<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JavaSE-进阶版 | XuGJia Blog</title><meta name="author" content="xuguangjia"><meta name="copyright" content="xuguangjia"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JavaSE进阶版，嘎嘎全面">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE-进阶版">
<meta property="og:url" content="http://xugjia.github.io/2022/11/13/Java-SE%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6%E7%89%88/index.html">
<meta property="og:site_name" content="XuGJia Blog">
<meta property="og:description" content="JavaSE进阶版，嘎嘎全面">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png">
<meta property="article:published_time" content="2022-11-13T00:00:00.000Z">
<meta property="article:modified_time" content="2022-11-14T02:23:16.620Z">
<meta property="article:author" content="xuguangjia">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://xugjia.github.io/2022/11/13/Java-SE%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6%E7%89%88/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaSE-进阶版',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-11-14 10:23:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 连接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XuGJia Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 连接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaSE-进阶版</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-13T00:00:00.000Z" title="发表于 2022-11-13 08:00:00">2022-11-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-14T02:23:16.620Z" title="更新于 2022-11-14 10:23:16">2022-11-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaSE-进阶版"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、抽象类和接口"><a href="#一、抽象类和接口" class="headerlink" title="一、抽象类和接口"></a>一、抽象类和接口</h1><h2 id="1、抽象类、接口以及抽象类和接口的区别。"><a href="#1、抽象类、接口以及抽象类和接口的区别。" class="headerlink" title="1、抽象类、接口以及抽象类和接口的区别。"></a>1、抽象类、接口以及抽象类和接口的区别。</h2><h3 id="1）、什么是抽象类？"><a href="#1）、什么是抽象类？" class="headerlink" title="1）、什么是抽象类？"></a>1）、什么是抽象类？</h3><pre><code>    抽象类是：类和类之间的共同特征，将这些具有共同特征的类再进一步抽象形成了抽象类。
    由于类本身是不存在的，所以抽象类无法创建对象。
</code></pre>
<h3 id="2）、抽象类属于什么类型？"><a href="#2）、抽象类属于什么类型？" class="headerlink" title="2）、抽象类属于什么类型？"></a>2）、抽象类属于什么类型？</h3><pre><code>    抽象类也属于引用数据类型
</code></pre>
<h3 id="3）、抽象类怎么定义？【能把基础语法先学会就行】"><a href="#3）、抽象类怎么定义？【能把基础语法先学会就行】" class="headerlink" title="3）、抽象类怎么定义？【能把基础语法先学会就行】"></a>3）、抽象类怎么定义？【能把基础语法先学会就行】</h3><pre><code>    语法：
        [修饰符列表] abstract class 类型&#123;
            类体;
        &#125;
</code></pre>
<h3 id="4）、抽象类是无法实例化的，无法创建对象，所以抽象类是用来被子类继承的"><a href="#4）、抽象类是无法实例化的，无法创建对象，所以抽象类是用来被子类继承的" class="headerlink" title="4）、抽象类是无法实例化的，无法创建对象，所以抽象类是用来被子类继承的."></a>4）、抽象类是无法实例化的，无法创建对象，所以抽象类是用来被子类继承的.</h3><h3 id="5）、final和abstract不能联合使用，这两个关键字是对立的。"><a href="#5）、final和abstract不能联合使用，这两个关键字是对立的。" class="headerlink" title="5）、final和abstract不能联合使用，这两个关键字是对立的。"></a>5）、final和abstract不能联合使用，这两个关键字是对立的。</h3><h3 id="6）、抽象类的子类可以是抽象类。"><a href="#6）、抽象类的子类可以是抽象类。" class="headerlink" title="6）、抽象类的子类可以是抽象类。"></a>6）、抽象类的子类可以是抽象类。</h3><h3 id="7）、抽象类虽然无法被实例化，但是抽象类有构造，构造方法是供子类使用的。"><a href="#7）、抽象类虽然无法被实例化，但是抽象类有构造，构造方法是供子类使用的。" class="headerlink" title="7）、抽象类虽然无法被实例化，但是抽象类有构造，构造方法是供子类使用的。"></a>7）、抽象类虽然无法被实例化，但是抽象类有构造，构造方法是供子类使用的。</h3><h3 id="8）、抽象类关联一个概念：抽象方法。什么是抽象方法呢？"><a href="#8）、抽象类关联一个概念：抽象方法。什么是抽象方法呢？" class="headerlink" title="8）、抽象类关联一个概念：抽象方法。什么是抽象方法呢？"></a>8）、抽象类关联一个概念：抽象方法。什么是抽象方法呢？</h3><pre><code>     抽象方法表示没有实现的方法，没有方法体的方法。例如:
        public abstract void doSome();
        抽象方法特点是：
            特点1：没有方法体，以分号结尾
            特点2：前面修饰符列表中有abstract关键字。
</code></pre>
<h3 id="9）、抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。"><a href="#9）、抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。" class="headerlink" title="9）、抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。"></a>9）、抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。</h3><pre><code>    public class AbstractTest01 &#123;
        public static void main(String[] args) &#123;
        //抽象类可以创建对象吗？
        //new Account(); 编译报错，Account是抽象的；无法实例化
        &#125;
    &#125;
    //银行账户抽象类
    abstract class Account&#123;
        //非抽象方法
        public void doOther()&#123;

        &#125;

        //抽象方法
        public abstract void withdraw();
    &#125;
    /*
    //子类继承抽象类，子类可以实例化对象
    class Creditaccount extends Account&#123;

    &#125;
    */

    /*
    //抽象类的子类可以是抽象类吗？可以
    abstract class Creditaccount extends Account&#123;

    &#125;
    */
</code></pre>
<h3 id="10）、重要结论：五颗星-（必须记住）"><a href="#10）、重要结论：五颗星-（必须记住）" class="headerlink" title="10）、重要结论：五颗星*****（必须记住）"></a>10）、重要结论：五颗星*****（必须记住）</h3><pre><code>        一个非抽象的类继承抽象的类，必须将抽象类中的抽象方法实现了。
        这里的覆盖/重写，也可以叫做实现。（对抽象的实现）
    public class AbstractTest02 &#123;
        public static void main(String[] args) &#123;
        //能不能使用多态？
        //父类型引用指向子类型对象。
        Animal b = new Bird(); //向上转型

        //这就是面向抽象编程。
        //以后调用的都是a.xxx
        //a的类型是Animal，Animal是抽象的
        //面向抽象编程，不要面向具体编程，降低程序的耦合度，提高程序的扩展力。
        //这种编程思想符合OCP原则。
        b.move();
        Animal c = new Cat();
        c.move();

        &#125;
    &#125;
    //动物类（抽象类）
    abstract class Animal&#123;
        //抽象方法
        public abstract void move();
    &#125;

    //子类（非抽象）
    //错误：Bird是抽象的，并且未覆盖Animal中的抽象方法move()
    class Bird extends Animal&#123;
        //需要将父类中继承过来的抽象方法惊醒覆盖/重写，或者也可以叫做“实现”。
        public void move()&#123;
        System.out.println(&quot;鸟儿在飞翔！&quot;);
        &#125;
    &#125;
    class Cat extends Animal&#123;
        public void move()&#123;
        System.out.println(&quot;小猫在爬树！&quot;);
        &#125;
    &#125;

    /*
    //如果Bird是抽象类的话，那么这个Animal中继承过来的抽象方法也可以不去重写/覆盖/实现。
    abstract class Bird extends Animal&#123;

    &#125;
    */
    /*
        有些内容不要死记硬背，讲讲道理。
        分析：
        Animal是父类，并且是抽象的
        Animal这个抽象类中有一个抽象方法move。

        Bird是子类，并且是非抽象的。
        Bird继承Animal之后，会将抽象方法继承过来。
    */
到目前为止，只是学习了抽象类的基础语法，一个类到底声明为抽象类还是非抽象类，这个以后慢慢来吧。
写代码多的时候自然就理解了。

面试题（判断题）：java语言中凡是没有方法体的方法都是抽象方法。
不对，错误的。
object类中就有很多方法都没有方法体，都是以“;”结尾的，但它们都不是抽象方法，例如：
    public native int hashCode();
    这个方法底层调用了C++写的动态链接库程序。
    前面修饰符列表中没有：abstract。有一个native表示调用JVM本地程序。
</code></pre>
<h2 id="2、接口的基础语法："><a href="#2、接口的基础语法：" class="headerlink" title="2、接口的基础语法："></a>2、接口的基础语法：</h2><h3 id="1）、接口也是一种引用数据类型。编译之后也是一个class字节码文件"><a href="#1）、接口也是一种引用数据类型。编译之后也是一个class字节码文件" class="headerlink" title="1）、接口也是一种引用数据类型。编译之后也是一个class字节码文件"></a>1）、接口也是一种引用数据类型。编译之后也是一个class字节码文件</h3><h3 id="2）、接口是完全抽象的。（抽象类是半抽象的）或者也可以说接口是特殊的抽象类。"><a href="#2）、接口是完全抽象的。（抽象类是半抽象的）或者也可以说接口是特殊的抽象类。" class="headerlink" title="2）、接口是完全抽象的。（抽象类是半抽象的）或者也可以说接口是特殊的抽象类。"></a>2）、接口是完全抽象的。（抽象类是半抽象的）或者也可以说接口是特殊的抽象类。</h3><h3 id="3）、接口怎么定义，语法是什么？"><a href="#3）、接口怎么定义，语法是什么？" class="headerlink" title="3）、接口怎么定义，语法是什么？"></a>3）、接口怎么定义，语法是什么？</h3><pre><code>        [修饰符列表] interface 接口名&#123;

        &#125;
</code></pre>
<h3 id="4）、接口支持多继承，一个接口可以继承多个接口。"><a href="#4）、接口支持多继承，一个接口可以继承多个接口。" class="headerlink" title="4）、接口支持多继承，一个接口可以继承多个接口。"></a>4）、接口支持多继承，一个接口可以继承多个接口。</h3><h3 id="5）、接口中只包含两部分内容，一部分是：常量；一部分是：抽象方法。接口中没有其它内容了，只有以上两部分。"><a href="#5）、接口中只包含两部分内容，一部分是：常量；一部分是：抽象方法。接口中没有其它内容了，只有以上两部分。" class="headerlink" title="5）、接口中只包含两部分内容，一部分是：常量；一部分是：抽象方法。接口中没有其它内容了，只有以上两部分。"></a>5）、接口中只包含两部分内容，一部分是：常量；一部分是：抽象方法。接口中没有其它内容了，只有以上两部分。</h3><h3 id="6）、接口中所有的元素都是public修饰的。（都是公开的）"><a href="#6）、接口中所有的元素都是public修饰的。（都是公开的）" class="headerlink" title="6）、接口中所有的元素都是public修饰的。（都是公开的）"></a>6）、接口中所有的元素都是public修饰的。（都是公开的）</h3><h3 id="7）、接口中的抽象方法定义时：public-abstract修饰符可以省略。"><a href="#7）、接口中的抽象方法定义时：public-abstract修饰符可以省略。" class="headerlink" title="7）、接口中的抽象方法定义时：public abstract修饰符可以省略。"></a>7）、接口中的抽象方法定义时：public abstract修饰符可以省略。</h3><h3 id="8）、接口中的方法都是抽象方法，所以不能带有方法体。"><a href="#8）、接口中的方法都是抽象方法，所以不能带有方法体。" class="headerlink" title="8）、接口中的方法都是抽象方法，所以不能带有方法体。"></a>8）、接口中的方法都是抽象方法，所以不能带有方法体。</h3><h3 id="9）、接口中常量的public-abstract修饰符可以省略。"><a href="#9）、接口中常量的public-abstract修饰符可以省略。" class="headerlink" title="9）、接口中常量的public abstract修饰符可以省略。"></a>9）、接口中常量的public abstract修饰符可以省略。</h3><pre><code>public class Test01 &#123;
    public static void main(String[] args) &#123;
    //访问接口的常量
    System.out.println(MyMath.PI);
    //常量能重新赋值吗？
    //编译报错：无法为最终变量PI分配值。
    //MyMath.PI = 3.1415926;
    &#125;
&#125;
//定义接口
interface A &#123;
&#125;

//接口支持继承
interface B extends A &#123;
&#125;

//接口支持多继承
interface C extends A , B &#123;
&#125;
//我的数学接口
interface MyMath&#123;
    //常量
    //public static final double PI = 3.141592653579;
    double PI = 3.141592653579;

    //public abstract int sum(int a , int b);

    //接口当中既然都是抽象方法，那么在编写代码的时候public abstract可以省略吗？【可以】
    int sum(int a , int b);

    //接口中的方法可以有方法体吗？【错误，接口抽象方法不能带有主体】
    /*
    void doSome()&#123;
    &#125;
    */
    //相加的抽象方法
    int sub(int a, int b);
&#125;
</code></pre>
<h2 id="3、接口的实现"><a href="#3、接口的实现" class="headerlink" title="3、接口的实现"></a>3、接口的实现</h2><h3 id="1）、类和类之间叫做继承，类和接口之间叫做实现。【别多想，仍然可以将“实现”看作“继承”】"><a href="#1）、类和类之间叫做继承，类和接口之间叫做实现。【别多想，仍然可以将“实现”看作“继承”】" class="headerlink" title="1）、类和类之间叫做继承，类和接口之间叫做实现。【别多想，仍然可以将“实现”看作“继承”】"></a>1）、类和类之间叫做继承，类和接口之间叫做实现。【别多想，仍然可以将“实现”看作“继承”】</h3><pre><code>         继承使用extends关键字完成；
         实现使用implements关键字完成。
</code></pre>
<h3 id="2）、非常重要的结论：当一个非抽象的类实现接口的话，必须将接口中所有的抽象方法全部实现-覆盖-重写。"><a href="#2）、非常重要的结论：当一个非抽象的类实现接口的话，必须将接口中所有的抽象方法全部实现-覆盖-重写。" class="headerlink" title="2）、非常重要的结论：当一个非抽象的类实现接口的话，必须将接口中所有的抽象方法全部实现/覆盖/重写。"></a>2）、非常重要的结论：当一个非抽象的类实现接口的话，必须将接口中所有的抽象方法全部实现/覆盖/重写。</h3><pre><code>    接口中有多少个抽象方法就要重写多少个！
    public class Test02 &#123;
        public static void main(String[] args) &#123;
        //能使用多态吗？【可以】
        //父类型的引用指向子类型的对象
        Math m = new MathImpl();
        //调用接口里的方法（面向接口编程）
        System.out.println(m.sum(1,2));
        &#125;
    &#125;
    interface Math&#123;
        double PI = 3.141592653579;
        int sum(int a , int b);
        int sub(int a, int b);
    &#125;
    //编写一个类（这个类是一个非抽象的类）
    //错误：MathImpl不是抽象的，并且未覆盖Math中的抽象方法sum(int, int)
    /*
    class MathImpl implements Math&#123;
    &#125;
    */
    //修正
    class MathImpl implements Math&#123;
        //重写/覆盖/实现接口中的方法（通常叫做实现）
        public int sum(int a,int b)&#123;
        return a + b;
        &#125;
        public int sub(int a,int b)&#123;
        return a - b;
        &#125;
    &#125;
</code></pre>
<h3 id="3）、接口和接口之间支持多继承，那么一个类可以同时实现多个接口吗？"><a href="#3）、接口和接口之间支持多继承，那么一个类可以同时实现多个接口吗？" class="headerlink" title="3）、接口和接口之间支持多继承，那么一个类可以同时实现多个接口吗？"></a>3）、接口和接口之间支持多继承，那么一个类可以同时实现多个接口吗？</h3><pre><code>     重点（五颗星*****）：一个类可以同时实现多个接口。
</code></pre>
<h3 id="4）、这种机制弥补了java中的哪个缺陷？"><a href="#4）、这种机制弥补了java中的哪个缺陷？" class="headerlink" title="4）、这种机制弥补了java中的哪个缺陷？"></a>4）、这种机制弥补了java中的哪个缺陷？</h3><pre><code>     java中类和类只支持单继承；实际上单继承是为了简单而出现的，现实世界中存在多继承，
     java中的接口弥补了单继承带来的缺陷。
</code></pre>
<h3 id="5）、接口A和接口B虽然没有继承关系，但是写代码的时候可以互转；不过运行的时候可能出现：ClassCastException异常。"><a href="#5）、接口A和接口B虽然没有继承关系，但是写代码的时候可以互转；不过运行的时候可能出现：ClassCastException异常。" class="headerlink" title="5）、接口A和接口B虽然没有继承关系，但是写代码的时候可以互转；不过运行的时候可能出现：ClassCastException异常。"></a>5）、接口A和接口B虽然没有继承关系，但是写代码的时候可以互转；不过运行的时候可能出现：ClassCastException异常。</h3><pre><code>     最终实际上还是和之前一样，需要加instanceof运算符进行判断；向下转型养成好习惯，
     转型之前先instanceof进行判断。
    public class Test03 &#123;
        public static void main(String[] args) &#123;
        //多态
        D d = new G();
        //d.m2();编译报错，D接口中没有m2方法
        d.m1(); //m1
        //调用其他接口中的方法需要转型（接口转型）
        ((E) d).m2(); //强转：d转换为E m2
        ((F) d).m3(); //强转：d转换为F m3
        System.out.println(&quot;--------&quot;);
        //直接转成G，m2，m3方法都可以调用
        ((G) d).m2();
        ((G) d).m3();
        E e1 = (E)d;
        //经过测试：接口和接口之间在进行强制类型转换的时候，没有继承关系也可以强转。
        //但是一定要注意，运行时可能会出现ClassCastException异常。
        &#125;
    &#125;
    interface D&#123;
        void m1();
    &#125;
    interface E&#123;
        void m2();
    &#125;
    interface F&#123;
        void m3();
    &#125;
    class G implements D,E,F&#123;
        //实现D接口中的m1
        public void m1()&#123;
        System.out.println(&quot;m1&quot;);
        &#125;
        //实现E接口中的m2
        public void m2() &#123;
        System.out.println(&quot;m2&quot;);
        &#125;
        //实现F接口中的m3
        public void m3() &#123;
        System.out.println(&quot;m3&quot;);
        &#125;
    &#125;
</code></pre>
<h3 id="6）、继承和实现都存在的话，代码该怎么写？"><a href="#6）、继承和实现都存在的话，代码该怎么写？" class="headerlink" title="6）、继承和实现都存在的话，代码该怎么写？"></a>6）、继承和实现都存在的话，代码该怎么写？</h3><pre><code>    extends关键字在前，implements关键字在后
    public class Test04 &#123;
        public static void main(String[] args) &#123;
        //表面看Animal没起作用
        Flyable f = new Cat();//多态
        f.Fly();

        Flyable f2 = new Pig();
        f2.Fly();
        &#125;
    &#125;
    //动物类：父类
    class Animal&#123;
    &#125;
    //可飞翔的接口(是一对翅膀)
    //能插拔的就是接口
    interface Flyable&#123;
        void Fly();
    &#125;
    //动物类子类：猫类
    //Flyable是一个接口，是一对翅膀的接口，通过接口插到猫身上
    class Cat extends Animal implements Flyable&#123;
        public void Fly() &#123;
        System.out.println(&quot;飞猫起飞：翱翔太空的一只猫，很神奇！&quot;);
        &#125;
    &#125;
    //蛇类，如果不想让它飞，可以不实现Flyable接口
    class Snake extends Animal&#123;

    &#125;
    //想飞就插翅膀
    class Pig extends Animal implements Flyable&#123;
        public void Fly() &#123;
        System.out.println(&quot;猪猪想起飞！&quot;);
        &#125;
    &#125;
    //没写extends也是有继承的，默认继承object
    class Fish implements Flyable&#123;
        public void Fly() &#123;
        System.out.println(&quot;飞鱼！&quot;);
        &#125;
    &#125;
</code></pre>
<h2 id="4、接口在开发中的作用"><a href="#4、接口在开发中的作用" class="headerlink" title="4、接口在开发中的作用"></a>4、接口在开发中的作用</h2><pre><code>*注意：接口在开发中的作用，类似于多态在开发中的作用
*多态：面向抽象编程，不要面向具体编程；降低程序的耦合度，提高程序的扩展力。
*接口在开发中的作用？
    接口是不是完全抽象的？【是】
    而我们以后正好要求，面向抽象编程。
    面向抽象编程这句话以后可以修改为：面向接口编程
    有了接口就有了可插拔，可插拔表示扩展力很强，不是焊死的。

    主板和内存条之间有插槽，这个插槽就是接口，内存条坏了，可以重新买一个换下来，
    这就叫做高扩展性（低耦合度）。
*总结一句话：面向接口编程，可以降低程序的耦合度，提高程序的扩展力，符合OCP开发原则。
*接口的使用离不开多态机制。（接口 + 多态才可以达到解耦合）
*接口可以解耦合，接的是谁的耦合？
    任何一个接口都有调用者和实现者；接口可以将调用者和实现者解耦合；
    调用者面向接口调用，实现者面向接口实现。
*以后进行大项目的开发，一般都是将项目分成一个模块一个模块的，模块和模块之间采用接口衔接，降低耦合度。【最难的是定接口】
</code></pre>
<h3 id="1）、实例：顾客拿菜单（接口）点餐，厨师按照菜单做菜【厨师是菜单的实现者】"><a href="#1）、实例：顾客拿菜单（接口）点餐，厨师按照菜单做菜【厨师是菜单的实现者】" class="headerlink" title="1）、实例：顾客拿菜单（接口）点餐，厨师按照菜单做菜【厨师是菜单的实现者】"></a>1）、实例：顾客拿菜单（接口）点餐，厨师按照菜单做菜【厨师是菜单的实现者】</h3><pre><code>//菜单【接口】
interface FoodMenu &#123;
    //西红柿炒蛋
    void shiZichaojidan();
    //鱼香肉丝
    void yuXiangrousi();
&#125;

//中餐厨师
//实现菜单上的菜
//厨师是接口的实现者
class ChinaCooker implements FoodMenu&#123;
    //西红柿炒蛋
    public void shiZichaojidan()&#123;
       System.out.println(&quot;中餐师傅做的西红柿炒蛋&quot;);
    &#125;
    //鱼香肉丝
    public void yuXiangrousi()&#123;
       System.out.println(&quot;中餐师傅做的鱼香肉丝&quot;);
    &#125;
&#125;

//西餐厨师
class AmericCooker implements FoodMenu&#123;
    //西红柿炒蛋
    public void shiZichaojidan()&#123;
       System.out.println(&quot;西餐师傅做的西红柿炒蛋&quot;);
    &#125;
    //鱼香肉丝
    public void yuXiangrousi()&#123;
       System.out.println(&quot;西餐师傅做的鱼香肉丝&quot;);
    &#125;
&#125;

//顾客
class Customer&#123;
    //顾客手里有一个菜单
    //Customer has a FoodMenu！
    //记住：以后凡是能够用has a来描述的，统一以属性的方式存在。
    //面向抽象编程，面向接口编程。
    private FoodMenu foodmenu; //都要养成封装的好习惯

    //如果以下这样写，就表示写死了（焊接住了;没有可插拔了）
    //ChinaCooker cc;
    //AmericCooker ac;

    //构造有参数的方法
    //给属性赋值
    public void doSome(FoodMenu foodmenu)&#123;
       this.foodmenu = foodmenu;
    &#125;

    //setter and getter

    public FoodMenu getFoodmenu() &#123;
       return foodmenu;
    &#125;

    public void setFoodmenu(FoodMenu foodmenu) &#123;
       this.foodmenu = foodmenu;
    &#125;
    //提供一个点菜的方法
    public void order()&#123;
       //先拿到菜单
       //调用get方法拿菜单
       //FoodMenu fm = this.getFoodmenu();
       //也可以不调用get方法，因为在本类中私有的属性是可以访问的。
       foodmenu.shiZichaojidan();
       foodmenu.yuXiangrousi();
    &#125;
&#125;
public class Test01 &#123;
    public static void main(String[] args) &#123;
       //创建顾客对象
       Customer c = new Customer();
       //顾客拿中国厨师菜单
       c.doSome(new ChinaCooker());
       //顾客点菜
       c.order();

       //通过调用c的set方法改变顾客手里的菜单
       c.setFoodmenu(new AmericCooker());
       c.order();
    &#125;
&#125;
</code></pre>
<h2 id="5、类型和类型之间的关系："><a href="#5、类型和类型之间的关系：" class="headerlink" title="5、类型和类型之间的关系："></a>5、类型和类型之间的关系：</h2><pre><code>is a(继承)、has a(关联)、like a(实现)
    *is a：
        Cat is a Animal(猫是一个动物)
        凡是能够满足is a的表示“继承关系”
        A extends B;
    *has a：
        I has a pen(我有一支笔)
        凡是能够满足has a的表示“关联关系”
        关联关系一般以“属性”的形式存在。
        A&#123;
            B b;
        &#125;
    *like a：
        Cooker like a foodmenu(厨师像一个菜单一样)
        凡是能狗满足like a关系的表示“实现关系”
        实现关系通常是：类实现接口。
        A implements B;
</code></pre>
<h2 id="6、抽象类和接口有什么区别？"><a href="#6、抽象类和接口有什么区别？" class="headerlink" title="6、抽象类和接口有什么区别？"></a>6、抽象类和接口有什么区别？</h2><pre><code>在这里我们只说以下抽象类和接口在语法上的区别；至于以后抽象类和接口应该怎么进行选择，
通过后面的项目去体会/学习。
    *抽象类是半抽象的
     接口是完全抽象的
    
    *抽象类中有构造方法
     接口中没有构造方法
    
    *接口和接口之间支持多继承
     类和类之间只能单继承
    
    *一个类可以同时实现多个接口
     一个抽象类只能继承一个类（单继承）
    
    *接口中只允许出现常量和抽象方法。

    这里先透露一个信息：
        以后接口使用的比抽象类多，一般抽像类使用的少；接口一般都是对“行为”的抽象。
</code></pre>
<h1 id="二、JDK类库的根类：Object"><a href="#二、JDK类库的根类：Object" class="headerlink" title="二、JDK类库的根类：Object"></a>二、JDK类库的根类：Object</h1><h3 id="1）、这个老祖宗类中的方法我们需要研究一下，因为这些方法都是所有子类通用的。任何一个类默认继承Object，就算没有直接继承，最终也会间接继承。"><a href="#1）、这个老祖宗类中的方法我们需要研究一下，因为这些方法都是所有子类通用的。任何一个类默认继承Object，就算没有直接继承，最终也会间接继承。" class="headerlink" title="1）、这个老祖宗类中的方法我们需要研究一下，因为这些方法都是所有子类通用的。任何一个类默认继承Object，就算没有直接继承，最终也会间接继承。"></a>1）、这个老祖宗类中的方法我们需要研究一下，因为这些方法都是所有子类通用的。任何一个类默认继承Object，就算没有直接继承，最终也会间接继承。</h3><h3 id="2）、Object类当中有哪些常用的方法？"><a href="#2）、Object类当中有哪些常用的方法？" class="headerlink" title="2）、Object类当中有哪些常用的方法？"></a>2）、Object类当中有哪些常用的方法？</h3><pre><code>    我们去哪里找这些方法呢？
    第一种方法：去源代码当中。（但是这种方式比较麻烦，源代码也比较难）
    第二种方法：去查阅java的类库的帮助文档。

    什么是API？
        应用程序编程接口。(Application Program Interface)
        整个JDK的类库就是一个API；
        每一个API都会配置一套API帮助文档。
        SUN公司提前写好的这套类库就是API。（一般每一个API都对应一份API帮文档）
    
    目前为止我们只需要知道这几个方法即可
        protected Object clone() //负责对象克隆的
        boolean    equals(Object obj) //判断两对象是否相等
        protected void    finalize() //垃圾回收器调用的方法
        int    hashCode() //获取对象哈希值的一个方法
        String    toString() //将对象转换成字符串形式
</code></pre>
<h3 id="3）、关于Object类中的toString-方法"><a href="#3）、关于Object类中的toString-方法" class="headerlink" title="3）、关于Object类中的toString()方法"></a>3）、关于Object类中的toString()方法</h3><pre><code>    *源代码长什么样？
    public String toString() &#123;
        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
    &#125;
    源代码上toString()方法的默认实现是：
        类名@对象的内存地址转换为十六进制的形式
    *SUN公司设计toString()方法的目的是什么？
         toString()方法的作用是什么？
            toString()方法设计的目的是：通过调用这个方法可以将一个“java对象”转换成“字符串表现形式”
    *其实SUN公司开发java语言的时候，建议所有的子类都去重写toString()方法。
        toString()方法应该是一个简洁的、详实的、易阅读的。
    public class Test01 &#123;
        public static void main(String[] args) &#123;
           MyTime t1 = new MyTime(1970,1,1);
           //一个日期对象转换陈该字符串形式的话 ，我可能还是希望能看到具体的日期信息。
           String s1 = t1.toString();
           //MyTime类重写toString()方法之前
           //System.out.println(s1); //MyTime@十六进制
           //MyTime类重写toString()方法之后
           System.out.println(s1); //1970年1月1日
           System.out.println(t1.toString());
           //输出引用的时候，会自动调用该引用的toString()方法
           System.out.println(t1);

        &#125;
    &#125;
    class MyTime&#123;
        int year;
        int month;
        int day;
        public MyTime()&#123;

        &#125;

        public MyTime(int year,int month,int day)&#123;
           this.year = year;
           this.month = month;
           this.day = day;
        &#125;

        //重写toString()方法
        //这个toString()方法怎么重写呢？
        //越简洁越好，可读性越强越好。
        //向简洁的、详实的、易阅读的方向发展
        public String toString()&#123;
           return this.year + &quot;年&quot; + this.month + &quot;月&quot; + this.day + &quot;日&quot;;
        &#125;
    &#125;
</code></pre>
<h3 id="4）、关于Object类中的equals方法"><a href="#4）、关于Object类中的equals方法" class="headerlink" title="4）、关于Object类中的equals方法"></a>4）、关于Object类中的equals方法</h3><pre><code>    *equals方法的源代码
     public boolean equals(Object obj) &#123;
        return (this == obj);
     &#125;
     以上这个方法是Object类的默认实现。

    *SUN公司设计equals方法的目的是什么？
     以后编程的过程当中，都要通过equals方法来判断两个对象是否相等。
     equals方法是判断两个对象是否相等的。

    *我们需要研究以下Object类给的这个默认的equals方法够不够用！！！！
     在Object类中的方法当中，默认采用的是“==”判断两个对象是否相等。而“==”判断的是两个java对象的内存地址，我们应该判断
     两个java对象的内容是否相等。所以老祖宗的equals方法不够用，需要子类重写equals

    *判断两个java对象是否相等不能使用“==”，因为“==”比较的是两个对象的内存地址。

    public class Equals &#123;
        public static void main(String[] args) &#123;
           //判断两个基本数据类型是否相等直接使用“==”就行。
           int a = 100;
           int b = 100;
           //这个“==”判断的是a中保存的100和b中保存的100是否相等。
           System.out.println(a == b); //true(相等);false(不等)

           //判断两个java对象是否相等，我们该怎么办？能直接使用“==”吗？
           //创建一个日期对象：2008年8月8日
           Time t1 = new Time(2008,8,8);
           //创建一个新的日期对象，但表示的也是：2008年8月8日
           Time t2 = new Time(2008,8,8);

           //测试一下，比较两个对象是否相等能不能用“==”？
           //这里的“==”判断的是：t1中保存的对象内地址和t2中保存的对象内存地址是否相等。
           System.out.println(t1 == t2); //false

           //重写Object equals方法之前
           /*
           boolean bl = t1.equals(t2);
           System.out.println(bl); //false
           */
           //重写Object equals方法之后
           boolean bl = t1.equals(t2);
           System.out.println(bl); //true

           Time t3 = new Time(2008,9,8);
           System.out.println(t1.equals(t3)); //false

           //我们这个程序有BUG吗？可以运行，但是效率低(怎么改造)
           Time t4 = null;
           System.out.println(t1.equals(t4));//false

        &#125;
    &#125;
    class Time&#123; //默认继承extends Object
        int year;
        int month;
        int day;
        public Time()&#123;

        &#125;

        public Time(int year,int month,int day)&#123;
           this.year = year;
           this.month = month;
           this.day = day;
        &#125;

        //重写toString()方法
        //这个toString()方法怎么重写呢？
        //越简洁越好，可读性越强越好。
        //向简洁的、详实的、易阅读的方向发展
        public String toString()&#123;
           return this.year + &quot;年&quot; + this.month + &quot;月&quot; + this.day + &quot;日&quot;;
        &#125;

        //默认的equals方法
        /*
        public boolean equals(Object obj) &#123;
              return (this == obj);
        &#125;
        */

        /*
        //重写Object类的equals方法
        public boolean equals(Object obj) &#123;
           //当年相同，月相同，日期相同的时候，表示两个日期相同，两个对象相等
           //获取第一个日期的年月日
           //this.year ...其中this.可以省略
           //获取第二个日期的年月日
           //由于obj中没有year等属性，所以需要进行强转：将obj类型强转为Time类型
           if(obj instanceof Time)&#123;
             Time t =  (Time)obj;
             //开始比较
              return (this.year == t.year &amp;&amp; month ==t.month &amp;&amp; day == t.day);
           &#125;
           return false;
        &#125;
        */
        //改良的equals方法
        public boolean equals(Object obj) &#123;
           //如果obj是空或者obj不是一个Time，返回false
           if(obj == null || !(obj instanceof Time))&#123;
              return false;
           &#125;
           Time t = (Time)obj;
           return this.year == t.year &amp;&amp; month ==t.month &amp;&amp; day == t.day;
        &#125;
    &#125;
</code></pre>
<h3 id="5）、String有没有重写equals方法和toString方法："><a href="#5）、String有没有重写equals方法和toString方法：" class="headerlink" title="5）、String有没有重写equals方法和toString方法："></a>5）、String有没有重写equals方法和toString方法：</h3><pre><code>    *String类已经重写了equals方法，比较两个字符串不能使用“==”，必须使用equals，equals是通用的。
    *String类已经重写了toString方法，输出引用的时候，会自动调用该引用的toString()方法。
    *String对象比较的时候必须使用equals方法
    public class EqualsTest02 &#123;
        public static void main(String[] args) &#123;
           Student s1 = new Student(1,&quot;南信大&quot;);
           Student s2 = new Student(1,&quot;南信大&quot;);
           Student s3 = new Student(2,&quot;南邮&quot;);
           System.out.println(s1.equals(s2)); //true
           System.out.println(s1.equals(s3)); //false
           System.out.println(s2.equals(s3)); //false
        &#125;
    &#125;
    class Student&#123;
        //学号
        int no;
        //所在学校
        String school;

        public Student(int no, String school) &#123;
           this.no = no;
           this.school = school;
        &#125;

        //重写toString方法
        public String toString()&#123;
           return &quot;学号:&quot; + no + &quot; ，所在学校名称：&quot; + school;
        &#125;
        //重写equals方法
        //需求：当一个学生的学号相等，并且学校相同时，表示同一个学生。

        public boolean equals(Object obj)&#123;
           if (obj == null || !(obj instanceof Student))&#123;
              return false;
           &#125;
           if (this == obj)&#123;
              return true;
           &#125;
           Student s = (Student)obj;
           //字符串比较用equals
           return this.no == s.no &amp;&amp; school.equals(s.school);
        &#125;
    &#125;
</code></pre>
<h3 id="6）、重写equals方法的时候要彻底："><a href="#6）、重写equals方法的时候要彻底：" class="headerlink" title="6）、重写equals方法的时候要彻底："></a>6）、重写equals方法的时候要彻底：</h3><pre><code>    public class EqualsTest03 &#123;
        public static void main(String[] args) &#123;
           User u1 = new User(&quot;zhangsan&quot;,new Address(&quot;nanjing&quot;,&quot;nanjing&quot;,&quot;223&quot;));
           User u2 = new User(&quot;zhangsan&quot;,new Address(&quot;nanjing&quot;,&quot;nanjing&quot;,&quot;223&quot;));
           User u3 = new User(&quot;lisi&quot;,new Address(&quot;nanjing&quot;,&quot;nanjing&quot;,&quot;223&quot;));
           User u4 = new User(&quot;zhangsan&quot;,new Address(&quot;beijing&quot;,&quot;nanjing&quot;,&quot;223&quot;));
           System.out.println(u1.equals(u2)); //true
           System.out.println(u1.equals(u3)); //false
           System.out.println(u1.equals(u4)); //false
        &#125;
    &#125;
    class User&#123;
        //用户名
        String name;
        //用户的住址
        Address addr;
        //有参数的构造方法
        public User(String name, Address addr) &#123;
           this.name = name;
           this.addr = addr;
        &#125;
        //重写equals方法
        //重写规则：当一个用户的用户名和家庭住址都相同，表示同一个用户
        //这个equals判断的是User和User对象是否相等
        public boolean equals(Object obj)&#123;
           if (obj == null || !(obj instanceof User))&#123;
              return false;
           &#125;
           if (this == obj)&#123;
              return true;
           &#125;
           //return this.name.equals((User)obj.name) &amp;&amp; this.addr.equals((User)obj.addr);
           //编译错误：调用强转(User)obj的属性，需要给整体加括号之后((User)obj)在&quot;.属性&quot;：((User)obj).addr
           return this.name.equals(((User)obj).name) &amp;&amp; this.addr.equals(((User)obj).addr);
        &#125;
    &#125;
    class Address&#123;
        String city;
        String street;
        String zipcode;

        public Address(String city,String street,String zipcode)&#123;
           this.city = city;
           this.street = street;
           this.zipcode = zipcode;
        &#125;

        //这个equals判断的是Address和Address对象是否相等。
        public boolean equals(Object obj)&#123;
           if(obj == null || !(obj instanceof Address))&#123;
              return false;
           &#125;
           if (this == obj)&#123;
              return true;
           &#125;
           Address ad = (Address)obj;
           return this.city.equals(ad.city) &amp;&amp; street.equals(ad.street) &amp;&amp; zipcode.equals(ad.zipcode);
        &#125;
    &#125;
</code></pre>
<h3 id="7）、关于Object类中的finalize方法（非重点，了解即可）"><a href="#7）、关于Object类中的finalize方法（非重点，了解即可）" class="headerlink" title="7）、关于Object类中的finalize方法（非重点，了解即可）"></a>7）、关于Object类中的finalize方法（非重点，了解即可）</h3><pre><code>    *这个方法是protected修饰的，在Object类中这个方法的源代码：
        protected void finalize() throws Throwable &#123; &#125;

        GC：负责调用fianlize()方法。

    *fianlize()方法只有一个方法体，里面没有代码，而且这个方法是protected修饰的。

    *这个方法不需要程序员手动调用，JVM的垃圾回收器负责调用这个方法。
     不像equals、toString，equals和toString()方法是需要重写完调用的；
     fianlize()只需要重写完将来自动会有程序来调用。

    *fianlize()方法的执行时机：
        当一个java对象即将被垃圾回收器回收的时候，垃圾回收器负责调用fianlize()方法。

    *fianlize()方法实际上是SUN公司为jaa程序员准备的一个时机，垃圾销毁时机；
    如果希望在对象销毁实际执行一段代码的话，
     这段代码要写道fianlize()方法中。

    *静态代码块的作用是什么？
        static&#123;
            .....
        &#125;
     静态代码块在类加载时刻执行，并且只能执行一次。
     这是一个SUN准备的类加载时机。

     fianlize()方法同样是SUN为程序员准备的一个时机；这个时机是垃圾回收时机。

    *提示：java中的垃圾回收器不是轻易启动的，垃圾太少，或者时间没到，种种条件下，
    有可能启动，也有可能不启动。
    public class FinalizeTest01 &#123;
        public static void main(String[] args) &#123;
           /*
           //多制造点垃圾
           for(int i = 1;i &lt; 1000000;i++) &#123;//创建对象
              Person p = new Person();
              //怎么把Person对象编程垃圾？
              p = null;
           &#125;
           */
           Person p = new Person();
           p = null;
           //有一段代码可以建立垃圾回收器启动。
           System.gc();//建议启动垃圾回收器。(只是建议，可能不启动，启动的概率高了一些)
        &#125;
    &#125;
    //项目开发中有这样的需求：所有对象在JVM中被释放的时候，请记录一下施放时间。
    //记录对象被释放的时间点，这个负责记录的代码写道finalize()方法中。
    class Person&#123;
        //重写fianlize()方法
        //Person类型的对象被垃圾回收器回收的时候，垃圾回收器负责调用P.finalize();
        protected void finalize() throws Throwable &#123;
           System.out.println(&quot;即将被销毁！&quot;);
        &#125;
    &#125;
</code></pre>
<h3 id="8）、关于Object类库中的hashCode-方法："><a href="#8）、关于Object类库中的hashCode-方法：" class="headerlink" title="8）、关于Object类库中的hashCode()方法："></a>8）、关于Object类库中的hashCode()方法：</h3><pre><code>    public native int hashCode();
    这个方法不是抽象方法，带有native关键字，底层调用C++程序。

    hashCode()方法返回的是哈希码：
        实际上就是一个Java对象的内存地址，经过哈希算法，得出的一个值；
        所以hashCode()方法执行结果可以看做一个java对象的内存地址。
    public class HashcodeTest01 &#123;
        public static void main(String[] args) &#123;
           Object o = new Object();
           int hashCodeValue = o.hashCode(); //返回值是整数型
           //对象内存地址经过哈希算法转换的一个数字，可以等同看做内存地址。
           System.out.println(hashCodeValue); //603742814
        &#125;
    &#125;
</code></pre>
<h3 id="9）、匿名内部类-类没有名字-："><a href="#9）、匿名内部类-类没有名字-：" class="headerlink" title="9）、匿名内部类(类没有名字)："></a>9）、匿名内部类(类没有名字)：</h3><pre><code>       *什么是内部类？
          内部类：在类的内部有定义了一个新的类，被称为内部类。
       *内部类分类：
          静态内部类：类似于静态变量
          实例内部类：类似于实例变量
          局部内部类：类似于局部变量
       *使用内部类编写的代码可读性很差，能不用尽量不用。

       *匿名内部类是局部内部类的一种；因为这个类没有名字而得名

       *不建议使用内部类：因为一个类没有名字无法重复使用，并且代码太乱，可读性太差。
    public class AnonymousInnerClassTest01 &#123;
        public static void main(String[] args) &#123;
           //调用MyMath中的sum方法
           MyMath mm = new MyMath();
           //mm.sum(new ComputeImpl(),100,200 );
           //采用匿名内部类
           //这表面看上去可以new了，实际上并不是接口可以new了，后面的&#123;&#125;代表了对接口的实现。
           mm.sum(new Compute() &#123;
              public int sum(int a, int b) &#123;
                 return a + b;
              &#125;
           &#125;,100,200);
        &#125;

        //该类在类的内部，所以称为内部类
        //由于前面有static，所以称为&quot;静态内部类&quot;
        static class Inter1&#123;

        &#125;
        //该类在类的内部，所以称为内部类
        //没有static叫做&quot;实例内部类&quot;
        class Inter2&#123;

        &#125;
        public void doSome()&#123;
           ////该类在类的内部，所以称为内部类
           //局部内部类
           class Inter3&#123;

           &#125;
        &#125;

        public void doOther()&#123;
           //doSome()方法中的局部内部类Inter3，在doOther()方法中不能用。
        &#125;
    &#125;

    //负责计算的接口
    interface Compute&#123;
        //抽象方法
        int sum(int a,int b);
    &#125;
    /*
    //你自动会在这里编写一个Compute接口的实现类
    class ComputeImpl implements Compute&#123;
        //对方法的实现
        public int sum(int a,int b)&#123;
           return a + b;
        &#125;
    &#125;
    */

    //数学类
    class MyMath&#123;
        //数学求和方法
        public void sum(Compute c,int x,int y)&#123;
           int retValue =  c.sum(x,y);
           System.out.println(x + &quot; + &quot; + y + &quot; = &quot; + retValue);
        &#125;
    &#125;
</code></pre>
<h1 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h1><h2 id="1、关于java语言中的数组-Array"><a href="#1、关于java语言中的数组-Array" class="headerlink" title="1、关于java语言中的数组(Array):"></a>1、关于java语言中的数组(Array):</h2><h3 id="1）、java语言中的数组是一种引用数据类型，不属于基本数据类型；数组的父类是Object类。"><a href="#1）、java语言中的数组是一种引用数据类型，不属于基本数据类型；数组的父类是Object类。" class="headerlink" title="1）、java语言中的数组是一种引用数据类型，不属于基本数据类型；数组的父类是Object类。"></a>1）、java语言中的数组是一种引用数据类型，不属于基本数据类型；数组的父类是Object类。</h3><h3 id="2）、数组是一个容器，可以容纳多个元素。-数组是一个数据的集合"><a href="#2）、数组是一个容器，可以容纳多个元素。-数组是一个数据的集合" class="headerlink" title="2）、数组是一个容器，可以容纳多个元素。(数组是一个数据的集合)"></a>2）、数组是一个容器，可以容纳多个元素。(数组是一个数据的集合)</h3><h3 id="3）、数组当中可以存储”基本数据类型”的数据，也可以存储”引用数据类型”的数据。"><a href="#3）、数组当中可以存储”基本数据类型”的数据，也可以存储”引用数据类型”的数据。" class="headerlink" title="3）、数组当中可以存储”基本数据类型”的数据，也可以存储”引用数据类型”的数据。"></a>3）、数组当中可以存储”基本数据类型”的数据，也可以存储”引用数据类型”的数据。</h3><h3 id="4）、数组因为是引用数据类型，所以数组对象是存储在堆内存当中的。"><a href="#4）、数组因为是引用数据类型，所以数组对象是存储在堆内存当中的。" class="headerlink" title="4）、数组因为是引用数据类型，所以数组对象是存储在堆内存当中的。"></a>4）、数组因为是引用数据类型，所以数组对象是存储在堆内存当中的。</h3><h3 id="5）、对于数组当中如果存储的是”java对象”的话实际上存储的是对象的”引用-内存地址-”"><a href="#5）、对于数组当中如果存储的是”java对象”的话实际上存储的是对象的”引用-内存地址-”" class="headerlink" title="5）、对于数组当中如果存储的是”java对象”的话实际上存储的是对象的”引用(内存地址)”"></a>5）、对于数组当中如果存储的是”java对象”的话实际上存储的是对象的”引用(内存地址)”</h3><h3 id="6）、数组一旦创建，在java中规定长度不可变。"><a href="#6）、数组一旦创建，在java中规定长度不可变。" class="headerlink" title="6）、数组一旦创建，在java中规定长度不可变。"></a>6）、数组一旦创建，在java中规定长度不可变。</h3><h3 id="7）、数组的分类：一维数组、二维数组、三位数组、多维数组…-一维数组较多，二维数组偶尔使用！"><a href="#7）、数组的分类：一维数组、二维数组、三位数组、多维数组…-一维数组较多，二维数组偶尔使用！" class="headerlink" title="7）、数组的分类：一维数组、二维数组、三位数组、多维数组…..(一维数组较多，二维数组偶尔使用！)"></a>7）、数组的分类：一维数组、二维数组、三位数组、多维数组…..(一维数组较多，二维数组偶尔使用！)</h3><h3 id="8）、所有的数组对象都有length属性-java自带的-，用来获取数组中元素的个数。"><a href="#8）、所有的数组对象都有length属性-java自带的-，用来获取数组中元素的个数。" class="headerlink" title="8）、所有的数组对象都有length属性(java自带的)，用来获取数组中元素的个数。"></a>8）、所有的数组对象都有length属性(java自带的)，用来获取数组中元素的个数。</h3><h3 id="9）、java中的数组要求数组中元素的类型统一；比如int类型数组只能存储int类型、Person数组只能存储Person类型。"><a href="#9）、java中的数组要求数组中元素的类型统一；比如int类型数组只能存储int类型、Person数组只能存储Person类型。" class="headerlink" title="9）、java中的数组要求数组中元素的类型统一；比如int类型数组只能存储int类型、Person数组只能存储Person类型。"></a>9）、java中的数组要求数组中元素的类型统一；比如int类型数组只能存储int类型、Person数组只能存储Person类型。</h3><h3 id="10）、数组在内存方面存储的时候，数组中的元素内存地址是连续的。-存储的每一个元素都是有规则的挨着排列的"><a href="#10）、数组在内存方面存储的时候，数组中的元素内存地址是连续的。-存储的每一个元素都是有规则的挨着排列的" class="headerlink" title="10）、数组在内存方面存储的时候，数组中的元素内存地址是连续的。(存储的每一个元素都是有规则的挨着排列的)"></a>10）、数组在内存方面存储的时候，数组中的元素内存地址是连续的。(存储的每一个元素都是有规则的挨着排列的)</h3><pre><code>         内存地址连续，这是数组存储元素额特点(特色)。数组实际上是一种简单的数据结构。
</code></pre>
<h3 id="11）、所有的数组都是拿”第一个小方框的内存地址”作为整个数组对象的内存地址。"><a href="#11）、所有的数组都是拿”第一个小方框的内存地址”作为整个数组对象的内存地址。" class="headerlink" title="11）、所有的数组都是拿”第一个小方框的内存地址”作为整个数组对象的内存地址。"></a>11）、所有的数组都是拿”第一个小方框的内存地址”作为整个数组对象的内存地址。</h3><pre><code>         数组中首元素的内存地址作为整个对象的内存地址。
</code></pre>
<h3 id="12）、数组中每一个元素都是有下标的，下标从0开始，以一递增，最后一个下标是-length-1"><a href="#12）、数组中每一个元素都是有下标的，下标从0开始，以一递增，最后一个下标是-length-1" class="headerlink" title="12）、数组中每一个元素都是有下标的，下标从0开始，以一递增，最后一个下标是[length-1]"></a>12）、数组中每一个元素都是有下标的，下标从0开始，以一递增，最后一个下标是[length-1]</h3><pre><code>         下标非常重要，因为我们对数组中的元素进行&quot;存取&quot;的时候都需要通过下标来进行。
</code></pre>
<h3 id="13）、数组这种数据结构的优点和缺点是什么？"><a href="#13）、数组这种数据结构的优点和缺点是什么？" class="headerlink" title="13）、数组这种数据结构的优点和缺点是什么？"></a>13）、数组这种数据结构的优点和缺点是什么？</h3><pre><code>         优点：查询/查找/检索某个下标上的元素是效率极高，可以说是查询效率最高的数据结构。
               为什么检索效率高？
                    第一：每一个元素的内存地址在空间存储上是连续的
                    第二：每一个元素类型相同，所以占用空间大小一样
                    第三：知道第一个元素内存地址，知道每一个元素占用空间大小，有知道下标，
                    可以通过一个数学表达式计算出某个下标上元素的内存地址；
                    直接通过内存地址定位元素，所以数组的检索效率最高。
         缺点：
              第一：由于为了保证数组中每个元素的内存地址连续，
              所以在数组上随机删除或者增加元素的时候效率较低，
              因为增删元素会涉及到后面元素向前或者向后位移的操作。
              第二：数组不能存储大数据量，因为很难在内存空间上找到一块特别的大的连续的内存空间。
              注意：对于数组中最后一个元素的增删，是没有效率影响的.
</code></pre>
<h3 id="14）、怎么声明-定义一个一维数组？"><a href="#14）、怎么声明-定义一个一维数组？" class="headerlink" title="14）、怎么声明/定义一个一维数组？"></a>14）、怎么声明/定义一个一维数组？</h3><pre><code>            语法格式：
                int[] array1;
                double[] array2;
                boolean[] array3;
                String[] array4;
</code></pre>
<h3 id="15）、怎么初始化一个一维数组呢？"><a href="#15）、怎么初始化一个一维数组呢？" class="headerlink" title="15）、怎么初始化一个一维数组呢？"></a>15）、怎么初始化一个一维数组呢？</h3><pre><code>          包括两种方式：静态初始化一维数组、动态初始化一维数组。
          静态初始化语法格式：
              int[] array = &#123;100,200,300&#125;;
          动态初始化语法格式：
              int[] array = new int[5]; //这里的5表示数组的元素个数；
              初始化一个5个长度的int类型数组，
              每一元素默认值为0
              String[] array = new String[6]; //初始化6个长度的String类型数组，
              每一元素默认值为null。
    public class ArrayTest01 &#123;
        public static void main(String[] args) &#123;

           //声明一个int类型的数组，使用静态初始化的方式
           int[] a = &#123;1,100,10,20,55,68&#125;;
           //这样也可以C++风格，不建议java中使用。
           //int a[] = &#123;1,100,10,20,55,68&#125;;
           //所有的数组对象都有length属性
           System.out.println(&quot;数组中元素的个数：&quot; + a.length);
           //数组中每一个元素都有下标
           //通过下标对数组中的元素进行存和取
           //取
           System.out.println(&quot;第一个元素：&quot; + a[0]);
           System.out.println(&quot;最后一个元素：&quot; + a[a.length - 1]);
           System.out.println(&quot;最后一个元素：&quot; + a[5]);

           //存(改)
           //把第一元素修改为111
           a[0] = 111;
           System.out.println(&quot;第一个元素：&quot; + a[0]);
           //把最后一个元素修改为0
           a[5] = 0;
           System.out.println(&quot;最后一个元素：&quot; + a[a.length - 1]);

           //一维数组怎么遍历呢？
           for (int i = 0;i &lt; a.length;i ++)&#123;
              System.out.print(a[i] + &quot; &quot;);
           &#125;
           System.out.println(&#39;\t&#39;);
           //下标为6表示第七个元素，第七个元素没有，下标越界了，会出现什么异常呢？
           //System.out.println(a[6]); //ArrayIndexOutOfBoundsException(比较著名的异常：数组下标越界异常)

           //从最后一个元素遍历到第一个元素
           for(int i = a.length - 1;i &gt;= 0;i --)&#123;
              System.out.print(a[i] + &quot; &quot;);
           &#125;
        &#125;
    &#125;

    public class ArrayTest02 &#123;
        public static void main(String[] args) &#123;
           //声明/定义一个数组，采用动态初始化的方式创建
           int[] a = new int[4]; //创建长度为4的int数组，数组中每个元素的默认值是0
           //遍历数组
           for (int i = 0; i &lt; a.length;i++)&#123;
              System.out.println(&quot;数组中下标为&quot; + i + &quot;的元素是：&quot; + a[i] );
           &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="16）、什么时候采用静态初始化的方式，什么时候采用动态初始化方式？"><a href="#16）、什么时候采用静态初始化的方式，什么时候采用动态初始化方式？" class="headerlink" title="16）、什么时候采用静态初始化的方式，什么时候采用动态初始化方式？"></a>16）、什么时候采用静态初始化的方式，什么时候采用动态初始化方式？</h3><pre><code>        当你创建数组的时候，确定数组中存储哪些具体的元素时，采用静态初始化方式；
        当你创建数组的时候，不确定将来数组中存储哪些数据，
        你可以采用动态初始化的方式预先分配内存空间。
    public class ArrayTest02 &#123;
        public static void main(String[] args) &#123;
           //声明/定义一个数组，采用动态初始化的方式创建
           int[] a = new int[4]; //创建长度为4的int数组，数组中每个元素的默认值是0
           //遍历数组
           for (int i = 0; i &lt; a.length;i++)&#123;
              System.out.println(&quot;数组中下标为&quot; + i + &quot;的元素是：&quot; + a[i] );
           &#125;

           //存储Object，采用静态初始化
           Object o1 = new Object();
           Object o2 = new Object();
           Object o3 = new Object();
           Object[] objects = &#123;o1,o2,o3&#125;;
           //Object[] objects = &#123;new Object(),new Object(),new Object()&#125;;

           for (int i = 0;i &lt; objects.length;i++)&#123;
              System.out.println(objects[i]); //java.lang.Object@1b28cdfa;java.lang.Object@eed1f14;java.lang.Object@7229724f
              //Object输出引用的时候，会自动调用该引用的toString()方法
           &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="17）、当一个方法上，参数类型是数组的时候。"><a href="#17）、当一个方法上，参数类型是数组的时候。" class="headerlink" title="17）、当一个方法上，参数类型是数组的时候。"></a>17）、当一个方法上，参数类型是数组的时候。</h3><pre><code>    public class ArrayTest03 &#123;
        //main方法的编译方式还可以采用C++的语法格式哦！
        //public static void main(String args[]) &#123;&#125;
        public static void main(String[] args) &#123;

           //调用方法时传一个数组
           int[] a =&#123;1,2,3,4,5&#125;;
           printarray(a);

           //创建String数组
           String[] s = &#123;&quot;加&quot;,&quot;油&quot;,&quot;!&quot;&#125;; //方法重载
           printarray(s);

           //传递动态数组
           printarray(new String[3]);
           printarray(new int[3]);
        &#125;
        //定义一个遍历数组方法
        public static void printarray(int[] array)&#123;
           for (int i = 0;i &lt; array.length;i++)&#123;
              System.out.println(array[i]);
           &#125;
        &#125;
        public static void printarray(String[] args)&#123;
           for (int i = 0;i &lt; args.length;i++)&#123;
              System.out.println(args[i]);
           &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="18）、当一个方法的参数是数组的时候，我们还可以采用这种方式传"><a href="#18）、当一个方法的参数是数组的时候，我们还可以采用这种方式传" class="headerlink" title="18）、当一个方法的参数是数组的时候，我们还可以采用这种方式传"></a>18）、当一个方法的参数是数组的时候，我们还可以采用这种方式传</h3><pre><code>    public class ArrayTest04 &#123;
        public static void main(String[] args) &#123;

           //静态初始化一维数组
           int[] a = &#123;1,2,3&#125;;
           printarray(a);
           //没有这种语法
           //printarray(&#123;1,2,3&#125;);
           //如果直接传递一个静态数组的话，语法必须这样写。
           printarray(new int[]&#123;1,2,3&#125;);

           //动态初始化一维数组
           int[] a2 = new int[4];
           printarray(a2);
        &#125;

        public static void printarray(int[] array)&#123;
           for (int i = 0;i &lt; array.length;i++)&#123;
              System.out.println(array[i]);
           &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="19）、-main方法上面的”String-args”有什么用？"><a href="#19）、-main方法上面的”String-args”有什么用？" class="headerlink" title="19）、 main方法上面的”String[] args”有什么用？"></a>19）、 main方法上面的”String[] args”有什么用？</h3><pre><code>       分析一下：谁负责调用main方法(JVM)
       JVM调用main方法的时候，会自动传一个String数组过来
    public class ArrayTest05 &#123;
        //这个方法程序员负责写出来，JVM负责调用，JVM调用的时候一定会传一个String数组过来。
        public static void main(String[] args) &#123;
           //JVM默认传递过来的这个数组的长度默认0
           //通过测试得出args不是null。
           System.out.println(&quot;JVM传递过来的String数组参数，它这个数组的长度是？&quot; 
                                                                   + args.length); //长度为0

           //这个数组什么时候里面会有值呢？
           //其实这个数组是留给用户的，用户可以在控制台上输入参数，
           //这个参数自动会被转换成&quot;String[] args&quot;
           //例如这样运行程序：java ArrayTest05 abc def xyz
           //那么这个时候JVM会自动将abc def xyz通过空格的方式进行分离，
           //分离完成之后自动放到&quot;Sring[] args&quot;数组当中
           //所以main方法上面对String[] args数组主要是用来接受用户输入参数的。
           //把abc def xyz转换成字符串数组：&#123;&quot;abc&quot;,&quot;def&quot;,&quot;xyz&quot;&#125;

           //点击工具栏里的RUN，选择Edit configurations；在Program arguments输入abc def xyz

           //遍历数组
           for (int i = 0;i &lt; args.length;i++)&#123;
              System.out.println(args[i]);
           &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="20）、-模拟一个系统，假设这个系统要使用，必须输入用户名和密码"><a href="#20）、-模拟一个系统，假设这个系统要使用，必须输入用户名和密码" class="headerlink" title="20）、 模拟一个系统，假设这个系统要使用，必须输入用户名和密码"></a>20）、 模拟一个系统，假设这个系统要使用，必须输入用户名和密码</h3><pre><code>    public class ArrayTest06 &#123;
        //用户名和密码输入到String[] args数组当中。
        public static void main(String[] args) &#123;
           if (args.length != 2)&#123;
              System.out.println(&quot;使用该系统时请输入用户名和密码，例如张三 123&quot;);
              return;
           &#125;

           //程序执行到此处说明用户确实提供了用户名和密码
           //接下来你应该判断用户名是否正确
           String s1 = args[0];
           String s2 = args[1];

           //注意：此处时字符串比较，不是对象比较，不需要创建对象重写equals方法，
           //直接调用字符串equals比较方法。

           //if (s1.equals(&quot;zhangsan&quot;) &amp;&amp; s2.equals(&quot;123&quot;)) &#123;
           //上述的if可能出现空指针异常，如果s1或者s2为null的话，就出现异常
           //这样写可以避免空指针异常
           if (&quot;zhangsan&quot;.equals(s1) &amp;&amp; &quot;123&quot;.equals(s2)) &#123;
              System.out.println(&quot;欢迎使用!&quot;);
           &#125;else &#123;
              System.out.println(&quot;用户名或密码不正确!&quot;);
           &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="21）、一维数组的深入，数组中存储的类型为：引用数据类型"><a href="#21）、一维数组的深入，数组中存储的类型为：引用数据类型" class="headerlink" title="21）、一维数组的深入，数组中存储的类型为：引用数据类型"></a>21）、一维数组的深入，数组中存储的类型为：引用数据类型</h3><pre><code>对于数组来说，实际上只能存储java对象的“内存地址”；数组中存储的每个元素是“引用”
public class ArrayTest07 &#123;
    public static void main(String[] args) &#123;

       //创建一个Animal类型的数组
       Animal[] animals = &#123;new Animal(),new Animal()&#125;;

       //对Animal数组进行遍历
       for (int i = 0;i &lt; animals.length;i++)&#123;
          //输出引用的时候，会自动调用该引用的toString()方法
          //System.out.println(animals[i]); //Animal@3f99bd52;Animal@4f023edb
          /*
          Animal a = animals[i];
          a.move(); //结果是输出两遍&quot;Animal move....&quot;
          */
          //代码合并
          animals[i].move();
       &#125;
       //动态初始化一个长度为2的Animal类型数组
       Animal[] ans = new Animal[2];
       //创建一个Animal对象那个，方法到数组的第一个盒子中。
       ans[0] = new Animal();
       //Animal数组中只能存放Animal类型，不能存放Product类型。
       //ans[1] = new Product();

       //Animal数组中可以存放Cat类型的数据，因为Cat是一个Animal。
       //Cat是Animal的子类
       ans[1] = new Cat();

       //创建一个Animal类型的数组，数组当中存储Cat和Bird
       Animal[] ans1 = &#123;new Cat(),new Bird()&#125;;

       for (int i = 0; i &lt;ans1.length; i++)&#123;
          //如果调用的方法是父类中存在的方法不需要向下转型，直接使用父类型引用调用即可。
          ans1[i].move();

          //调用子对象中特有方法的话
          if (ans1[i] instanceof Cat)&#123;
             ((Cat)ans1[i]).catchMouse();
          &#125;else if (ans1[i] instanceof Bird)&#123;
             ((Bird)ans1[i]).sing();
          &#125;
       &#125;
    &#125;
&#125;
class Animal &#123;
    public void move() &#123;
       System.out.println(&quot;Animal move....&quot;);
    &#125;
&#125;

class Product&#123;

&#125;

class Cat extends Animal&#123;

    //重写父类中的move()方法
    public void move() &#123;
       System.out.println(&quot;猫在爬树！&quot;);
    &#125;
    //特有的方法
    public void catchMouse()&#123;
       System.out.println(&quot;猫在抓老鼠!&quot;);
    &#125;
&#125;

class Bird extends Animal&#123;
    //重写父类中的move()方法
    public void move() &#123;
       System.out.println(&quot;Bird fly!&quot;);
    &#125;

    //特有的方法
    public void sing()&#123;
       System.out.println(&quot;小鸟在唱歌!&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="22）、关于一维数组的扩容。"><a href="#22）、关于一维数组的扩容。" class="headerlink" title="22）、关于一维数组的扩容。"></a>22）、关于一维数组的扩容。</h3><pre><code>在java开发中，数组长度一旦确定不可变，那么数组满了怎么办？
    数组满了，需要扩容，Java中对数组的扩容是：
        先新建一个大容量的数组，然后将小容量的数组中的数据拷贝到大数组当中。
结论：数组扩容效率较低，因为涉及到拷贝的问题；所以在以后的开发中请注意：尽可能少的进行数组的拷贝。
可以在创建数组对象的时候预估计一下，最好预估准确，这样可以减少数组的扩容次数，提高效率。
public class ArrayTest08 &#123;
    public static void main(String[] args) &#123;
       //java中的数组是怎么进行拷贝的呢？
       //System.arraycopy(5个参数);

       //拷贝源
       int[] src = &#123;1, 11, 22, 3, 4&#125;;

       //拷贝目标
       int[] dest = new int[20]; //动态初始化一个长度为20的数组，每一个元素默认值为0
       //调用JDK System类中的方法，来完成数组的拷贝
       System.arraycopy(src,1,dest,3,2);

       //遍历目标数组
       for (int i = 0;i &lt; dest.length; i++)&#123;
          System.out.println(dest[i]); //0 0 0 11 22 0...0
       &#125;

       //数组中如果存储的元素是引用可以拷贝吗？【当然可以】
       String[] strs = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;study&quot;,&quot;java&quot;,&quot;oracle&quot;,&quot;mysql&quot;,&quot;jdbc&quot;&#125;;
       String[] newstrs = new String[10];
       System.arraycopy(strs,0,newstrs,0,strs.length);
       for (int i = 0;i &lt;newstrs.length;i++)&#123;
          System.out.println(newstrs[i]);
       &#125;
    &#125;
&#125;
</code></pre>
<h2 id="2、关于java语言中的二维数组"><a href="#2、关于java语言中的二维数组" class="headerlink" title="2、关于java语言中的二维数组"></a>2、关于java语言中的二维数组</h2><h3 id="1）、二维数组其实是一个特殊的一维数组，特殊在这个一维数组当中的每一个元素是一个一维数组。"><a href="#1）、二维数组其实是一个特殊的一维数组，特殊在这个一维数组当中的每一个元素是一个一维数组。" class="headerlink" title="1）、二维数组其实是一个特殊的一维数组，特殊在这个一维数组当中的每一个元素是一个一维数组。"></a>1）、二维数组其实是一个特殊的一维数组，特殊在这个一维数组当中的每一个元素是一个一维数组。</h3><h3 id="2）、三维数组是什么？"><a href="#2）、三维数组是什么？" class="headerlink" title="2）、三维数组是什么？"></a>2）、三维数组是什么？</h3><pre><code>         三维数组是一个特殊的二维数组，特殊在这个二维数组中每一个元素是一个一维数组。
         实际开发中使用最多的就是一维数组，二维数组也很少使用，三维数组几乎不用。
</code></pre>
<h3 id="3）、二维数组静态初始化"><a href="#3）、二维数组静态初始化" class="headerlink" title="3）、二维数组静态初始化"></a>3）、二维数组静态初始化</h3><pre><code>         int[][] array = &#123;&#123;1,2,2&#125;,&#123;2,2,2&#125;,&#123;3,2,2,3&#125;&#125;;

    public class ArrayTest09 &#123;
        public static void main(String[] args) &#123;
           //一维数组
           int[] array = &#123;100,200,300&#125;;
           System.out.println(array.length); //3

           //二维数组
           int[][] a = &#123;
                 &#123;100,200,300,&#125;,
                 &#123;30,20,40,50,60&#125;,
                 &#123;6,7,9,1&#125;,
                 &#123;0&#125;
           &#125;;
           System.out.println(a.length); //4；a这个二维数组的长度
           System.out.println(a[0].length); //3；第一个一维数组的长度
        &#125;
    &#125;
</code></pre>
<h2 id="3、关于二维数组中元素的读和改"><a href="#3、关于二维数组中元素的读和改" class="headerlink" title="3、关于二维数组中元素的读和改:"></a>3、关于二维数组中元素的读和改:</h2><pre><code>    a[二维数组中的一维数组的下标][一维数组的下标]
    a[0][0]：表示第一个一维数组中第一个元素的下标
    public class ArrayTest10 &#123;
        public static void main(String[] args) &#123;
           int[][] a = &#123;
                 &#123;34,65,4&#125;,
                 &#123;100,200,300&#125;,
                 &#123;0&#125;
           &#125;;

           //请取出以上二维数组中的第一个一维数组
           int[] a0 = a[0]; //第一个一维数组
           int a00 = a0[0]; //第一个一维数组中的第一个元素
           System.out.println(a00);

           //合并以上代码
           System.out.println(a[0][0]);
           //取出第二个一维数组当中的第三个元素
           System.out.println(&quot;第二个一维数组当中的第三个元素：&quot; + a[1][2]);

           //改[注意别越界]
           a[1][2] = 11111;
           int[] array = &#123;1,2&#125;;
           a[2] = array;
           //a[2] = &#123;1,2&#125;;报错：没有这种语法
           a[2] = new int[]&#123;1,2&#125;;
           System.out.println(a[2][1]);
           &#125;
    &#125;
</code></pre>
<h2 id="4、关于二维数组的遍历"><a href="#4、关于二维数组的遍历" class="headerlink" title="4、关于二维数组的遍历"></a>4、关于二维数组的遍历</h2><pre><code>public class ArrayTest11 &#123;
    public static void main(String[] args) &#123;
       //二维数组
       String[][] args1 = &#123;
             &#123;&quot;java&quot;,&quot;oracle&quot;,&quot;C++&quot;,&quot;python&quot;,&quot;C#&quot;&#125;,
             &#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;&#125;,
             &#123;&quot;lucy&quot;,&quot;jack&quot;,&quot;rose&quot;&#125;
       &#125;;
       printArray(args1);

       //动态初始化二维数组
       //3行4列
       //三个一维数组，每个一维数组当中四个元素
       int[][] array = new int[3][4];

       int[][] a = &#123;
             &#123;34,65,4&#125;,
             &#123;100,200,300&#125;,
             &#123;0&#125;
       &#125;;
       printArray(a);
       //没有以下这种语法
       //printArray(&#123;&#123;34,65,4&#125;, &#123;100,200,300&#125;, &#123;0&#125;&#125;;);
       printArray(new int[][]&#123;&#123;34,65,4&#125;, &#123;100,200,300&#125;, &#123;0&#125;&#125;);

    &#125;

    public static void printArray(int[][] array)&#123;
       //遍历二维数组
       for (int i = 0;i &lt; array.length;i ++)&#123;
          //负责遍历一维数组
          for (int j = 0; j &lt; array[i].length;j++)&#123;
             System.out.print(array[i][j] + &quot; &quot;);
          &#125;
          //输出换行符
          System.out.println();
       &#125;
    &#125;
    public static void printArray(String[][] array)&#123;
       //遍历二维数组
       for (int i = 0;i &lt; array.length;i ++)&#123;
          //负责遍历一维数组
          for (int j = 0; j &lt; array[i].length;j++)&#123;
             System.out.print(array[i][j] + &quot; &quot;);
          &#125;
          //输出换行符
          System.out.println();
       &#125;
    &#125;
&#125;    
</code></pre>
<h1 id="四、常见算法"><a href="#四、常见算法" class="headerlink" title="四、常见算法"></a>四、常见算法</h1><pre><code>排序算法：
        冒泡排序算法
        选择排序算法
查找算法：
        二分法查找
    以上算法在以后的java开发中我们不需要使用的；因为java已经封装好了，直接调用就行；
    不过以后面试的时候可能有机会碰上。
</code></pre>
<h2 id="1、冒泡排序算法"><a href="#1、冒泡排序算法" class="headerlink" title="1、冒泡排序算法"></a>1、冒泡排序算法</h2><pre><code>    *每一次循环结束之后，都要找出最大的数据，放到参与比较的这堆数据的最右边。(冒出最大的气泡)
    *核心：
       拿着左边的数字和右边的数字比对，当左边 &gt; 右边，交换位置。

原始数据：3, 2, 7, 6, 8
第一次循环：(最大的跑到最右边)
拿着3和右边相邻的2进行比较，如果左边大于右边(3&gt;2)，交换位置：2, 3, 7, 6, 8
继续拿着上一次比较之后的结果中右边较大的数据和后续的数据继续比较(3&lt;7)，不动：2, 3, 7, 6, 8
(不需要交换位置，但是需要比较一次)
继续拿7和6比较：2, 3, 6, 7, 8
继续7和8比较：2, 3, 6, 7, 8(不需要交换位置，但是需要比较一次)

经过第一次循环，剩下参与比较的数据：2, 3, 6, 7
第二次循环：
2, 3, 6, 7(2和3比较，不需要交换位置，但是需要比较一次)
2, 3, 6, 7(3和6比较，不需要交换位置，但是需要比较一次)
2, 3, 6, 7(6和7比较，不需要交换位置，但是需要比较一次)

经过第二次循环，剩下参与比较的数据：2, 3, 6
第三次循环：
2, 3, 6(2和3比较，不需要交换位置，但是需要比较一次)
2, 3, 6(3和6比较，不需要交换位置，但是需要比较一次)

经过第三次循环，剩下参与比较的数据：2, 3
第四次循环：
2, 3(2和3比较，不需要交换位置，但是需要比较一次)


//冒泡排序的外层循环采用第一个for的方式（循环length-1次）
for(int i = 数组.length - 1;i &gt; 0;i--)&#123;
    for(int j = 0;j &lt; i;j++)&#123;
        if(arr[j] &gt; arr[j+1])&#123;
            //交换位置
            //arr[j]和arr[j+1]交换位置
            int temp;
            temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp;
        &#125;
    &#125;
&#125;
总循环次数：(length*(length - 1))/2
    public class BubbleSort &#123;
        public static void main(String[] args)&#123;
           int count = 0;
           //这是int类型的数组对象
           int[] arr = &#123;3, 2, 7, 6, 8&#125;;
           //经过冒泡排序算法对以上数组中元素进行排序
           //冒泡排序算法的核心是什么？
           for (int i = arr.length - 1;i &gt; 0;i--)&#123;
              for (int j = 0;j &lt; i;j++)&#123;
                 //不管是否需要交换位置，都需要比较一次
                 count++;
                 if (arr[j] &gt; arr[j + 1])&#123;
                    int temp;
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                 &#125;
              &#125;
           &#125;
           System.out.println(&quot;比较次数：&quot; + count);
           //遍历数组
           for (int i = 0; i &lt; arr.length;i++)&#123;
              System.out.println(arr[i]);
           &#125;
        &#125;
    &#125;
</code></pre>
<h2 id="2、选择排序："><a href="#2、选择排序：" class="headerlink" title="2、选择排序："></a>2、选择排序：</h2><pre><code>       每一次从这堆&quot;参与比较的数据当中&quot;找出最小值；
       拿着这个最小值和&quot;参与比较的这堆最前面的元素&quot;交换位置。
       选择排序比冒泡排序效率高；高在交换位置的次数上，每一次的交换位置都是有意义的。
       比较次数没变，交换次数减少了。

参与比较的数据：3 1 6 2 5 (这一堆参加比较的数据中最左侧元素的下标是0)
第一次循环之后的结果是：
1 3 6 2 5

参与比较的数据：3 6 2 5   (这一堆参加比较的数据中最左侧元素的下标是1)
第二次循环之后的结果是：
2 6 3 5

参与比较的数据：6 3 5     (这一堆参加比较的数据中最左侧元素的下标是2)
第三次循环之后的结果是：
3 6 5

参与比较的数据：6 5       (这一堆参加比较的数据中最左侧元素的下标是3)
第四次循环之后的结果是：
5 6

注意：5条数据循环4次

关键点：选择排序中的关键在于，你怎么找出一堆数据中最小的。
3 2 6 1 5
假设：
    第一个3是最小的；
    3和2比对，发现2更小，所以此时最小的是2.

    继续拿着2往下比对，2和6比对，2仍然是最小的；

    继续拿着2往下比对，2和1比对，发现1更小；

    继续拿着1往下比对，1和5比对，1仍然是最小的；

    拿着1和最左边的3交换位置。

2 6 3 5
假设：....
....
    public class SelectSort &#123;
        public static void main(String[] args) &#123;
           int[] arr = &#123;3, 1, 6, 2, 5&#125;;
           int count = 0;
           //选择排序
           //5条数据循环4次(外层循环4次)
           for (int i =0;i &lt; arr.length - 1;i++)&#123;
              //i = 0 1 2 3
              //i正好是“参加比较的这堆数据中”最左边那个元素的下标
              //i是一个参与比较的这堆数据中的起点下标
              //假设七点i下标位置上的元素是最小的
              int min = i;
              for (int j = i+1;j &lt; arr.length;j++)&#123;
                 count++;
                 if (arr[j] &lt; arr[min])&#123;
                    min = j; //最小元素的下标是j
                 &#125;
              &#125;

              //当i和min相等时，表示最初的猜测是对的
              //当i和min不相等时，表示最初的猜测是错的，有比这个元素更小的元素
              //需要拿着这个更小的元素和最左边的元素交换位置
              if (min != i)&#123;
                 //表示存在更小的数据
                 //现在arr[min]是最小的数据
                 //arr[i]是最面前的数据
                 int temp;
                 temp = arr[i];
                 arr[i] = arr[min];
                 arr[min] = temp;
              &#125;
           &#125;
           System.out.println(&quot;比较次数：&quot; + count);

           for (int i = 0;i &lt; arr.length;i++)&#123;
              System.out.println(arr[i]);
           &#125;
        &#125;
    &#125;
</code></pre>
<h2 id="3、数组的元素查找有两种方式："><a href="#3、数组的元素查找有两种方式：" class="headerlink" title="3、数组的元素查找有两种方式："></a>3、数组的元素查找有两种方式：</h2><pre><code>    第一种方式：一个一个挨着找，知道找到为止。
    第二种方式：二分法查找(算法)，这个效率较高
    public class ArraySerch &#123;
        public static void main(String[] args) &#123;
           //这个例子演示一下第一种方式
           int[] arr = &#123;4, 5, 6, 7, 87, 8&#125;;

           /*
           //需求：找出87的下标，如果没有返回-1；
           //一个一个挨着找
           for (int i = 0;i &lt; arr.length;i++)&#123;
              if (arr[i] == 87)&#123;
                 System.out.println(&quot;87元素的下标是：&quot; + i);
                 return; //为什么不用break？因为break结束的是for循环语句，找到找不到都会继续下面的语句，return结束的是main方法。

              &#125;
           &#125;
           //程序执行到此处，表示没有87
           System.out.println(&quot;不存在该元素！&quot;);
           */

           //以上的程序换一个方法，思考：传什么参数？返回什么值？
           //传什么：第一个参数是数组；第二个参数是被查找的元素。
           //返回值：被查找元素的下标，如果找不到返回-1.
           int retValue = arraySerch(arr,87);
           System.out.println(retValue == -1?&quot;该元素不存在&quot;:&quot;该元素下标是：&quot; + retValue);
        &#125;

        /**
        * 从数组中检索某个元素（返回的是要查找的第一个元素的下标）
        * @param arr 被检索的数组
        * @param a 被检索的元素
        * @return 大于等于0的书表示元素的下标，-1表示该元素不存在
        */
        public static int arraySerch(int[] arr,int a)&#123;
           for (int i = 0;i &lt; arr.length;i++)&#123;
              if (arr[i] == a)&#123;
                 return i;
              &#125;
           &#125;
           return -1;
        &#125;
    &#125;
</code></pre>
<h2 id="4、关于查找算法中的二分法查找："><a href="#4、关于查找算法中的二分法查找：" class="headerlink" title="4、关于查找算法中的二分法查找："></a>4、关于查找算法中的二分法查找：</h2><pre><code>       10(下标0) 11 12 13 14 15 16 17 18 19 20(下标10)
       通过二分法查找，找出18这个元素的下标：
          (0 + 10) / 2 --&gt; 中间元素的下标：5
       拿着中间这个元素和目标要查找的元素进行对比：
          中间元素是：arr[5] --&gt; 15
          15 &lt; 18(被查找的元素)
          被查找的元素18在目前中间元素15的右边。
          所以开始元素的下标从0变成6(5+1)；

       再重新计算一个中间元素的下标；
          开始下标是：5+1
          结束下标是：10
          (6 + 10) / 2 --&gt; 8

       8下标对应的元素arr[8]是 18
          找到的中间元素正好和被找的元素18相等，表示找到了：下标为8

    二分法查找的终止条件：一直折半，直到中间的那个元素恰好是被查找的元素。

   二分法查找算法是基于排序的基础之上。(没有排序的数据是无法查找的)
    public class ArraySerch2 &#123;
        public static void main(String[] args) &#123;
           int[] arr = &#123;100,200,230,235,600,1000,2000,9999&#125;;

           //找出arr这个数组中200所在的下标。
           //调用方法
           int index = binarySearch(arr,9999);
           System.out.println(index == -1?&quot;该元素不存在&quot;:&quot;该元素下标为：&quot; + index);
        &#125;

        /**
        * 从数组中查找目标元素的下标
        * @param arr 被查找的数组(这个必须是已经排序的)
        * @param dest 目标元素
        * @return -1表示该元素不存在，其它是这个元素的下标
        */
        public static int binarySearch(int[] arr, int dest) &#123;
           //开始下标
           int begin = 0;
           //结束下标
           int end = arr.length-1;

           //开始元素的下标在一直增，结束元素的下标在一直减
           //开始元素只要在介属下表的左边就有机会继续循环
           while (begin &lt;= end) &#123;
              //中间元素下标
              int mid = (begin + end) / 2;
              if (arr[mid] == dest) &#123;
                 return mid;
              &#125; else if (arr[mid] &lt; dest) &#123;
                 //目标在“中间”的右边
                 //开始元素下标需要发生变化(开始元素的下标需要重新赋值)
                 begin = mid + 1; //一直增

              &#125; else &#123;
                 //arr[mid] &gt; dest
                 //目标在“中间”的左边
                 //修改结束元素的下边
                 end = mid - 1; //一直减
              &#125;
           &#125;
           return -1;
        &#125;
    &#125;
</code></pre>
<h2 id="5、Arrays工具类"><a href="#5、Arrays工具类" class="headerlink" title="5、Arrays工具类"></a>5、Arrays工具类</h2><pre><code>       SUN工艺已经为我们程序员写好了一个数组工具类。
          java.util.Arrays;
          所有方法都是静态的，直接用类名调用
       主要使用的是两个方法：
          二分法查找，排序
       以后要看文档，不要死记硬背。
    public class ArraysTest02 &#123;
        public static void main(String[] args) &#123;
           //java.util.Arrays;工具类中由哪些方法，我们开发的时候需要参考API帮助文档
           //不要死记硬背。
           int[] arr = &#123;3,4,6,5,1,12,32,5&#125;;
           //排序
           Arrays.sort(arr);
           //输出
           for (int i = 0; i &lt; arr.length;i++)&#123;
              System.out.println(arr[i]);
           &#125;

           //二分法查找(建立在排序基础之上)
           int index = Arrays.binarySearch(arr,12);
           System.out.println(index == -1 ? &quot;该元素不存在&quot; : &quot;该元素的下标为：&quot; + index);
        &#125;
    &#125;
</code></pre>
<h1 id="五、JDK中内置的常用类"><a href="#五、JDK中内置的常用类" class="headerlink" title="五、JDK中内置的常用类"></a>五、JDK中内置的常用类</h1><h2 id="1、关于java-JDK中内置的一个类：java-lang-String："><a href="#1、关于java-JDK中内置的一个类：java-lang-String：" class="headerlink" title="1、关于java JDK中内置的一个类：java.lang.String："></a>1、关于java JDK中内置的一个类：java.lang.String：</h2><h3 id="1）、String表示字符串，属于引用数据类型，不属于基本数据类型"><a href="#1）、String表示字符串，属于引用数据类型，不属于基本数据类型" class="headerlink" title="1）、String表示字符串，属于引用数据类型，不属于基本数据类型"></a>1）、String表示字符串，属于引用数据类型，不属于基本数据类型</h3><h3 id="2）、在java中随便使用双引号括起来的都是String对象；例如：”abc”-“def”-“HelloWorld”-这是3个String对象。"><a href="#2）、在java中随便使用双引号括起来的都是String对象；例如：”abc”-“def”-“HelloWorld”-这是3个String对象。" class="headerlink" title="2）、在java中随便使用双引号括起来的都是String对象；例如：”abc”, “def”, “HelloWorld”, 这是3个String对象。"></a>2）、在java中随便使用双引号括起来的都是String对象；例如：”abc”, “def”, “HelloWorld”, 这是3个String对象。</h3><h3 id="3）、java中规定，双引号括起来的字符串是不可变的，也就是说”abc”自出生到消逝不可变，不能变成”abcd”，也不可变成”ab”。"><a href="#3）、java中规定，双引号括起来的字符串是不可变的，也就是说”abc”自出生到消逝不可变，不能变成”abcd”，也不可变成”ab”。" class="headerlink" title="3）、java中规定，双引号括起来的字符串是不可变的，也就是说”abc”自出生到消逝不可变，不能变成”abcd”，也不可变成”ab”。"></a>3）、java中规定，双引号括起来的字符串是不可变的，也就是说”abc”自出生到消逝不可变，不能变成”abcd”，也不可变成”ab”。</h3><h3 id="4）、在JDK当中双引号括起来的字符串，例如：”abc”-“def”都是直接存储在“方法区”的“字符串常量池”当中的。"><a href="#4）、在JDK当中双引号括起来的字符串，例如：”abc”-“def”都是直接存储在“方法区”的“字符串常量池”当中的。" class="headerlink" title="4）、在JDK当中双引号括起来的字符串，例如：”abc”, “def”都是直接存储在“方法区”的“字符串常量池”当中的。"></a>4）、在JDK当中双引号括起来的字符串，例如：”abc”, “def”都是直接存储在“方法区”的“字符串常量池”当中的。</h3><pre><code>    为什么SUN公司把字符串存储在一个常量池当中呢？因为字符串子啊实际开发中使用的太频繁，为了执行效率，
    所以把字符串放到了方法区的字符串常量池当中。
    public class StringTest01 &#123;
        public static void main(String[] args) &#123;
           //这两行代码表示底层创建了3个字符串对象，都在字符串常量池当中
           String s1 = &quot;abcdef&quot;;
           String s2 = &quot;abcdef&quot; + &quot;xy&quot;;
           //垃圾回收器是不会释放常量的，即使没有指针指向&quot;xy&quot;,&quot;xy&quot;依然存在。

           //分析：这是使用new的方式创建字符串对象，这个代码中的&quot;xy&quot;是从哪里来的？
           //凡是双引号括起来的都在字符串常量池中有一份
           //new对象的时候一定在堆内存当中开辟空间
           //s3是在栈里的引用，里面存了堆内存中String对象的内存地址；
           //堆内存中String对象里存了指向方法区内存中字符串常量池中的&quot;xy&quot;地址。
           String s3 = new String(&quot;xy&quot;);

           //i变量中保存的是100这个值
           int i = 100;
           //s引用中保存的是字符串对象的内存地址
           //s引用中保存的不是&quot;abc&quot;，是0x1111
           //而0x1111是&quot;abc&quot;字符串对象在字符串常量池当中的内存地址。
           String s = &quot;abc&quot;;
        &#125;
    &#125;
</code></pre>
<h3 id="5）、接上举例："><a href="#5）、接上举例：" class="headerlink" title="5）、接上举例："></a>5）、接上举例：</h3><pre><code>    public class StringTest02 &#123;
        public static void main(String[] args) &#123;
           String s1 = &quot;Hello&quot;;
           //&quot;Hello&quot;是存储在方法区的字符串常量池当中
           //所以这个&quot;Hello&quot;不会新建(因为这个对象已经存在了！)
           String s2 = &quot;Hello&quot;;

           //分析结果是true还是false：true
           System.out.println(s1 == s2); //true

           String x = new String(&quot;xyz&quot;);
           String y = new String(&quot;xyz&quot;);
           System.out.println(x == y); //false
           // == 双等号比较的是内存地址
           System.out.println(x.equals(y)); //true

           //通过这个案例学习，我们知道了，字符串对象之间的比较不能使用“==”
           //“==”不保险，应该调用String类的equals方法。
           //String类已经重写了equals方法，以上equals方法调用的是String重写之后的equals方法。

           String k = new String(&quot;testString&quot;);
           //&quot;testString&quot;这个字符串可以后面加&quot; . &quot;呢？
           //因为&quot;testString&quot;是一个String字符串对象，只要是对象都可以调用方法。
           System.out.println(&quot;testString&quot;.equals(k)); //建议使用这种方式，
           //因为这个可以避免空指针异常
           System.out.println(k.equals(&quot;testString&quot;)); //k = null的时候空指针异常
        &#125;
    &#125;
</code></pre>
<h3 id="6）、关于String类中的构造方法"><a href="#6）、关于String类中的构造方法" class="headerlink" title="6）、关于String类中的构造方法"></a>6）、关于String类中的构造方法</h3><pre><code>    public class StringTest03 &#123;
        public static void main(String[] args)&#123;
           //创建字符串对象最常用的一种方式
           String s1 = &quot;Hello World!&quot;;

           //这里只掌握常用的构造方法。
           byte[] bytes = &#123;97, 98, 99&#125;; //97是a，98是b，99是c
           String s2 = new String(bytes);

           //前面说过，输出一个引用的时候，会自动调用toString()方法，
           //默认Object的话，会自动输出对象的内存地址。
           //通过输出结果我们得出一个结论：String类已经重写了toString()方法。
           //输出字符串对像的话，输出的不是对象的内存地址，而是字符串本身。
           System.out.println(s2.toString()); //abc
           System.out.println(s2); //abc

           //String(字节数组，数组元素下标的起始位置，长度)
           //将byte数组中的一部分转换成字符串。
           String s3 = new String(bytes,1,2);
           System.out.println(s3); //bc

           //将char数组全部转换成字符串
           char[] chars = &#123;&#39;我&#39;,&#39;是&#39;,&#39;中&#39;,&#39;国&#39;,&#39;人&#39;&#125;;
           String s4 = new String(chars);
           System.out.println(s4); //我是中国人
           //将char数组的一部分转换成字符串
           String s5 = new String(chars,2,3);
           System.out.println(s5); //中国人

           String s6 = new String(&quot;Helloworld!&quot;);
           System.out.println(s6);
        &#125;
    &#125;
</code></pre>
<h3 id="7）、关于String类中的常用方法"><a href="#7）、关于String类中的常用方法" class="headerlink" title="7）、关于String类中的常用方法"></a>7）、关于String类中的常用方法</h3><pre><code>    public class StringTest04 &#123;
        public static void main(String[] args) &#123;
           //String当中常用的方法
           //1(掌握)、char charAt(int index)
           char c = &quot;中国人&quot;.charAt(1); //&quot;中国人&quot;是一个字符串String对象，这要是对象都能&quot;点&quot;
           System.out.println(c); // 国

           //2、(了解)、int compareTo(String anotherString) 按字典顺序比较字符串
           //字符串之间比较不能直接使用 &gt; &lt; ，需要使用compareTo方法。
           int result = &quot;abc&quot;.compareTo(&quot;abc&quot;);
           System.out.println(result); //0(等于0) 前后一致 10 - 10 = 0

           int result2 = &quot;abcd&quot;.compareTo(&quot;abce&quot;);
           System.out.println(result2); //-1(小于0) 前小后大 8 - 9 = -1

           int result3 = &quot;abce&quot;.compareTo(&quot;abcd&quot;);
           System.out.println(result3); //1(大于0) 前大后小 9 - 8 = 1
           int result4 = &quot;abcf&quot;.compareTo(&quot;abcd&quot;);
           System.out.println(result4); //2(大于0) 前大后小 10 - 8 = 2

           //拿着字符串第一个字母和后面字符串的第一个字母比较，能分胜负就不再比较了。
           System.out.println(&quot;xyz&quot;.compareTo(&quot;yxz&quot;)); //-1

           //3、(掌握)boolean contains(CharSequence s); 判断前面的字符串是否包含后面的子字符串
           System.out.println(&quot;Helloworld.java&quot;.contains(&quot;.java&quot;)); //true

           //4、(掌握)boolean endsWith(String suffix); 判断当前字符串是否以某个字符串结尾
           System.out.println(&quot;text.txt&quot;.endsWith(&quot;.txt&quot;)); //true

           //5、(掌握)boolean equals(Object anObject); 判断两个字符串是否相等，
           //必须使用equals方法，不能使用&quot;==&quot;

           //6、(掌握)boolean equalsIgnoreCase(String anotherString); 判断两个字符串是否相等，
           //并且同时忽略大小写。
           System.out.println(&quot;Abc&quot;.equals(&quot;abc&quot;)); //false
           System.out.println(&quot;Abc&quot;.equalsIgnoreCase(&quot;abc&quot;)); //true

           //7、(掌握)byte[] getBytes(); 将字符串对象转换成字节数组
           byte[] bytes = &quot;abcdef&quot;.getBytes();
           for (int i = 0;i &lt; bytes.length;i++)&#123;
              System.out.println(bytes[i]);
           &#125; //97 98 99 100 101 102

           //8、(掌握)int indexOf(String str); 判断子字符串中第一次出现处的索引(下标)
           System.out.println(&quot;abc&quot;.indexOf(&quot;bc&quot;)); //1

           //9、(掌握)boolean isEmpty(); 判断某个字符串是否为空字符串。
           System.out.println(&quot;&quot;.isEmpty()); //true
           System.out.println(&quot;abc&quot;.isEmpty()); //false;

           //10、(掌握)int length();判断字符串的长度
           //面试题：判断数组长度和判断字符串长度不一样
           //判断数组长度是length属性，判断字符串长度是length()方法
           System.out.println(&quot;abc&quot;.length()); //3

           //11、(掌握)int lastIndexOf(String str);判断某个子字符串在当前字符串中
           //最后一次出现的索引(下标)
           System.out.println(&quot;oraclejavac++javac#phpjavapython&quot;.lastIndexOf(&quot;java&quot;)); 
           //22

           //12、(掌握)String replace(char oldChar,char newChar)
           System.out.println(&quot;abcd&quot;.replace(&quot;d&quot;,&quot;e&quot;)); //abce

           //13、(掌握)String replace(CharSequence target,CharSequence replacement); 替换
           //String的父接口就是：CharSequence
           String s = &quot;http://www.baidu.com&quot;.replace(&quot;http://&quot;,&quot;https://&quot;);
           System.out.println(s); //https://www.baidu.com

           String s2 = &quot;name=zhangsan&amp;password=123&amp;age=20&quot;.replace(&quot;=&quot;,&quot;:&quot;);
           System.out.println(s2); //name:zhangsan&amp;password:123&amp;age:20

           //14、(掌握)String[] split(String regex); 拆分字符串
           String[] ymd = &quot;1980-10-11&quot;.split(&quot;-&quot;); //&quot;1980-10-11&quot;以&quot;-&quot;分隔符进行拆分
           for (int i = 0; i &lt; ymd.length;i++)&#123;
              System.out.println(ymd[i]); //1980 10 11
           &#125;

           String[] param = &quot;name=zhangsan&amp;password=123&amp;age=20&quot;.split(&quot;&amp;&quot;);
           for (int i = 0; i &lt; param.length;i++)&#123;
              System.out.println(param[i]); //name=zhangsan password=123 age=20
              //可以继续向下拆分
              String[] param2 = param[i].split(&quot;=&quot;);
              for (int j = 0 ;j &lt; param2.length;j++)&#123;
                 System.out.println(param2[j]);
              &#125;
           &#125;

           //15、(掌握)boolean startsWith(String prefix)判断某个字符串是否以某个子字符串开始
           System.out.println(&quot;abcdefg&quot;.startsWith(&quot;abc&quot;)); //true
           System.out.println(&quot;abcdefg&quot;.startsWith(&quot;abce&quot;)); //false

           //16、(掌握)String substring(int beginIndex)截取字符串，参数是起始下标
           System.out.println(&quot;abcdefg&quot;.substring(2)); //cdefg

           //17、(掌握)String substring(int beginIndex,int endIndex) 起始下标包含，
           //结束下标不包含
           System.out.println(&quot;abcdefg&quot;.substring(2,5)); //cde

           //18、(掌握)char[] toCharArray() 将字符串转换为char数组
           char[] ca = &quot;abc&quot;.toCharArray();
           for (int i = 0;i &lt; ca.length;i++)&#123;
              System.out.println(ca[i]); //a b c
           &#125;

           //19、(掌握)String toLowerCase() 转换为小写
           System.out.println(&quot;ABCd&quot;.toLowerCase()); //abcd

           //20、(掌握)String toUpperCase() 转换为大写
           System.out.println(&quot;abcD&quot;.toUpperCase()); //ABCD

           //21、(掌握)String trim() 去除字符串前后空白
           System.out.println(&quot;       hello       world     &quot;.trim()); //hello       world

           //22、(掌握)String中只有一个方法是静态的，不需要new对象：
           //valueOf 将“非字符串”转换成“字符串”
           String s1 = String.valueOf(true);
           System.out.println(s1); //true(返回的是字符串String的true)

           char[] a = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;&#125;;
           String s3 = String.valueOf(a);
           System.out.println(s3); //abcd

           //这个静态的valueOf()方法，参数是一个对象的时候，会自动调用该对象的toString()方法
           String s4 = String.valueOf(new Customer());
           //System.out.println(s4); //没有重写toString()方法之前是对象内存地址。
           //Customer@3f99bd52
           System.out.println(s4); //我是一个VIP客户!
        &#125;
    &#125;
    class Customer&#123;
        public String toString() &#123;
           return &quot;我是一个VIP客户!&quot;;
        &#125;
    &#125;
</code></pre>
<h3 id="8）、关于Jdk中的StringBuffer"><a href="#8）、关于Jdk中的StringBuffer" class="headerlink" title="8）、关于Jdk中的StringBuffer"></a>8）、关于Jdk中的StringBuffer</h3><pre><code>思考：我们在实际的开发中，如果需要进行字符串的频繁拼接，会有什么问题？
    因为java中的字符串是不可变的，每一次拼接都会产生新字符串。
    这样会占用大量的方法区内存，造成内存空间的浪费。
        String s = &quot;abc&quot;;
        s += &quot;hello&quot;;
        以上两行代码在方法区字符串常量池中创建了3个对象；
        &quot;abc&quot;
        &quot;hello&quot;
        &quot;abchello&quot;
如果以后需要进行大量的字符串的拼接操作，建议使用JDK中自带的：
    java.lang.StringBuffer
    java.lang.StringBuilder

如何优化StringBuffer的性能？
    在创建StringBuffer的时候尽可能给定一个初始化容量
    最好减少底层数组的扩容次数，预估记一下，给一个大一些的初始化容量。
    关键点：给一个合适的初始化容量。可以提高程序的执行效率
public class StringBufferTest01 &#123;
    public static void main(String[] args) &#123;
       /*
       String s = &quot;&quot;;
       //这样做会给java的方法区字符串常量池带来很大的压力
       for (int i = 0;i &lt; 100;i++)&#123;
          s += i;
          System.out.println(s);
       &#125;
       */

       //创建一个初始化容量为16个byte[] 数组。(字符串缓冲区对象)
       StringBuffer stringBuffer = new StringBuffer();
       //拼接字符串，以后拼接字符串统一调用append方法
       stringBuffer.append(&quot;a&quot;);
       stringBuffer.append(&quot;b&quot;);
       stringBuffer.append(&quot;c&quot;);
       stringBuffer.append(3.14);
       stringBuffer.append(true);
       //append方法底层在进行追加的时候，如果byte满了会自动扩容。
       stringBuffer.append(100L);

       System.out.println(stringBuffer.toString()); //toString()可以省略，自动调用

       //指定初始化容量的stringBuffer对象(字符串缓冲区对象)
       StringBuffer stringBuffer1 = new StringBuffer(100);
    &#125;
&#125;
</code></pre>
<h3 id="9）、java-lang-StringBuilder"><a href="#9）、java-lang-StringBuilder" class="headerlink" title="9）、java.lang.StringBuilder"></a>9）、java.lang.StringBuilder</h3><pre><code>StringBuffer和StringBuilder的区别：
    StringBuffer中的方法都有：synchronized关键字修饰；
        表示StringBuffer在多线程环境下运行是安全的。
    StringBuilder中的方法都没有synchronized关键字修饰；
        表示StringBuilder在多线程环境下运行是不安全的。

    StringBuffer是线程安全的
    StringBuilder是非线程安全的
    public class StringBuilderTest01 &#123;
        public static void main(String[] args) &#123;
           //使用StringBuilder也是可以完成字符串的拼接。
           StringBuilder sb = new StringBuilder();
           sb.append(10);
           sb.append(true);
           sb.append(&quot;hello&quot;);
           sb.append(&quot;kitty&quot;);
           System.out.println(sb);
        &#125;
    &#125;
</code></pre>
<h2 id="2、八种包装类"><a href="#2、八种包装类" class="headerlink" title="2、八种包装类"></a>2、八种包装类</h2><h3 id="1）、java中为8种基本数据类型又准备了8种包装类型。8中包装类型属于引用数据类型，父类是Object。"><a href="#1）、java中为8种基本数据类型又准备了8种包装类型。8中包装类型属于引用数据类型，父类是Object。" class="headerlink" title="1）、java中为8种基本数据类型又准备了8种包装类型。8中包装类型属于引用数据类型，父类是Object。"></a>1）、java中为8种基本数据类型又准备了8种包装类型。8中包装类型属于引用数据类型，父类是Object。</h3><h3 id="2）、思考：为什么要再提供8种包装类呢？"><a href="#2）、思考：为什么要再提供8种包装类呢？" class="headerlink" title="2）、思考：为什么要再提供8种包装类呢？"></a>2）、思考：为什么要再提供8种包装类呢？</h3><pre><code>        因为8种基本类型不够用，所以SUN又提供8种包装类型。
    public class IntegerTest01 &#123;
        //入口
        public static void main(String[] args) &#123;
           //有没有这种需求：调用doSome()方法的时候需要传一个数字。
           //但是数字属于基本数据类型，而doSome()方法参数的类型是Object。
           //可见doSome()方法无法接受基本数据类型的数学。那怎么办呢？可以传一个数字对应的包装类进去。
           //把100这个数字经过构造方法包装成对象
           MyInt myInt = new MyInt(100);
           //doSome()方法虽然不能直接传100，但是可以传一个100对应的包装类型。
           doSome(myInt); //MyInt@3f99bd52 ; 100

        &#125;

        public static void doSome(Object obj)&#123;
           System.out.println(obj);
        &#125;
    &#125;

    //这种包装类目前是自己写的，实际开发中u需要自己写。
    //8种基本数据类型对应的8种包装，SUN公司已经写好了，我们直接用。
    class MyInt&#123;
        int value;

        public MyInt() &#123;
        &#125;

        public MyInt(int value) &#123;
           this.value = value;
        &#125;

        public String toString() &#123;
           return String.valueOf(value);
        &#125;
    &#125;
</code></pre>
<h3 id="3）、8种基本数据类型对应的包装类名是什么？"><a href="#3）、8种基本数据类型对应的包装类名是什么？" class="headerlink" title="3）、8种基本数据类型对应的包装类名是什么？"></a>3）、8种基本数据类型对应的包装类名是什么？</h3><pre><code>    基本数据类型              包装类型
    --------------------------------
    byte                     java.lang.Byte(父类Number)
    short                    java.lang.Short(父类Number)
    int                      java.lang.Integer(父类Number)
    long                     java.lang.Long(父类Number)
    float                    java.lang.Float(父类Number)
    double                   java.lang.Double(父类Number)
    boolean                  java.lang.Boolean(父类Object)
    char                     java.lang.Character(父类Object)
</code></pre>
<h3 id="4）、以上八种包装类种，重点以java-lang-Integer为代表进行学习，其他的类型照葫芦画瓢。"><a href="#4）、以上八种包装类种，重点以java-lang-Integer为代表进行学习，其他的类型照葫芦画瓢。" class="headerlink" title="4）、以上八种包装类种，重点以java.lang.Integer为代表进行学习，其他的类型照葫芦画瓢。"></a>4）、以上八种包装类种，重点以java.lang.Integer为代表进行学习，其他的类型照葫芦画瓢。</h3><h3 id="5）、八种包装类其中6个都是数字对应的包装类，他们的父类都是Number，可以研究一下Number中公共的方法；"><a href="#5）、八种包装类其中6个都是数字对应的包装类，他们的父类都是Number，可以研究一下Number中公共的方法；" class="headerlink" title="5）、八种包装类其中6个都是数字对应的包装类，他们的父类都是Number，可以研究一下Number中公共的方法；"></a>5）、八种包装类其中6个都是数字对应的包装类，他们的父类都是Number，可以研究一下Number中公共的方法；</h3><pre><code>     Numebr是一个抽象类，无法实例化对象
     Number里面由这样的方法：
        byte    byteValue() 将指定数字的值以byte形式作为返回
        abstract double    doubleValue() 将指定数字的值以double形式作为返回
        abstract float    floatValue() 将指定数字的值以float形式作为返回
        abstract int    intValue() 将指定数字的值以int形式作为返回
        abstract long    longValue() 将指定数字的值以long形式作为返回
        short    shortValue() 将指定数字的值以short形式作为返回
        这些方法其实所有的数字包装类的子类都有，这些方法是负责拆箱的。
    public class IntegerTest02 &#123;
        public static void main(String[] args) &#123;
           //123这个基本数据类型，进行构造方法的包装达到了：基本数据类型向引用数据类型的转换
           //基本数据类型 --(转换为)-&gt; 引用数据类型 (装箱)
           Integer i = new Integer(123);

           //将引用数据类型 --(转换为)-&gt; 基本数据类型 (拆箱)
           float f = i.floatValue();
           System.out.println(f); //123.0
        &#125;
    &#125;
    6）、 关于Integer类的构造方法有两个：
           Integer(int);
           Integer(String);
        通过访问包装类的常量，来获取最大值和最小值

        在java5之后，支持自动拆箱和自动装箱
           自动装箱：基本数据类型自动转换成包装类
           自动拆箱：包装类自动转换成基本数据类型

           有了自动拆箱之后，Number类中的方法就用不着了！
           好处：方便编程
    public class IntegerTest03 &#123;
        public static void main(String[] args) &#123;
           //java9之后不建议使用这个构造方法了，出现横线表示已过时。
           //将数字100转换为Integer包装类型(int --&gt; integer)
           //x是一个引用，x是一个变量，x还是保存了一个对象的内存地址。
           Integer x = new Integer(100);

           //将String类型的数字，转换成Integer包装类型。(String --&gt; integer)
           Integer y = new Integer(&quot;123&quot;);

           //double --&gt; Double
           Double d = new Double(1.23);

           //String --&gt; Double
           Double e = new Double(&quot;3.14&quot;);

           //通过访问包装类的常量，来获取最大值和最小值
           System.out.println(&quot;int的最大值:&quot; + Integer.MAX_VALUE); //int的最大值:2147483647
           System.out.println(&quot;int的最小值:&quot; + Integer.MIN_VALUE); //int的最小值:-2147483648
           System.out.println(&quot;byte的最大值:&quot; + Byte.MAX_VALUE); //byte的最大值:127
           System.out.println(&quot;byte的最小值:&quot; + Byte.MIN_VALUE); //byte的最小值:-128

           //自动装箱
           //100是基本数据类型
           //x1是包装类型
           //基本数据类型 --(自动转换)--&gt; 包装类型
           Integer x1 = 100;

           //自动拆箱
           //y1是基本数据类型
           //x1是包装类型
           //包装类型 --(自动转换)--&gt; 基本数据类型
           int y1 = x1;

           //分析为什么这个数据没有报错呢？
           //+两边要求是基本数据类型，x1是包装类，不属于基本数据类型，这里会自动拆箱，
           //将x1转换成基本数据类型
           System.out.println(x1 + 1);

           /*
              java中为了提高程序的执行效率，将[-128,127]之间所有的包装对象提前创建好，
              放到了一个方法区的&quot;整数型常量池&quot;当中了
              目的是只要用这个区间的数据不需要再new了，直接从整数型常量池当中取出来。
            */
           Integer m = 128; //Integer m = new Integer(128); 
           m个引用，保存对象的内存地址指向对象
           Integer n = 128; //Integer n = new Integer(128);
            n是个引用，保存对象的内存地址指向对象
           System.out.println(m == n); //false
           //双等号比较的是对象的内存地址，m和n两个引用种保存的对象的内存地址不同。
           //== 这个运算符不会触发自动拆箱机制。（只有+ - * / 等运算的时候才会）

           Integer h = 127;
           Integer t = 127;
           //原理：x变量中保存的对象的内存地址和y变量中保存的对象的内存地址是一样的
           System.out.println(h == t); //true
        &#125;
    &#125;
</code></pre>
<h3 id="7）、总结一下之前所学的经典异常："><a href="#7）、总结一下之前所学的经典异常：" class="headerlink" title="7）、总结一下之前所学的经典异常："></a>7）、总结一下之前所学的经典异常：</h3><pre><code>    空指针异常：NullPointerException
    类型转换异常：ClassCastException
    数组下标越界异常：ArrayIndexOutOfBoundsException
    数字格式化异常：NumberFormatException
    Integer类当中有哪些常用的方法呢？
    public class IntegerTest04 &#123;
        public static void main(String[] args) &#123;
           //手动装箱
          Integer x = new Integer(100);
           //手动拆箱
          int y = x.intValue();
          System.out.println(y);

           //Integer a = new Integer(&quot;123&quot;);
           //编译的时候没问题，一切符合语法，运行时会不会出现问题呢？
           //不是一个“数字”可以包装成Integer吗? 不能，运行时出现异常。
           //java.lang.NumberFormatException (数字格式化异常)
           //Integer a = new Integer(&quot;中国&quot;);

           //重点方法
           // static int    parseInt(String s)
           //静态方法，传参String，返回int
           //网页上文本框中输入的100实际上是“100”字符串；后台数据库种要求存储100数字，
           //此时java程序需要将“100”转换成100数字。
           int retValue = Integer.parseInt(&quot;123&quot;); //String --&gt; int
           System.out.println(retValue); //123
           //int retValue = Integer.parseInt(&quot;中文&quot;); 
           //NumberFormatException (数字格式化异常)

           //照葫芦画瓢
           double retValue2 = Double.parseDouble(&quot;3.14&quot;);
           System.out.println(retValue2 + 1); //4.140000000000001 (精度问题)
           
           /*
              String Integer int之间相互转换
            */
           //String --&gt; int
           String s1 = &quot;100&quot;;
           int i1 = Integer.parseInt(s1);
           System.out.println(i1);

           //int --&gt; String
           String s2 = String.valueOf(i1);
           System.out.println(s2);

           String s3 = i1 + &quot;&quot;;
           System.out.println(s3 + 1); //1001

           //int --&gt; Integer
           //自动装箱
           Integer m = 1000;

           //Integer --&gt; int
           //自动拆箱
           int n = x;

           //String --&gt; Integer
           Integer k = Integer.valueOf(&quot;123&quot;);

           //Integer --&gt; String
           String s4 = String.valueOf(k);
        &#125;
    &#125;
</code></pre>
<h3 id="8）、java中对时间的处理"><a href="#8）、java中对时间的处理" class="headerlink" title="8）、java中对时间的处理"></a>8）、java中对时间的处理</h3><pre><code>import java.text.SimpleDateFormat;
import java.util.Date;
/*
java中对日期的处理
    这个案例最主要掌握String和Date之间的互相转换
 */
public class DateTest01 &#123;
    public static void main(String[] args) throws Exception&#123;
       //获取系统当前时间(精确到毫秒的系统当前时间)
       //直接调用无参数构造方法就行
       Date nowTime = new Date();
       //自动调用了已经重写的toString方法，
       System.out.println(nowTime); //Thu Feb 24 19:33:04 CST 2022

       //日期可以格式化吗？
       //将日期类型Date，按照指定的格式进行转换：Date --转换成具有一定格式的日期字符串--&gt; String

       //SimpleDateFormat是java.text包下的，专门负责日期格式化的。
       /*
       yyyy 年 (年时4位的)
       MM 月
       dd 日
       HH 时
       mm 分
       ss 秒
       SSS 毫秒 (毫秒时3为，最高999，1000毫秒代表1秒)
       注意：在日期格式中，除了y M d H m s S这些字符不能随便写之外，剩下的符号格式自己随意组织。
        */
       SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
       String nowTimeStr = sdf.format(nowTime);
       System.out.println(nowTimeStr); //2022-02-25 14:24:02 808

       //假设现在有一个日期字符串String，怎么转换成Date类型呢？
       String time = &quot;2022-02-25 14:24:02 808&quot;;
       //SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;格式不能随便写，要和日期字符串格式相同&quot;);
       SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
       Date datetime = sdf2.parse(time);
       System.out.println(datetime); //Fri Feb 25 14:24:02 CST 2022
    &#125;
&#125;
</code></pre>
<h3 id="9）、统计方法执行时长"><a href="#9）、统计方法执行时长" class="headerlink" title="9）、统计方法执行时长"></a>9）、统计方法执行时长</h3><pre><code>/*
获取自1970年1月1日 00:00:00 000到当前系统时间的总毫秒数。
1秒=1000毫秒

简单总结一下System类的相关属性和方法：
    System.out [out时System类的静态变量]
    System.out.println() [println()方法不是System类的，是PrintStream类的方法。]
    System.gc 建议启动垃圾回收器
    System.currentTimeMillis() 获取自1970年1月1日 00:00:00 000到当前系统时间的总毫秒数
    System.exit(0) 推出JVM
 */
public class DateTest02 &#123;
    public static void main(String[] args) &#123;
       //获取自1970年1月1日 00:00:00 000到当前系统时间的总毫秒数。
       long nowTimeMillis =System.currentTimeMillis();
       System.out.println(nowTimeMillis); //1645771208010

       //统计一个方法耗时
       //在调用目标方法之前记录一个毫秒数
       long begin = System.currentTimeMillis();
       print();
       //在调用完目标方法之后记录一个毫秒数
       long end = System.currentTimeMillis();
       System.out.println(&quot;耗费时长：&quot; + (end - begin) + &quot;毫秒&quot;); //耗费时长：24毫秒
    &#125;

    //需求：统计一个方法执行所耗费的时长
    public static void print()&#123;
       for (int i = 0; i &lt; 1000; i++)&#123;
          System.out.println(&quot;i =&quot; + i);
       &#125;
    &#125;
&#125;
</code></pre>
<h3 id="10）、通过毫秒构造Date对象"><a href="#10）、通过毫秒构造Date对象" class="headerlink" title="10）、通过毫秒构造Date对象"></a>10）、通过毫秒构造Date对象</h3><pre><code>import java.text.SimpleDateFormat;
import java.util.Date;

public class DateTest03 &#123;
    public static void main(String[] args) &#123;
       //这个时间是什么时间？
       //1970-01-01 00:00:00 001
       Date time = new Date(1); //注意：参数是一个毫秒
       SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
       String timeStr = sdf.format(time);
       //北京是东8区，差8个小时
       System.out.println(timeStr); //1970-01-01 08:00:00 001

       //获取昨天的此时的时间
       Date time2 = new Date(System.currentTimeMillis() - 1000 * 24 * 60 * 60);
       String timeStr2 = sdf.format(time2);
       System.out.println(timeStr2); //2022-02-24 15:11:44 189

       //获取去年的今天的时间
       Date time3 = new Date(System.currentTimeMillis() - (long)1000 * 24 * 60 * 60 * 365);
       String timeStr3 = sdf.format(time3);
       System.out.println(timeStr3);
    &#125;
&#125;
</code></pre>
<h1 id="六、枚举"><a href="#六、枚举" class="headerlink" title="六、枚举"></a>六、枚举</h1><pre><code>/*
    这个案例没有使用java中的枚举，分析以下程序，在设计方面有什么缺陷？
        以下代码可以编译，也可以运行，这些都没问题。
        在这个返回值类型上，返回一个int不恰当；既然最后的结果只是成功和失败，最好用布尔类型。
        因为布尔类型true和false正好可以表示两种不同的状态。

    总结：
        a、枚举是一种引用数据类型
        b、枚举类型怎么定义，语法是？
           enum 枚举类型名&#123;
              枚举值1, 枚举值2,...
           &#125;
        c、结果只有两种情况建议使用布尔类型；结果超过两种情况并且可以一枚一枚列举出来的，
            建议使用枚举类型。
     */
    public class enumTest01 &#123;
        public static void main(String[] args) &#123;
           Boolean retValue1 = divide(10,2);
           System.out.println(retValue1); //true

           Boolean retValue2 = divide(10,0);
           System.out.println(retValue2); //false

           Result retValue3 = divide2(10,2);
           System.out.println(retValue3); //SUCCESS

           Result retValue4 = divide2(10,0);
           System.out.println(retValue4); //FAIL
        &#125;

        /**
        * 以下程序，计算两个int类型的商
        * @param a int类型的数据
        * @param b int类型的数据
        * @return 返回1表示成功，返回0表示失败
        */
        /*
        public static int divide(int a,int b)&#123;
           try&#123;
              int c = a / b;
              //程序执行到此处，表示以上代码没有发生异常，表示执行成功！
              return 1;
              //如果程序员在返回值设置出错设置为10，编译器无法检查出来
              //我们一直追求的是：所有的错误京可能让编译器找出来，所有的错误越早发现越好！
              //return 10;
           &#125;catch (Exception e)&#123;
              //程序执行到此处表示以上程序出现了异常，表示执行失败
              return 0;
           &#125;
        &#125;
        */

        //改进
        public static Boolean divide(int a,int b)&#123;
           try&#123;
              int c = a / b;
              return true;
           &#125;catch (Exception e)&#123;
              return false;
           &#125;
        &#125;
        
        /*
        思考：以上的这个方法设计挺好，返回true和false表示两种情况，但是在以后的开发中，
        有可能遇到一个方法的执行结果包括三种情况，四种情况，五种情况不等，
        但是每一个都是可以数清楚的并且都是可以列举出来的，这个布尔类型就无法满足需求了。
        此时需要使用java语言中的枚举类型。
        */

        //采用枚举的方式改造程序
        //枚举：一枚一枚可以列举出来的才建议使用枚举类型。
        enum Result&#123;
           //枚举编译之后也是生成class文件；枚举也是一种引用数据类型；
           //没居中的每一个值可以看做是常量。
           //SUCCESS 是枚举Result类型中的一个值
           //FAIL 是枚举Result类型中的一个值
           //枚举中的每一个值，可以看做是“常量”
           SUCCESS, FAIL
        &#125;
        public static Result  divide2(int a,int b)&#123;
           try&#123;
              int c = a / b;
              return Result.SUCCESS;
           &#125;catch (Exception e)&#123;
              return Result.FAIL;
           &#125;
        &#125;
    &#125;
</code></pre>
<h1 id="七、异常"><a href="#七、异常" class="headerlink" title="七、异常"></a>七、异常</h1><h2 id="1、什么是异常，java提供异常处理机制有什么用？"><a href="#1、什么是异常，java提供异常处理机制有什么用？" class="headerlink" title="1、什么是异常，java提供异常处理机制有什么用？"></a>1、什么是异常，java提供异常处理机制有什么用？</h2><pre><code>       以下程序执行过程中发生了不正常的情况，而这种不正常的情况叫做：异常
       java语言是很完善的语言，提供了异常的处理方式，以下程序执行过程中出现了不正常情况，
       Java把该异常信息打印输出到控制台，供程序员参考。程序员看到异常信息之后，
       可以对程序进行修改，让程序更加健壮。

       作用：增强程序的健壮性。
</code></pre>
<h2 id="2、java语言中异常是以什么形式存在的呢？"><a href="#2、java语言中异常是以什么形式存在的呢？" class="headerlink" title="2、java语言中异常是以什么形式存在的呢？"></a>2、java语言中异常是以什么形式存在的呢？</h2><pre><code>    异常在java中以类的形式存在，每一个异常类都可以创建一个异常对象
    public class ExceptionTest02 &#123;
        public static void main(String[] args) &#123;
           //通过异常类实例化异常对象
           NumberFormatException nfe = new NumberFormatException(&quot;数字格式化异常&quot;);
           System.out.println(nfe); //java.lang.NumberFormatException: 数字格式化异常

           //通过异常类，创建异常对象
           NullPointerException npe = new NullPointerException(&quot;空指针异常&quot;);
           System.out.println(npe); //java.lang.NullPointerException: 空指针异常
        &#125;
    &#125;
</code></pre>
<h2 id="3、java的异常处理机制"><a href="#3、java的异常处理机制" class="headerlink" title="3、java的异常处理机制"></a>3、java的异常处理机制</h2><h3 id="1）、什么是UML？有什么用？"><a href="#1）、什么是UML？有什么用？" class="headerlink" title="1）、什么是UML？有什么用？"></a>1）、什么是UML？有什么用？</h3><pre><code>UML是一种同意建模语言；一种图标式语言（画图的）
UML不是只有java中使用，只要是面向对象的编程语言都有UML。
一般画UML图的都是软件架构师或者说是系统分析师；软件设计人员使用UML。

在UML图中可以描述类和类之间的关系，程序执行的流程，对象的状态等...
在java软件开发当中，软件分析师/设计师负责设计类，java软件开发人员必须要能看懂。
</code></pre>
<h3 id="2）、异常在java中以类和对象的形式存在，那么异常的继承结构是怎样的？"><a href="#2）、异常在java中以类和对象的形式存在，那么异常的继承结构是怎样的？" class="headerlink" title="2）、异常在java中以类和对象的形式存在，那么异常的继承结构是怎样的？"></a>2）、异常在java中以类和对象的形式存在，那么异常的继承结构是怎样的？</h3><pre><code>我们可以使用UML图来描述一下继承结构。
画UML图有很多工具，例如：Rational Rose（收费的）、starUML等...
</code></pre>
<h4 id="a）、Object"><a href="#a）、Object" class="headerlink" title="a）、Object"></a>a）、Object</h4><pre><code>    Object下有Throwable（可抛出的）
    Throwable下有两个分支：Error（不可处理，直接退出JVM）和Exception（可处理的）
    Exception下有两个分支：
        Exception的直接子类：编译时异常（要求程序员在编写阶段必须预先对这些异常进行处理，
        如果不处理编译器报错因此得名）
        又称为：受检异常，受控异常
        RunTimeException：运行时异常（在编写程序阶段程序员可以预先处理，也可以不管，都行）
        又称为：未受检异常，非受控异常
</code></pre>
<h4 id="b）、编译时异常和运行时异常都是发生在运行阶段，编译阶段宜昌市不会发生的。"><a href="#b）、编译时异常和运行时异常都是发生在运行阶段，编译阶段宜昌市不会发生的。" class="headerlink" title="b）、编译时异常和运行时异常都是发生在运行阶段，编译阶段宜昌市不会发生的。"></a>b）、编译时异常和运行时异常都是发生在运行阶段，编译阶段宜昌市不会发生的。</h4><h4 id="c）、编译时异常因为什么而得名？"><a href="#c）、编译时异常因为什么而得名？" class="headerlink" title="c）、编译时异常因为什么而得名？"></a>c）、编译时异常因为什么而得名？</h4><pre><code>        因为编译时异常必须在编译（编写）阶段预先处理，如果不处理，编译器报错，因此而得名
        所有异常都是在运行阶段发生的，因为只有程序运行阶段才可以new对象。
        因为异常的发生就是new异常对象。
</code></pre>
<h4 id="d）、编译时异常和运行时异常的区别？"><a href="#d）、编译时异常和运行时异常的区别？" class="headerlink" title="d）、编译时异常和运行时异常的区别？"></a>d）、编译时异常和运行时异常的区别？</h4><pre><code>        编译时异常一般发生的概率比较高
            举个例子：
                你看到外面下雨了，你出门之前会预料到：如果不打伞，可能回生病（生病是一种异常）
                而这个异常发生的概率很高，所以出门之前要拿一把伞。
                “拿一把伞”就是对“生病异常”发生之前的一种处理方式。

                对于一些发生概率较高的异常，需要在运行之前对其进行预处理。
        运行时异常一般发生的概率比较低。
            举个例子：
                小明走在大街上，可能会被天上的飞机轮子砸到；“被飞机轮子砸到”也算是一种异常，
                但是这种异常发生的概率较低。在出门之前没必要提前对这种发生概率较低的异常进行预处理；
                如果你预处理这种异常，你将活得很累。

        假设java中没有对异常进行划分，没有分为：编译时异常和运行时异常，所有的异常都需要在编写程序
        阶段对其进行预处理，将是一种怎样的效果呢？
            首先如果这样的话，程序肯定绝对的安全；
            但是程序员编写程序太累，代码到处都是处理异常的代码。
</code></pre>
<h4 id="e）、Java语言中对异常的处理包括两种方式："><a href="#e）、Java语言中对异常的处理包括两种方式：" class="headerlink" title="e）、Java语言中对异常的处理包括两种方式："></a>e）、Java语言中对异常的处理包括两种方式：</h4><pre><code>        第一种方式：在方法声明的位置上，使用throws关键字，抛给上一级。
            谁调用我，我就抛给谁，抛给上一级。
        第二种方式：使用try..catch语句进行异常的捕捉。
            这件事发生了，谁也不知道，因为我给抓住了。
        举个例子：
            我是一名销售，因为我的失误公司损失了1000元，“损失1000元”可以看做是一个异常发生了。
            我有两种处理方式；
            第一种方式：我把这件事告诉我的领导【异常上抛】
            第二种方式：我自己掏腰包把这个钱补上【异常的捕捉】

        思考：
            异常发生之后，如果我选择了上抛，抛给了我的调用者，调用者需要对这个异常继续处理，
            那么调用者处理这个异常同样有两种处理方式。
        注意：
            异常发生之后如果一直上抛，最终抛给了main方法，main方法继续上抛，
            抛给了调用者JVM，JVM知道这个异常发生，只有一个结果，终止java程序的执行。
        
</code></pre>
<h4 id="f）、以下代码报错的原因是什么？"><a href="#f）、以下代码报错的原因是什么？" class="headerlink" title="f）、以下代码报错的原因是什么？"></a>f）、以下代码报错的原因是什么？</h4><pre><code>    因为doSome方法声明位置上使用了throws ClassNotFoundException
    而ClassNotFoundException是编译时异常，必须编写代码时处理，没有处理编译器报错。
    public class ExceptionTest03 &#123;
        public static void main(String[] args)&#123;
           //main方法中调用doSome方法
           //因为doSome方法声明位置上有：throws ClassNotFoundException
           //我们在调用doSome()方法的时候必须对这种异常进行预先处理。
           //如果不处理，编译器就报错。
           //编译器报错信息：Unhandled exception: java.lang.ClassNotFoundException
           //doSome();

           //第一种方式：在方法声明的位置上继续使用：throws，来完成异常的继续上抛，抛给调用者。
           //上抛类似于推卸责任(继续把异常传给调用者)
           /*
           public static void main(String[] args) throws ClassNotFoundException&#123;
           doSome();
           &#125;
           */

           //第二种处理方式：try..catch进行捕捉。
           //捕捉等于把异常拦下来了，异常真正的解决了，调用者是不知道的。
           try &#123;
              doSome();
           &#125; catch (ClassNotFoundException e) &#123;
              e.printStackTrace();
           &#125;
        &#125;

    /**
    * doSome方法在方法声明的位置上使用了：throws ClassNotFoundException
    * 这个代码表示doSome()在执行过程中，有可能出现ClassNotFoundException异常(叫做类没找到异常)
    * 这个异常直接父类时：Exception，所以ClassNotFoundException属于编译时异常。
    * @throws ClassNotFoundException
    */
    public static void doSome() throws ClassNotFoundException&#123;
       System.out.println(&quot;doSome!&quot;);
        &#125;
     &#125;
</code></pre>
<h3 id="3）、异常的处理方式"><a href="#3）、异常的处理方式" class="headerlink" title="3）、异常的处理方式"></a>3）、异常的处理方式</h3><pre><code>/*
处理异常的第一种方式：在方法声明的位置上，使用throws关键字抛出，谁调用我这个方法，我就抛给谁，
抛给调用者来处理。
 */    
import java.io.FileInputStream;
import java.io.FileNotFoundException;
public class ExceptionTest04 &#123;
    //一般不建议在main方法上使用throws，因为这个异常如果真的发生了，一定会抛给JVM。JVM只有终止。
    //所以一般main方法中的异常建议使用try..catch进行捕捉。main就不用上抛了
    public static void main(String[] args) &#123;
       System.out.println(&quot;main begin&quot;);
       m1();
       System.out.println(&quot;main over&quot;);
    &#125;

    public static void m1()&#123;
       System.out.println(&quot;m1 begin&quot;);
       m2();
       System.out.println(&quot;m1 over&quot;);
    &#125;

    private static void m2() &#123;
       System.out.println(&quot;m2 begin&quot;);
       //编译器报错原因是：m3方法声明位置上有throws FileNotFoundException
       //我们在这里调用m3没有对异常进行预处理，所以编译器报错。
       //m3();
       try &#123;
          m3();
       &#125; catch (FileNotFoundException e) &#123;
          System.out.println(&quot;文件不存在，可能路径错误，也可能该文件被删除了!&quot;);
       &#125;
       //注意：只要异常没有捕捉，采用上报的方式，此方法后续代码不会执行
       //另外需要注意，try语句块中的某一行出现异常，改行后面的代码不会执行
       //try..catch捕捉完成之后，后续代码可以执行。
       System.out.println(&quot;m2 over&quot;);
    &#125;

    private static void m3() throws FileNotFoundException &#123;
       //抛别的不行，抛给父类IOException，这样是可以的。
       //throws后面也可以写多个异常，使用逗号隔开。
       //调用SUN jdk中某个类的构造方法
       //这个类没有接触过，后期IO流的时候就知道了。
       //我们只是借助这个类学习一下异常处理机制。
       //创建一个输入流对象，该流指向一个文件。
       /*
       编译报错的原因是什么？
          第一：这里调用了一个构造方法：FileInputStream(String name)
          第二：这个构造方法的声明位置上有throws FileNotFoundException
          第三：通过类的继承结构看到：FileNotFoundException的父类是IOException，
                                                  IOException的父类是Exception
          最终得知，FileNotFoundException是编译时异常。

          错误原因：编译时异常要求程序员编写程序阶段必须对它进行处理，不处理编译器就报错。

        */
       //new FileInputStream(&quot;F:\\ideaIUproject\\Exception&quot;);

       //我们采用第一种处理方式：在方法声明的位置上使用throws继续上抛
       new FileInputStream(&quot;F:\\ideaIUproject\\Exception&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="4）、深入try…catch"><a href="#4）、深入try…catch" class="headerlink" title="4）、深入try…catch"></a>4）、深入try…catch</h3><h4 id="a）、catch后面的小括号中的类型可以是具体的异常类型，也可以是该异常类型的父类型"><a href="#a）、catch后面的小括号中的类型可以是具体的异常类型，也可以是该异常类型的父类型" class="headerlink" title="a）、catch后面的小括号中的类型可以是具体的异常类型，也可以是该异常类型的父类型"></a>a）、catch后面的小括号中的类型可以是具体的异常类型，也可以是该异常类型的父类型</h4><h4 id="b）、catch可以写多个；建议catch的时候，精确地一个一个处理。这样利于程序调试。"><a href="#b）、catch可以写多个；建议catch的时候，精确地一个一个处理。这样利于程序调试。" class="headerlink" title="b）、catch可以写多个；建议catch的时候，精确地一个一个处理。这样利于程序调试。"></a>b）、catch可以写多个；建议catch的时候，精确地一个一个处理。这样利于程序调试。</h4><h4 id="c）、catch必须遵循从小到大的原则。"><a href="#c）、catch必须遵循从小到大的原则。" class="headerlink" title="c）、catch必须遵循从小到大的原则。"></a>c）、catch必须遵循从小到大的原则。</h4><h4 id="d）、在开发中，处理编译异常时，应该上报还是捕捉呢，怎么选？"><a href="#d）、在开发中，处理编译异常时，应该上报还是捕捉呢，怎么选？" class="headerlink" title="d）、在开发中，处理编译异常时，应该上报还是捕捉呢，怎么选？"></a>d）、在开发中，处理编译异常时，应该上报还是捕捉呢，怎么选？</h4><pre><code>        如果希望调用者来处理，选择throws上报；其他情况使用捕捉的方式。
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
public class ExceptionTest05 &#123;
    public static void main(String[] args) &#123;
       /*try&#123;
       FileInputStream fis= new FileInputStream(&quot;F:\\ideaIUproject\\Exception&quot;);
          System.out.println(&quot;以上出现异常，这里无法执行!&quot;);
       &#125;//catch(FileNotFoundException e)&#123;
       catch(IOException e)&#123; //多态：IOException e = new FileNotFoundException();
       // Exception也可以。
          System.out.println(&quot;文件不存在!&quot;);
       &#125;
       */

       /*
       try&#123;
          FileInputStream fis= new FileInputStream(&quot;F:\\ideaIUproject\\Exception&quot;);
          fis.read();
       &#125; catch(FileNotFoundException e)&#123;
          System.out.println(&quot;文件不存在!&quot;);
       &#125;catch (IOException e)&#123;
          System.out.println(&quot;读文件报错了!&quot;);
       &#125;
       System.out.println(&quot;hello World!&quot;);
       */

       try&#123;
          FileInputStream fis= new FileInputStream(&quot;F:\\ideaIUproject\\Exception&quot;);

          //进行数学运算
          System.out.println(100 / 0); //这个异常是运行时异常，编写程序时可以处理，也可以不处理。
       &#125; catch(FileNotFoundException | ArithmeticException e)&#123;
          System.out.println(&quot;文件不存在或数学计算异常&quot;);
       &#125;
    &#125;
&#125;
</code></pre>
<h3 id="5）、异常对象有两个重要的方法："><a href="#5）、异常对象有两个重要的方法：" class="headerlink" title="5）、异常对象有两个重要的方法："></a>5）、异常对象有两个重要的方法：</h3><pre><code>    获取异常简单的描述信息：
       String msg = exception.getMessage();
    打印异常追踪的堆栈信息：
       exception.printStackTrace();

我们以后查看异常的追踪信息，我们应该怎么看可以快速的调试程序呢？
    异常追踪信息从上往下一行一行看；
    但是需要注意的是：SUN写的代码就不用看了(看包名就知道是自己的还是SUN的)，
    主要的问题是出现在自己编写的代码上。
public class ExceptionTest06 &#123;
    public static void main(String[] args) &#123;
       //这里只是为了测试getMassage()方法和printStackTrace()方法
       //这里只是new了异常对象，但是没有将异常对象抛出，JVM会认为这是一个普通的Java对象。
       NullPointerException e = new NullPointerException(&quot;空指针异常&quot;);

       //获取异常简单描述信息：这个信息实际上就是构造方法上面String参数。
       String msg = e.getMessage();
       System.out.println(msg); //空指针异常

       //打印异常堆栈信息
       //java后台打印异常堆栈追踪信息的时候，采用了异步线程的方式打印的。
       e.printStackTrace();
       /*
       java.lang.NullPointerException: 空指针异常
        at ExceptionTest06.main(ExceptionTest06.java:12)
       at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
       at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.
                                               invoke(NativeMethodAccessorImpl.java:62)
       at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.
                                               invoke(DelegatingMethodAccessorImpl.java:43)
       at java.base/java.lang.reflect.Method.invoke(Method.java:567)
       at com.intellij.rt.execution.application.AppMainV2.main(AppMainV2.java:131)
        */
       //这里程序不会党务执行，很健壮。（服务器不会因为遇到异常而宕机）
       System.out.println(&quot;hello world!&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="6）、关于try-catch中的finally子句："><a href="#6）、关于try-catch中的finally子句：" class="headerlink" title="6）、关于try..catch中的finally子句："></a>6）、关于try..catch中的finally子句：</h3><h4 id="a）、在finally子句中的代码是最后执行的，并且是一定会执行的，即使try语句块中的代码出现了异常。"><a href="#a）、在finally子句中的代码是最后执行的，并且是一定会执行的，即使try语句块中的代码出现了异常。" class="headerlink" title="a）、在finally子句中的代码是最后执行的，并且是一定会执行的，即使try语句块中的代码出现了异常。"></a>a）、在finally子句中的代码是最后执行的，并且是一定会执行的，即使try语句块中的代码出现了异常。</h4><pre><code>        finally子句必须和try一起出现，不能单独编写。
</code></pre>
<h4 id="b）、finally语句通常使用在哪些情况下呢？"><a href="#b）、finally语句通常使用在哪些情况下呢？" class="headerlink" title="b）、finally语句通常使用在哪些情况下呢？"></a>b）、finally语句通常使用在哪些情况下呢？</h4><pre><code>        通常在finally语句块中完成资源的释放/关闭。
        因为finally中的代码比较有保障；即使try语句块中的代码出现异常，finally中的代码也会正常执行。
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
public class ExceptionTest07 &#123;
    public static void main(String[] args) &#123;
       FileInputStream fis = null; //声明位置放到try外面，这样在finally中才能用。
       try &#123;
          //创建输入流对象
          fis = new FileInputStream(&quot;F:\\ideaIUproject\\Common Class\\String - Use.png&quot;);
          String s = null;
          //一定会出现空指针异常
          s.toString();
          //流使用完需要关闭，因为流是占资源的。
          //即使以上程序出现异常，流也必须要关闭！
          //放在这里，上面出现异常的话，流关不了
          //fis.close();
       &#125; catch (FileNotFoundException e) &#123;
          e.printStackTrace();
       &#125; catch (IOException e) &#123;
          e.printStackTrace();
       &#125; finally &#123;
          //流的关闭放在这里比较保险
          //finally中的代码一定会执行的
          //即使try中出现了异常
          if (fis != null) &#123; //避免空指针异常
             try &#123;
                //close()方法有异常，采用捕捉的方式。
                fis.close();
             &#125; catch (IOException e) &#123;
                e.printStackTrace();
             &#125;
          &#125;
       &#125;
    &#125;
&#125;
</code></pre>
<h3 id="7）、finally语句"><a href="#7）、finally语句" class="headerlink" title="7）、finally语句"></a>7）、finally语句</h3><pre><code>public class ExceptionTest08 &#123;
    public static void main(String[] args) &#123;
       /*
       try和finally，没有catch可以吗？ 可以。
          try不能单独使用；try finally可以联合使用

       以下代码的执行顺序：
          先执行try；
          再执行finally；
          最后执行return (return语句只要执行方法必然结束)

       放在finally中的语句是一定会执行的。
        */
       try&#123;
          System.out.println(&quot;try...&quot;);
          //return;

          //如果是System.exit(0);
          //退出JVM之后，finally语句中的代码就不执行了！
          System.exit(0);
       &#125;finally &#123;
          //finally中的语句会执行
          System.out.println(&quot;finally...&quot;);
       &#125;

       //这里不能写语句，因为这个代码是无法执行到的。
       //System.out.println(&quot;hello world&quot;); //Unreachable statement,无法到达的语句
    &#125;
&#125;
</code></pre>
<h3 id="8）、java语法规则（有些规则是不能破坏的，一旦这么说了，就必须这么做！）"><a href="#8）、java语法规则（有些规则是不能破坏的，一旦这么说了，就必须这么做！）" class="headerlink" title="8）、java语法规则（有些规则是不能破坏的，一旦这么说了，就必须这么做！）"></a>8）、java语法规则（有些规则是不能破坏的，一旦这么说了，就必须这么做！）</h3><pre><code>    java中有一条这样的规则：
       方法体中的代码必须遵循自上而下顺序一次逐行执行（亘古不变的语法！）
    java中还有一条语法规则：
       return语句一旦执行，整个方法必须结束（亘古不变的语法！）
public class ExceptionTest09 &#123;
    public static void main(String[] args) &#123;
       int result = m();
       System.out.println(result); //100
    &#125;

    private static int m() &#123;
       int i = 100;
       try&#123;
          //这行代码出现再int i = 100;的下面，所以最终结果必须是返回100；
          //return语句还必须保证是最后执行的，一旦执行，整个方法结束。
          return i;
       &#125;finally &#123;
          i++;
       &#125;
    &#125;
&#125;
</code></pre>
<h3 id="9）、final-finally-finalize有什么区别？"><a href="#9）、final-finally-finalize有什么区别？" class="headerlink" title="9）、final finally finalize有什么区别？"></a>9）、final finally finalize有什么区别？</h3><pre><code>        final 关键字
           final修饰的类无法继承
           final修饰的方法无法覆盖
           final修饰的变量不能重新赋值

        finally 关键字
           和try一起联合使用
           finally语句块中的代码必须是执行的

        finalize 标识符
           是一个Object类中的一个方法名
           这个方法是由垃圾回收器GC负责调用的
public class ExceptionTest10 &#123;
    public static void main(String[] args) &#123;
       //final是一个关键字，表示最终的，不变的
       final int i = 100;

       //finally也是一个关键字，和try联合使用，使用再异常处理机制中
       //在finally语句块中的代码是一定会执行的
       try&#123;

       &#125;finally &#123;
          System.out.println(&quot;finally...&quot;);
       &#125;

       //finalize()是Object类中的一个方法，作为方法名出现
       //所以finalize是标识符。
       //finalize()方法是JVM的GC垃圾回收器负责调用
       Object obj;
    &#125;
&#125;
</code></pre>
<h3 id="10）、异常在实际开发中的应用"><a href="#10）、异常在实际开发中的应用" class="headerlink" title="10）、异常在实际开发中的应用"></a>10）、异常在实际开发中的应用</h3><h4 id="a）、SUN提供的JDK内置的异常肯定是不够用的，在实际开发中，有很多业务，"><a href="#a）、SUN提供的JDK内置的异常肯定是不够用的，在实际开发中，有很多业务，" class="headerlink" title="a）、SUN提供的JDK内置的异常肯定是不够用的，在实际开发中，有很多业务，"></a>a）、SUN提供的JDK内置的异常肯定是不够用的，在实际开发中，有很多业务，</h4><pre><code>    这些业务出现异常之后，JDK中都是没有的，和业务挂钩。
    那么异常类我们程序员可以自己定义吗？ 可以！
</code></pre>
<h4 id="b）、Java中怎么自定义异常呢？"><a href="#b）、Java中怎么自定义异常呢？" class="headerlink" title="b）、Java中怎么自定义异常呢？"></a>b）、Java中怎么自定义异常呢？</h4><pre><code>        两步：
           第一步：编写一个类继承Exception或者RuntimeException。
           第二步：提供两个构造方法，一个无参数的，一个带有String参数的。
栈操作异常:自定义异常
注意：最后的例子，是异常最重要的案例，必须掌握，自定义异常在时机开发中的应用
public class MyStackOperationException extends Exception&#123; //编译时异常
    public  MyStackOperationException()&#123;

    &#125;

    public MyStackOperationException(String s)&#123;
       super(s);
    &#125;
&#125;

public class HomeWork &#123;
    public static void main(String[] args) &#123;
       //创建栈对象
       MyStack ms = new MyStack();
       //压栈
       try &#123;
          ms.push(new Object());
          ms.push(new Object());
          ms.push(new Object());
          ms.push(new Object());
          ms.push(new Object());
          ms.push(new Object());
          ms.push(new Object());
          ms.push(new Object());
          ms.push(new Object());
          ms.push(new Object());
          //这里栈满了
          ms.push(new Object());
       &#125; catch (MyStackOperationException e) &#123;
          //e.printStackTrace();
          //输出异常的简单信息
          System.out.println(e.getMessage());
       &#125;
       //弹栈
       try &#123;
          ms.pop();
          ms.pop();
          ms.pop();
          ms.pop();
          ms.pop();
          ms.pop();
          ms.pop();
          ms.pop();
          ms.pop();
          ms.pop();
          //这里栈空了
          ms.pop();
       &#125; catch (MyStackOperationException e) &#123;
          //e.printStackTrace();
          System.out.println(e.getMessage());
       &#125;

    &#125;

&#125;

class MyStack&#123;
    //向栈当中存储元素，我们这里使用一维数组模拟。存到栈中就表示存到数组中。
    //因为数组是我们学习java的第一个容器。
    //为什么选择Object类型数组？因为这个栈可以存储java中任何引用数据。
    //new Animal()对象可以放进去，new Person()对象也可以放进去，因为它们的超级父类就是Object。
    private Object[] elements;

    //栈帧永远指向栈顶部元素
//  那么这个默认初始值应该是多少？注意：最初的栈是空的，一个元素都没有。
//  private int index = 0;如果index采用0，表示栈帧指向了顶部元素的上方。
//  private int index = -1; //如果index采用-1，表示栈帧指向了顶部元素。
    private  int index;

    //无参构造方法，默认初始化栈容量10.
    public MyStack() &#123;
       //一维数组动态初始化
       this.elements = new Object[10];

       this.index = -1;
    &#125;
//  这是一个压栈的方法，obj表示被压的元素
    public void push(Object obj) throws MyStackOperationException &#123;
       if (index &gt;= elements.length - 1)&#123;
          /*
          //创建异常对象
          MyStackOperationException e = new MyStackOperationException(&quot;栈已满，压栈失败&quot;);
          //手动将异常抛出去
          throw e; //这里捕捉没有意义。自己new一个异常，自己捕捉，没有意义。
              栈已满这个信息你需要传递出去。
          */

          //合并(手动抛出异常)
          throw new MyStackOperationException(&quot;压栈失败，栈已满&quot;);
       &#125;

//      程序能够走到这里，说明栈没满
//      this.index ++;
//      this.elements[index] = obj;
       //先++再赋值
       elements[++index] = obj;
       System.out.println(&quot;压栈&quot; + obj + &quot;成功，栈帧指向&quot; + index);
    &#125;

//    这是一个弹栈的方法，从数组中往外取元素，每取出一个元素栈帧向下移动一位
    public void pop() throws MyStackOperationException &#123;
       if (index &lt; 0)&#123;
          throw new MyStackOperationException(&quot;弹栈失败，栈已空&quot;);
       &#125;

       //程序能够执行到此处说明栈没有空
       System.out.println(&quot;弹栈&quot; + elements[index] + &quot;成功!&quot;);
       System.out.println(&quot;栈帧指向&quot; + (--index));
    &#125;


    public Object[] getElements() &#123;
       return elements;
    &#125;

    public int getIndex()&#123;
       return index;
    &#125;

    public void setElements(Object[] elements) &#123;
       this.elements = elements;
    &#125;

    public void setIndex(int index) &#123;
       this.index = index;
    &#125;
&#125;
</code></pre>
<h3 id="11）、之前在讲解方法覆盖的时候，当时遗留了一个问题："><a href="#11）、之前在讲解方法覆盖的时候，当时遗留了一个问题：" class="headerlink" title="11）、之前在讲解方法覆盖的时候，当时遗留了一个问题："></a>11）、之前在讲解方法覆盖的时候，当时遗留了一个问题：</h3><pre><code>    重写之后的方法不能比重写之前的方法抛出更多(更宽泛)的异常，可以更少。
    public class ExceptionTest11 &#123;
    &#125;

    class Animal&#123;
        public void doSome()&#123;

        &#125;

        public void doOther() throws Exception&#123;

        &#125;
    &#125;

    class cat extends Animal&#123;
        //编译报错
       /*
       public void doSome() throws Exception&#123;

        &#125;
        */

       //编译正常
        /*
       public void doOther()&#123;

       &#125;
       */

        //编译正常
        public void doOther() throws Exception&#123;

        &#125;
    &#125;

/*
总结异常中的关键字：
    异常捕捉：
       try
       catch
       finally

    throws 在方法声明位置上使用，表示上报异常信息给调用者
    throw  手动抛出异常
 */
</code></pre>
<h3 id="12）、异常应用一"><a href="#12）、异常应用一" class="headerlink" title="12）、异常应用一"></a>12）、异常应用一</h3><pre><code> 编写程序模拟用户注册：
1、程序开始执行时，提示用户输入“用户名”和“密码”信息。
2、输入信息之后，后台java程序模拟用户注册。
3、注册时用户名要求在[6 - 14]之间，小于或者大于都表示异常。

注意：
    完成注册的方法放到一个单独的类中。
    异常类自定义即可。
 */
public class Homework2 &#123;
    public static void main(String[] args) &#123;
       System.out.println(&quot;请输入用户名和密码！&quot;);
       java.util.Scanner s = new java.util.Scanner(System.in);
       UserService us = new UserService();
       try &#123;
          us.register(s.next() , s.nextInt());
       &#125; catch (RegisterException e) &#123;
          System.out.println(e.getMessage());
       &#125;
    &#125;
&#125;

class UserService&#123;
    /**
    * 用户注册
    * @param username 用户名
    * @param password 密码
    * @throws RegisterException 用户名为null或者1用户名长度小于6，大于14，会出现异常。
    */
    public void register(String username, int password) throws RegisterException&#123;
       //这个方法完成注册！
       //引用等于null的这个判断最好梵高所有田间最前面。
       //username ==null 不如写成 null == username
       if (null == username || username.length() &gt; 14 || username.length() &lt; 6)&#123;
          throw new RegisterException(&quot;用户名请保持在[6 - 14]个字符之间！&quot;);
       &#125;
       System.out.println(&quot;注册成功！欢迎&quot; + &quot;[&quot; + username + &quot;]&quot;);
    &#125;
&#125;

class RegisterException extends Exception&#123;
    public RegisterException() &#123;
    &#125;

    public RegisterException(String message) &#123;
       super(message);
    &#125;
&#125;
</code></pre>
<h3 id="13）、异常应用二："><a href="#13）、异常应用二：" class="headerlink" title="13）、异常应用二："></a>13）、异常应用二：</h3><pre><code>    写一个类Army，代表一支军队，这个类有一个属性Weapon数组w(用来存储该军队拥有的所有武器)
    该类还提供一个构造方法，在构造方法里通过传一个int类型的参数来限定该类所拥有的最大武器数量
    并用这一大小来初始化w数组。

    该类还提供一个方法addWeapon(weapon wa)，表示把参数wa所代表的武器加入到数组w中。
    在这个类中还定义两个方法attackALL()让w数组中的所有武器攻击；以及moveALL()让w数组中的
    所有可移动的武器移动

    写一个主方法区测试以上程序。
    public class Homework3 &#123;
        public static void main(String[] args) &#123;
           //构建一个军队
           Army army = new Army(4); //代码只为军队添加了4个武器
           //创建武器对象
           Fighter fighter = new Fighter();
           Fighter fighter2 = new Fighter();
           Tank tank = new Tank();
           GaoShePao gaoShePao = new GaoShePao();
           WuZiJi wuZiJi = new WuZiJi();
           //添加武器
           try &#123;
              army.addWeapon(fighter);
              army.addWeapon(tank);
              army.addWeapon(gaoShePao);
              army.addWeapon(wuZiJi);
              army.addWeapon(fighter2);
           &#125; catch (WeaponException e) &#123;
              System.out.println(e.getMessage());
           &#125;

           //让所有可移动的移动
           army.moveAll();
           //让所有可攻击的攻击
           army.attackAll();
        &#125;
    &#125;

    /*
    可移动的接口
     */
    interface Moveable&#123;
        /**
        * 移动行为
        */
        void move();
    &#125;

    /*
    可攻击的接口
     */
    interface Attackable&#123;
        /**
        * 攻击行为
        */
        void attack();
    &#125;

    class Army&#123;
        private Weapon[] w;
        private Weapon wa;
        private int index;


        /**
        * 创建军队构造方法
        * @param a 武器数量
        */
        public Army(int a) &#123;
           w = new Weapon[a];
           this.index = -1;
        &#125;

        //构造addWeapon()方法，把武器存入库中
        public void addWeapon(Weapon wa) throws WeaponException&#123;
           if ( index &gt;= w.length-1)&#123;
              throw new WeaponException(&quot;武器库已满！&quot;);
           &#125;else if (null == wa )&#123;
              throw new WeaponException(&quot;武器出错！&quot;);
           &#125;
           w[++index] = wa;
           System.out.println(&quot;武器&quot; + wa + &quot;存放成功！&quot;);
        &#125;

        /**
        * 所有可攻击的武器攻击
        * @return
        */
        public void attackAll()&#123;
           for (int i = 0; i &lt; w.length;i++)&#123;
              if (w[i] instanceof Attackable)&#123;
                 /**
                  * 类在强制类型转换过程中，如果是类转换成接口类型，那么类和接口之间不存在继承关系，
                  * 也可以转换，在java中是允许的。
                  */
                 Attackable attackable = (Attackable)w[i];
                 attackable.attack();
              &#125;
           &#125;
        &#125;

        /**
        * 所有可移动的武器移动
        * @return
        */
        public void moveAll()&#123;
           for (int i = 0; i &lt; w.length;i++)&#123;
              if (w[i] instanceof Moveable)&#123;
                 Moveable moveable = (Moveable)w[i];
                 moveable.move();
              &#125;
           &#125;
        &#125;

        public Weapon[] getW() &#123;
           return w;
        &#125;

        public void setW(Weapon[] w) &#123;
           this.w = w;
        &#125;
    &#125;

    //所有武器的父类
    class Weapon&#123;

    &#125;

    /**
     * 坦克是一个武器，可移动，可攻击
     */

    class Tank extends Weapon implements Moveable,Attackable&#123;
        //攻击
        public void attack() &#123;
           System.out.println(&quot;坦克开炮&quot;);
        &#125;

        //移动
        public void move() &#123;
           System.out.println(&quot;坦克移动&quot;);
        &#125;

        //重写toString()方法
        public String toString()&#123;
           return &quot;坦克&quot;;
        &#125;
    &#125;

    /**
     * 高射炮
     */
    class GaoShePao extends Weapon implements Attackable&#123;
        //攻击
        public void attack() &#123;
           System.out.println(&quot;高射炮开炮&quot;);
        &#125;

        public String toString()&#123;
           return &quot;高射炮&quot;;
        &#125;
    &#125;

    /**
     * 战斗机
     */
    class Fighter extends Weapon implements Attackable,Moveable&#123;
        //移动
        public void move() &#123;
           System.out.println(&quot;战斗机起飞&quot;);
        &#125;

        //攻击
        public void attack() &#123;
           System.out.println(&quot;战斗机攻击&quot;);
        &#125;

        public String toString()&#123;
           return &quot;战斗机&quot;;
        &#125;
    &#125;

    /**
     * 物资机
     */
    class WuZiJi extends Weapon implements Moveable&#123;
        @Override
        public void move() &#123;
           System.out.println(&quot;物资机起飞&quot;);
        &#125;

        public String toString()&#123;
           return &quot;物资机&quot;;
        &#125;
    &#125;

    //武器库异常
    class WeaponException extends Exception&#123;
        public WeaponException() &#123;

        &#125;

        public WeaponException(String message) &#123;
           super(message);
        &#125;
    &#125;
</code></pre>
<h1 id="八、集合"><a href="#八、集合" class="headerlink" title="八、集合"></a>八、集合</h1><h2 id="1、集合概述"><a href="#1、集合概述" class="headerlink" title="1、集合概述"></a>1、集合概述</h2><h3 id="1）、什么是集合？有什么用？"><a href="#1）、什么是集合？有什么用？" class="headerlink" title="1）、什么是集合？有什么用？"></a>1）、什么是集合？有什么用？</h3><pre><code>    数组其实就是一个集合。集合实际上就是一个容器，可以来容纳其他类型的数据。

    集合为什么说在开发中使用较多？
        集合是一个容器，一个载体，可以一次容纳多个对象。
        在实际开发中假设链接数据库，数据库当中有十条记录，那么假设把这10条记录查询出来，
        在java程序中会将10条数据封装成10个java对象，
        然后将10个java对象放到某个集合当中，将集合传到前端，然后遍历集合，将数据一个一个展现出来。
</code></pre>
<h3 id="2）、集合不能直接存储基本数据类型，另外集合也不能直接存储java对象，集合当中存储的都是java对象的内存地址。-或者说集合中存储的是引用。"><a href="#2）、集合不能直接存储基本数据类型，另外集合也不能直接存储java对象，集合当中存储的都是java对象的内存地址。-或者说集合中存储的是引用。" class="headerlink" title="2）、集合不能直接存储基本数据类型，另外集合也不能直接存储java对象，集合当中存储的都是java对象的内存地址。(或者说集合中存储的是引用。)"></a>2）、集合不能直接存储基本数据类型，另外集合也不能直接存储java对象，集合当中存储的都是java对象的内存地址。(或者说集合中存储的是引用。)</h3><pre><code>    list.add(100); //自动装箱Integer
    注意：集合在java中本身是一个容器，是一个对象；集合中任何时候存储的都是&quot;引用&quot;。
</code></pre>
<h3 id="3）、在java中每一个不同的集合，底层会对应不同的数据结构，往不同的集合中存储元素，等于将数据放到了不同的数据结构当中。"><a href="#3）、在java中每一个不同的集合，底层会对应不同的数据结构，往不同的集合中存储元素，等于将数据放到了不同的数据结构当中。" class="headerlink" title="3）、在java中每一个不同的集合，底层会对应不同的数据结构，往不同的集合中存储元素，等于将数据放到了不同的数据结构当中。"></a>3）、在java中每一个不同的集合，底层会对应不同的数据结构，往不同的集合中存储元素，等于将数据放到了不同的数据结构当中。</h3><pre><code>什么是数据结构？数据存储的结构就是数据结构；不同的数据结构，数据存储方式不同。
    例如：
        数组、二叉树、链表、哈希表 ....
        以上这些都是常见的数据结构。
    在java集合这一章节，你需要掌握的不是精通数据结构，java中已经将数据结构实现了，
    已经写好了这些常用的集合类，你只需要掌握怎么用，
    在什么情况下选择哪一种合适的集合使用即可。

    new ArrayList();创建一个集合对象，底层是数组。
    new LinkList();创建一个集合对象，底层是链表。
    new TreeList();创建一个集合对象，底层是二叉树。
    .....
</code></pre>
<h3 id="4）、集合在java-JDK中哪个包下？"><a href="#4）、集合在java-JDK中哪个包下？" class="headerlink" title="4）、集合在java JDK中哪个包下？"></a>4）、集合在java JDK中哪个包下？</h3><pre><code>    java.util.*;
    所有的集合类和集合接口都在java.util包下。
</code></pre>
<h3 id="5）、为了让大家掌握集合这块的内容，最好能将集合的继承结构图背会！！！"><a href="#5）、为了让大家掌握集合这块的内容，最好能将集合的继承结构图背会！！！" class="headerlink" title="5）、为了让大家掌握集合这块的内容，最好能将集合的继承结构图背会！！！"></a>5）、为了让大家掌握集合这块的内容，最好能将集合的继承结构图背会！！！</h3><pre><code>    集合整个的体系是怎样的一个结构，你需要有印象。
</code></pre>
<h3 id="6）、在Java中集合分为两大类："><a href="#6）、在Java中集合分为两大类：" class="headerlink" title="6）、在Java中集合分为两大类："></a>6）、在Java中集合分为两大类：</h3><pre><code>一类是单个方式存储元素：
    单个方式存储元素，这一类集合中超级父接口：java.util.Collection;
一类是以键值对的方式存储元素
    以键值对的方式存储元素，这一类集合中超级父接口：java.util.Map;

Iterator it = &quot;Collection 对象&quot;.iterator();
it就是迭代器对象。

结构图见文件夹Collection下的图文件。
</code></pre>
<h3 id="7）、总结-所有的实现类-："><a href="#7）、总结-所有的实现类-：" class="headerlink" title="7）、总结(所有的实现类)："></a>7）、总结(所有的实现类)：</h3><pre><code>    a）、ArrayList：底层是数组。
    b）、LinkList：底层是双向链表。
    c）、Vector：底层是数组，线程安全的，效率较低，使用较少。
    d）、HashSet：底层是HashMap，放到HashSet集合中的元素等同于放到HashMap集合key部分了。
    e）、TreeSet：底层是TreeMap，放到TreeSet集合中的元素等同于放到TreeMap集合key部分了。
    f）、HashMap：底层是哈希表。
    g）、Hashtable：底层也是哈希表，只不过是线程安全的，效率较低，使用较少。
    h）、Properties：是线程安全的，并且key和value只能存储字符串String。
    i）、TreeMap：底层是二叉树。TreeMap集合key可以按照大小顺序排序。

    List集合存储元素的特点：
        有序可重复
        有序：存进去的顺序和取出的顺序相同，每一个元素都有下标
        可重复：存进去1，可以再存储一个1
    Set(Map)集合存储元素的特点：
        无序不可重复
        无序：存进去的顺序和取出的顺序不一定相同。另外Set集合中元素没有下标。
        不可重复：存进去1，不能再存储1了。
    SortedSet(SortedMap)集合存储元素的特点：
        首先是无序不可重复的，但是SortedSet集合中的元素是可排序的。
        无序：存进去的顺序和取出的数据不一定相同。另外Set集合中元素没有下标。
        不可重复：存进去1，不能再存储1了。
        可排序：可以按照大小顺序排序。
    Map集合的key就是一个set集合。往set集合中放数据，实际上放到了Map集合的key部分。
</code></pre>
<h2 id="2、关于java-util-Collection接口中常用的方法。"><a href="#2、关于java-util-Collection接口中常用的方法。" class="headerlink" title="2、关于java.util.Collection接口中常用的方法。"></a>2、关于java.util.Collection接口中常用的方法。</h2><h3 id="1）、Collection中能存放什么元素？"><a href="#1）、Collection中能存放什么元素？" class="headerlink" title="1）、Collection中能存放什么元素？"></a>1）、Collection中能存放什么元素？</h3><pre><code>    没有使用“泛型”之前，Collection中可以存储Object的所有子类型。
    使用了“泛型”之后，Collection中只能存储某个具体的类型。
    集合后期我们会学习“泛型”语法；目前我们先不用管。Collection中什么都能存储，
    只要是Object的子类型都行。
    强调：集合中不能直接存储基本数据类型，也不能存java对象，只是存储java对象的内存地址。
</code></pre>
<h3 id="2）、Collection中的常用方法"><a href="#2）、Collection中的常用方法" class="headerlink" title="2）、Collection中的常用方法"></a>2）、Collection中的常用方法</h3><pre><code>    boolean    add(E e) //向集合中添加元素
    int    size() //获取集合中元素的个数
    void clear() //清空集合
    boolean    contains(Object o) //判断当前集合中是否包含元素o，包含返回true，不包含返回false
    boolean    isEmpty() //判断集合是否为空
    Object[] toArray() //调用这个方法可以把集合转换成数组
    import java.util.ArrayList;
    import java.util.Collection;
    public class CollectionTest01 &#123;
        public static void main(String[] args) &#123;
           //创建一个集合对象
           //Collection c = new Collection(); //接口是抽象的，无法实例化
           //多态
           Collection c = new ArrayList();
           //测试Collection接口中的常用方法
           c.add(1200); //自动装箱，实际上是放进去了一个对象的内存地址。
           //Integer x = new Integer(1200);
           c.add(3.14);
           c.add(new Object());

           //获取集合中元素的个数
           System.out.println(&quot;集合中元素的个数是：&quot; + c.size());

           //清空集合
           c.clear();
           System.out.println(&quot;集合中元素的个数是：&quot; + c.size());

           //再向集合中添加元素
           c.add(&quot;hello&quot;); //&quot;hello&quot;对象的内存地址放到了集合当中。
           c.add(&quot;world&quot;);
           c.add(&quot;浩克&quot;);
           c.add(&quot;绿巨人&quot;);

           //判断集合中是否包含&quot;绿巨人&quot;
           System.out.println(c.contains(&quot;绿巨人&quot;)); //true
           System.out.println(c.contains(&quot;绿巨人2&quot;)); //false

           //判断集合是否为空
           System.out.println(c.isEmpty()); //false

           //转换成数组
           Object[] obj = c.toArray();
           for (int i =0;i &lt; obj.length;i++)&#123;
              System.out.println(obj[i]);
           &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="3）、关于集合遍历-迭代专题（重点：五颗星-）"><a href="#3）、关于集合遍历-迭代专题（重点：五颗星-）" class="headerlink" title="3）、关于集合遍历/迭代专题（重点：五颗星*****）"></a>3）、关于集合遍历/迭代专题（重点：五颗星*****）</h3><pre><code>    import java.util.ArrayList;
    import java.util.Collection;
    import java.util.Iterator;
    public class CollectionTest02 &#123;
        public static void main(String[] args) &#123;
           //注意：以下讲解的遍历方式/迭代方式，是所有Collection通用的一种方式。
           //在Map集合中不能用，在所有的Collection以及子类中使用
           //创建集合对象
           Collection c = new ArrayList(); //后面的集合无所谓，
           //主要是看前面的Collection接口怎么遍历/迭代
           //添加元素
           c.add(&quot;abc&quot;);
           c.add(&quot;def&quot;);
           c.add(100);
           c.add(new Object());
           //对集合Collection进行遍历/迭代
           //第一步：获取集合对象的迭代器对象
           Iterator it = c.iterator();
           //第二步：通过以上获取的迭代器对象开始迭代/遍历集合
           /*
              以下两个方法是迭代器Iterateor中的方法：
              boolean    hasNext() //如果仍有元素可以迭代，则返回true
              Object next() //返回迭代的下一个元素；让迭代器前进一位，并且将指向的元素返回
            */
           /*
           //判断集合里是否还有可迭代的元素，如果有hasNext()方法返回true，next()方法返回元素，
           //如果没有hasNext()方法返回false
           //next()方法不执行；两种方法交替使用
           if (it.hasNext())&#123;
              //不管当初存进去什么，取出来统一是Object
              Object obj = it.next();
              System.out.println(obj);
           &#125;
           */
           //循环判断是否有元素可迭代，使用while循环
           while (it.hasNext())&#123;
              System.out.println(it.next());
           &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="4）、深入Collection集合的contains方法："><a href="#4）、深入Collection集合的contains方法：" class="headerlink" title="4）、深入Collection集合的contains方法："></a>4）、深入Collection集合的contains方法：</h3><pre><code>    boolean    contains(Object o) //判断当前集合中是否包含元素o，包含返回true，不包含返回false
    contains方法是用来判断集合中是否包含某个元素的方法，
    那么它在底层是怎么判断集合中是否包含某个元素的呢？
       调用了equals方法进行比对。
    import java.util.ArrayList;
    import java.util.Collection;
    public class CollectionTest03 &#123;
        public static void main(String[] args) &#123;
           //创建集合对象
           Collection c = new ArrayList();
           /*
           //向集合中存储元素
           c.add(&quot;abc&quot;);
           c.add(&quot;def&quot;);
           //集合中元素的个数
           System.out.println(&quot;元素的个数是：&quot; + c.size()); //元素的个数是：2

           System.out.println(c.contains(&quot;abc&quot;)); //true
           */
           //向集合中存储元素
           String s1 = new String(&quot;abc&quot;);
           c.add(s1);
           String s2 = new String(&quot;def&quot;);
           c.add(s2);
           String x = new String(&quot;abc&quot;);
           System.out.println(c.contains(x)); //true
        &#125;
    &#125;
</code></pre>
<h3 id="5）、测试contains方法"><a href="#5）、测试contains方法" class="headerlink" title="5）、测试contains方法"></a>5）、测试contains方法</h3><pre><code>    结论：存放在集合里的类型，一定要重写equals方法
    import java.util.ArrayList;
    import java.util.Collection;
    public class CollectionTest04 &#123;
        public static void main(String[] args) &#123;
           //创建集合对象
           Collection c = new ArrayList();
           //创建用户对象
           User u1 = new User(&quot;jack&quot;);
           User u2 = new User(&quot;jack&quot;);
           //加入集合
           c.add(u1);
           //判断集合中是否包含u2
           //System.out.println(c.contains(u2)); //false；因为没有重写equals方法
           System.out.println(c.contains(u2)); //true；重写equals方法之后就是true了

           //创建集合对象
           Collection cc = new ArrayList();
           String s1 = new String(&quot;hello&quot;);
           cc.add(s1);
           String s2 = new String(&quot;hello&quot;);
           //删除s2
           cc.remove(s2); //s1.equals(s2) java认为s1和s2是一样的，因为调了equals方法
           System.out.println(cc.size()); //0；说明remove()方法底层也调用了equals方法
        &#125;
    &#125;

    class User&#123;
        private String name;
        public User()&#123;&#125;
        public User(String name)&#123;
           this.name = name;
        &#125;

        //重写equals方法
        //将来调用equals方法的时候，一定是调用这个重写的equals方法
        //这个equals方法的比较原理是：只要姓名一样就表示同一个用户
        public boolean equals(Object object) &#123;
           if (this == object) return true;
           if (null == object || !(object instanceof User)) return false;
           User u = (User) object;
           return u.name.equals(this.name);
        &#125;
    &#125;
</code></pre>
<h3 id="6）、关于集合元素的remove"><a href="#6）、关于集合元素的remove" class="headerlink" title="6）、关于集合元素的remove"></a>6）、关于集合元素的remove</h3><pre><code>重点：当集合的结构发生改变时，迭代器一定要重新获取，如果还用老的迭代器，
就会出现异常。java.util.ConcurrentModificationException
     在迭代集合元素的过程中，不能调用集合对象的remove方法，删除元素：c.remove();
     会出翔：java.util.ConcurrentModificationException

     在迭代元素的过程当中，一定要使用迭代器Iterator的remove方法删除元素，
     不要使用集合自带的remove方法删除元素。
    import java.util.ArrayList;
    import java.util.Collection;
    import java.util.Iterator;
    public class CollectionTest05&#123;
    public static void main(String[] args) &#123;
           //创建集合
           Collection c = new ArrayList();
           //添加元素
           c.add(1);
           c.add(2);
           c.add(3);
           //获取迭代器
           //注意：集合结构一旦发生改变，迭代器一定要重新获取。
           Iterator it = c.iterator();
           while (it.hasNext())&#123;
              //编写代码时，next()方法返回值类型时object
              Object obj = it.next();
              //删除元素
              //删除元素之后，集合的结构发生了变化，应该重新区获取迭代器
              //但是，循环下一次的时候并没有重新获取迭代器，所以会出现异常；
              //c.remove(obj); //直接通过集合去删除元素，没有通知迭代器。
              //(导致迭代器的快照和原集合状态不同)
              //使用迭代器删除可以吗？
              it.remove(); //删除的一定是迭代器指向的当前元素
              System.out.println(obj);
           &#125;
           System.out.println(c.size()); //0
        &#125;
    &#125;
</code></pre>
<h2 id="3、List集合"><a href="#3、List集合" class="headerlink" title="3、List集合"></a>3、List集合</h2><h3 id="1）、List集合存储元素特点：有序可重复"><a href="#1）、List集合存储元素特点：有序可重复" class="headerlink" title="1）、List集合存储元素特点：有序可重复"></a>1）、List集合存储元素特点：有序可重复</h3><pre><code>    有序：List集合中的元素有下标
    从0开始，以1递增
    可重复：存储一个1，还可以再存储一个1
</code></pre>
<h3 id="2）、List既然是Collection接口的子接口，那么肯定List接口有自己“特色”的方法；"><a href="#2）、List既然是Collection接口的子接口，那么肯定List接口有自己“特色”的方法；" class="headerlink" title="2）、List既然是Collection接口的子接口，那么肯定List接口有自己“特色”的方法；"></a>2）、List既然是Collection接口的子接口，那么肯定List接口有自己“特色”的方法；</h3><pre><code>    以下只列出List接口特有的常用方法：
        void add(int index, Object element) 在此列表中的指定位置插入指定的元素。
        Object    get(int index) 返回此列表中指定位置处的元素。
        int    indexOf(Object o) 返回此列表中指定元素的第一次出现的索引，
                                            如果此列表不包含该元素，则返回-1。
        int    lastIndexOf(Object o) 返回此列表中指定元素的最后一次出现的索引，
                                            如果此列表不包含该元素，则返回-1。
        Object    remove(int index) 删除此列表中指定位置的元素。
        Object    set(int index, Object element) 将此列表中指定位置的元素替换为指定的元素。

    以上几个方法不需要死记硬背，可以自己编写代码测试一下，理解一下
    以后开发的时候，还是要翻阅帮助文档。
    import java.util.ArrayList;
    import java.util.Iterator;
    import java.util.List;
    public class ListTest01 &#123;
        public static void main(String[] args) &#123;
           //创建List类型的集合
           List myList = new ArrayList();
           //添加元素
           myList.add(&quot;A&quot;); //默认都是向集合末尾添加元素。
           myList.add(&quot;B&quot;);
           myList.add(&quot;C&quot;);
           myList.add(&quot;D&quot;);
           //在列表的指定位置插入指定元素(第一个参数是下标)
           //这个方法使用不多，因为对于ArrayList集合来说效率比较低
           myList.add(1,&quot;KING&quot;);

           //迭代
           Iterator it = myList.iterator();
           while (it.hasNext())&#123;
              System.out.println(it.next());
           &#125;

           //根据下标获取元素
           Object firstObj = myList.get(0);
           System.out.println(firstObj);

           //因为有下标，所以List集合有自己比较特殊的遍历方式
           //通过下标遍历。[List集合特有的]
           for (int i = 0;i &lt; myList.size();i++)&#123;
              System.out.println(myList.get(i));
           &#125;

           //获取指定对象第一次出现处的索引
           System.out.println(myList.indexOf(&quot;B&quot;)); //2

           //获取指定对象最后一次出现的索引
           System.out.println(myList.lastIndexOf(&quot;KING&quot;)); //1

           //删除指定下标位置的元素
           //删除下标为0的元素
           myList.remove(0);
           System.out.println(myList.size()); //4

           //修改指定位置的元素
           myList.set(2,&quot;Cc&quot;);
           //遍历集合
           for (int i = 0; i &lt; myList.size();i++)&#123;
              System.out.println(myList.get(i));
           &#125;
        &#125;
    &#125;
    /*
    计算机英语：
        增删改查这几个单词要知道：
           增：add、save、new
           删：delete、drop、remove
           改：update、set、modify
           查：find、get、query、select
     */
</code></pre>
<h2 id="4、主要的集合类"><a href="#4、主要的集合类" class="headerlink" title="4、主要的集合类"></a>4、主要的集合类</h2><h3 id="1）、ArrayList集合："><a href="#1）、ArrayList集合：" class="headerlink" title="1）、ArrayList集合："></a>1）、ArrayList集合：</h3><h4 id="a）、默认初始化容量10-底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量10"><a href="#a）、默认初始化容量10-底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量10" class="headerlink" title="a）、默认初始化容量10(底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量10)"></a>a）、默认初始化容量10(底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量10)</h4><h4 id="b）、集合底层是一个Object-数组"><a href="#b）、集合底层是一个Object-数组" class="headerlink" title="b）、集合底层是一个Object[]数组"></a>b）、集合底层是一个Object[]数组</h4><h4 id="c）、构造方法："><a href="#c）、构造方法：" class="headerlink" title="c）、构造方法："></a>c）、构造方法：</h4><pre><code>        new ArrayList();
        new ArrayList(20);
</code></pre>
<h4 id="d）、ArrayList集合的扩容："><a href="#d）、ArrayList集合的扩容：" class="headerlink" title="d）、ArrayList集合的扩容："></a>d）、ArrayList集合的扩容：</h4><pre><code>        原容量的1.5倍。
        ArrayList集合底层是数组，怎么优化？
            尽可能少地扩容，因为数组扩容效率比较低，
            建议在使用ArrayList集合地时候预估记元素的个数，
            给定一个初始化容量。
</code></pre>
<h4 id="e）、数组优点："><a href="#e）、数组优点：" class="headerlink" title="e）、数组优点："></a>e）、数组优点：</h4><pre><code>        检索效率比较高
</code></pre>
<h4 id="f）、数组缺点："><a href="#f）、数组缺点：" class="headerlink" title="f）、数组缺点："></a>f）、数组缺点：</h4><pre><code>        随机增删元素效率比较低
        另外数组无法存储大数据量，因为很难找到一块非常巨大的连续内存空间。
</code></pre>
<h4 id="g）、向数组末尾添加元素，效率很高，不受影响。"><a href="#g）、向数组末尾添加元素，效率很高，不受影响。" class="headerlink" title="g）、向数组末尾添加元素，效率很高，不受影响。"></a>g）、向数组末尾添加元素，效率很高，不受影响。</h4><h4 id="h）、这么多的集合，使用那个集合最多？"><a href="#h）、这么多的集合，使用那个集合最多？" class="headerlink" title="h）、这么多的集合，使用那个集合最多？"></a>h）、这么多的集合，使用那个集合最多？</h4><pre><code>        ArrayList集合；因为往数组末尾添加元素，效率不受影响；
        另外，我们检索/查询某个元素的操作比较多。
</code></pre>
<h4 id="i）、ArrayList集合是非线程安全的集合。-不是线程安全的集合"><a href="#i）、ArrayList集合是非线程安全的集合。-不是线程安全的集合" class="headerlink" title="i）、ArrayList集合是非线程安全的集合。(不是线程安全的集合)"></a>i）、ArrayList集合是非线程安全的集合。(不是线程安全的集合)</h4><pre><code>    import java.util.ArrayList;
    import java.util.List;
    public class ArrayListTest01 &#123;
        public static void main(String[] args) &#123;
           //默认初始化容量是10
           //数组的长度是20
           List list1 = new ArrayList();
           //集合的size()方法是获取当前集合中元素的个数，不是获取集合的容量
           System.out.println(list1.size()); //0
           //指定初始化容量
           List list2 = new ArrayList(20);

           list1.add(1);
           list1.add(2);
           list1.add(3);
           list1.add(4);
           list1.add(5);
           list1.add(6);
           list1.add(7);
           list1.add(8);
           list1.add(9);
           list1.add(0);

           System.out.println(list1.size());

           //再加一个元素
           list1.add(11);

           /*
           int newCapacity = ArraysSupport.newLength(oldCapacity,minCapacity - 
                                                           oldCapacity, oldCapacity &gt;&gt; 1 );
            */
           //100 二进制转换成10进制：00000100 右移一位 00000010（2）【4 / 2】
           //原先是4、现在增长：2，增长之后是6，增长之后的容量是之前容量的1.5倍。
        &#125;
    &#125;
</code></pre>
<h4 id="j）、位运算符-gt-gt-lt-lt"><a href="#j）、位运算符-gt-gt-lt-lt" class="headerlink" title="j）、位运算符 &gt;&gt; &lt;&lt;"></a>j）、位运算符 &gt;&gt; &lt;&lt;</h4><pre><code>public class BinaryTest &#123;
    public static void main(String[] args) &#123;
       // &gt;&gt; 1 二进制右移一位
       //10的二进制位：00001010 右移一位：00000101 [5]
       System.out.println(10 &gt;&gt; 1); //5，右移一位就是除以2

       // &lt;&lt; 二进制位左移
       //00001010 [10] 左移一位：00010100 [20]
       System.out.println(10 &lt;&lt; 1); //20,左移一位就是乘以2
    &#125;
&#125;
</code></pre>
<h4 id="k）、集合ArrayList的构造方法"><a href="#k）、集合ArrayList的构造方法" class="headerlink" title="k）、集合ArrayList的构造方法"></a>k）、集合ArrayList的构造方法</h4><pre><code>    import java.util.ArrayList;
    import java.util.Collection;
    import java.util.HashSet;
    import java.util.List;
    public class ArrayTest02 &#123;
        public static void main(String[] args) &#123;
           //默认初始化容量10
           List myList1 = new ArrayList();
           //指定初始化容量100
           List myList2 = new ArrayList(100);

           //创建一个HashSet集合
           Collection c = new HashSet();
           //添加元素
           c.add(100);
           c.add(200);
           c.add(900);
           c.add(50);

           //通过这个构造方法就可以将HashSet转换成List集合
           List myList3 = new ArrayList(c);
           for (int i = 0; i &lt; myList3.size();i++)&#123;
              System.out.println(myList3.get(i));
           &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="2）、链表类（单向链表）"><a href="#2）、链表类（单向链表）" class="headerlink" title="2）、链表类（单向链表）"></a>2）、链表类（单向链表）</h3><pre><code>public class Link &#123;
        //头节点
        Node header = null;

        int size;

        public int Size()&#123;
           return size;
        &#125;

        //向链表中添加元素的方法(向末尾添加)
        public  void add(Object obj)&#123;
           //创建一个新的节点对象
           //让之前单链表的末尾节点next指向新节点对象
           //有可能这个元素是第一个，也可能是第二个，也可能是第三个。
           if (header == null)&#123;
              //说明还没有节点
              //new一个新的节点对象作为头节点
              header = new Node(obj,null);
           &#125;else&#123;
              //说明头节点不是空，头节点已经有了
              //找出当前末尾节点，让当前的末尾节点的next是新节点
              Node currentLast = findLast(header);
              currentLast.next = new Node(obj,null);

           &#125;
           size++;

        &#125;

        /**
        * 专门查找末尾节点的方法
        * @param
        * @return
        */
        private Node findLast(Node node) &#123;
           if (node.next == null)&#123;
              //如果一个节点的next是null
              //说明这个系欸但就是末尾节点
              return node;
           &#125;
           //程序能够到这里说明：node不是末尾节点。
           return findLast(node.next); //递归算法
        &#125;

        //删除链表中某个数据的方法
        public void remove(Object obj)&#123;

        &#125;

        //修改链表中某个数据的方法
        public void modify(Object newObj)&#123;

        &#125;

        //查找链表中某个元素的方法
        public void find(Object obj)&#123;

        &#125;
    &#125;

    单链表中的节点。
    节点是单向链表中基本的单元
    每一个节点Node都有两个属性：
        一个属性：是存储的数据；
        另一个属性：是下一个节点的内存地址。

    链表优点：
        随机增删元素效率较高。(因为增删元素不涉及到大量元素位移的问题)
        由于链表上的元素在空间存储上内存地址不连续，因此随机增删效率较高。
        在以后的开发中，如果遇到随机增删集合中元素的业务比较多是，建议使用LinkedList。
    链表缺点：
        查询效率较低，每一次查找某个元素的时候都需要从头节点开始往下遍历。
        不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头节点开始遍历，
        知道找到为止；
        所以LinkedList集合检索/查找的效率较低。

    ArrayList：把检索发挥到极致(末尾添加元素效率还是很高的)
    LinkedList：把随机增删发挥到极致
    加元素都是往末尾添加，所以ArrayList用的比LinkedList多一些。
    public class Node &#123;
        //存储的数据
        Object element;
        //下一个节点的内存地址
        Node next;

        public Node() &#123;
        &#125;

        public Node(Object element, Node next) &#123;
           this.element = element;
           this.next = next;
        &#125;
    &#125;

    public class Test &#123;
        public static void main(String[] args) &#123;
           //创建了一个集合对象
           Link link = new Link();
           //往集合中添加元素
           link.add(100);
           link.add(200);
           link.add(300);
           //获取元素个数
           System.out.println(link.size); //3

           //LinkedList集合底层也是有下标
           //注意：ArrayList只所以检索效率比较高，不是丹村因为下标的原因。
           //是因为底层数组发挥的作用。
           //LinkedList集合照样有下标，但是检索/查找某个元素的时候效率比较低，
           //因为只能从头节点开始一个一个遍历。
           List list = new LinkedList();
           list.add(&quot;a&quot;);
           list.add(&quot;b&quot;);
           list.add(&quot;c&quot;);

           for (int i = 0;i &lt; list.size();i++)&#123;
              Object obj = list.get(i);
              System.out.println(obj);
           &#125;
           //LinkedList集合有初始化容量吗？ 没有
           //最初这个链表中没有任何元素。first和last引用都是null
           //不管是LinkedList还是ArrayList，以后写代码是都不需要关心具体是哪个集合。
           //因为我们要面向接口编程，调用的方法都是接口中的方法。
           //List list2 = new ArrayList(); 无论新建的是LinkedList集合还是ArrayList集合，
           //下面代码不受影响。
           List list2 = new LinkedList();
           list2.add(&quot;123&quot;);
           list2.add(&quot;456&quot;);
           list2.add(&quot;789&quot;);
           for (int i = 0;i &lt; list2.size();i++)&#123;
              System.out.println(list2.get(i));
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="3）、Vector"><a href="#3）、Vector" class="headerlink" title="3）、Vector"></a>3）、Vector</h3><h4 id="a）、底层也是一个数组"><a href="#a）、底层也是一个数组" class="headerlink" title="a）、底层也是一个数组"></a>a）、底层也是一个数组</h4><h4 id="b）、初始化容量：10"><a href="#b）、初始化容量：10" class="headerlink" title="b）、初始化容量：10"></a>b）、初始化容量：10</h4><h4 id="c）、怎么扩容的？"><a href="#c）、怎么扩容的？" class="headerlink" title="c）、怎么扩容的？"></a>c）、怎么扩容的？</h4><pre><code>          扩容之后是原容量的2倍；10 --&gt; 20 --&gt; 40
</code></pre>
<h4 id="d）、ArrayList集合扩容特点："><a href="#d）、ArrayList集合扩容特点：" class="headerlink" title="d）、ArrayList集合扩容特点："></a>d）、ArrayList集合扩容特点：</h4><pre><code>          扩展之后是原容量的1.5倍
</code></pre>
<h4 id="e）、Vector中所有的方法都是线程同步的，都带有synchronized关键字，是线程安全的，效率比较低，用的比较少"><a href="#e）、Vector中所有的方法都是线程同步的，都带有synchronized关键字，是线程安全的，效率比较低，用的比较少" class="headerlink" title="e）、Vector中所有的方法都是线程同步的，都带有synchronized关键字，是线程安全的，效率比较低，用的比较少"></a>e）、Vector中所有的方法都是线程同步的，都带有synchronized关键字，是线程安全的，效率比较低，用的比较少</h4><h4 id="h）、怎么将一个线程不安全的ArrayList集合转换成线程安全的呢？"><a href="#h）、怎么将一个线程不安全的ArrayList集合转换成线程安全的呢？" class="headerlink" title="h）、怎么将一个线程不安全的ArrayList集合转换成线程安全的呢？"></a>h）、怎么将一个线程不安全的ArrayList集合转换成线程安全的呢？</h4><pre><code>          使用集合工具类：
             java.util.Collections;是集合工具类。
             java.util.Collection;是集合接口。
    import java.util.*;
    public class VectorTest01 &#123;
        public static void main(String[] args) &#123;
           List vector = new Vector();
           vector.add(1);
           vector.add(2);
           vector.add(3);
           vector.add(4);
           vector.add(5);
           vector.add(6);
           vector.add(7);
           vector.add(8);
           vector.add(9);
           vector.add(10);
           vector.add(11);

           Iterator it = vector.iterator();
           while (it.hasNext())&#123;
              System.out.println(it.next());
           &#125;

           //这个可能以后要使用！！！！！
           List myList = new ArrayList(); //非线程安全的
           //变成线程安全的
           Collections.synchronizedList(myList); //这里没有办法看效果，因为多线程没学，先记住。
           myList.add(&quot;111&quot;);
           myList.add(&quot;222&quot;);
           myList.add(&quot;333&quot;);
        &#125;
    &#125;
</code></pre>
<h3 id="4）、HashSet集合"><a href="#4）、HashSet集合" class="headerlink" title="4）、HashSet集合"></a>4）、HashSet集合</h3><pre><code>无序不可重复
    import java.util.HashSet;
    import java.util.Set;
    public class HashTest01 &#123;
        //演示一下HsahSet集合特点
        public static void main(String[] args) &#123;
           Set&lt;String&gt; strs = new HashSet&lt;&gt;();
           strs.add(&quot;hello3&quot;);
           strs.add(&quot;hello4&quot;);
           strs.add(&quot;hello1&quot;);
           strs.add(&quot;hello2&quot;);
           strs.add(&quot;hello1&quot;);

           //遍历
           for(String s : strs)&#123;
              System.out.println(s);
           &#125;
           /*
           hello1
           hello4
           hello2
           hello3
           a）、存储时顺序和取出的顺序不同
           b）、不可重复。
           c）、放到HashSet集合中的元素实际上是放到HashMap集合的key部分了。
            */
        &#125;
    &#125;
</code></pre>
<h3 id="5）、TreeSet集合（一）"><a href="#5）、TreeSet集合（一）" class="headerlink" title="5）、TreeSet集合（一）"></a>5）、TreeSet集合（一）</h3><pre><code>无序不可重复，但是存储的元素可以自动按照大小顺序排序！称为可排序集合。
    无序：这里的无序指的是存进去的顺序和取出来的顺序不同，并且没有下标。
    import java.util.Set;
    import java.util.TreeSet;
    public class TreeSetTest01 &#123;
        public static void main(String[] args) &#123;
           //创建集合对象
           Set&lt;String&gt; strs = new TreeSet&lt;&gt;();
           strs.add(&quot;A&quot;);
           strs.add(&quot;B&quot;);
           strs.add(&quot;Z&quot;);
           strs.add(&quot;Y&quot;);
           strs.add(&quot;Z&quot;);
           strs.add(&quot;K&quot;);
           strs.add(&quot;M&quot;);

           //遍历
           for (String s : strs)&#123;
              System.out.println(s);
           &#125;
           /*
           A
           B
           K
           M
           Y
           Z
           从小到大自动排序
            */
        &#125;
    &#125;
    注：剩下的看完Map集合继续讲解
</code></pre>
<h3 id="6）、Map集合"><a href="#6）、Map集合" class="headerlink" title="6）、Map集合"></a>6）、Map集合</h3><h4 id="a）、Map和Collection没有继承关系"><a href="#a）、Map和Collection没有继承关系" class="headerlink" title="a）、Map和Collection没有继承关系"></a>a）、Map和Collection没有继承关系</h4><h4 id="b）、Map集合以key和value的方式存储数据：键值对"><a href="#b）、Map集合以key和value的方式存储数据：键值对" class="headerlink" title="b）、Map集合以key和value的方式存储数据：键值对"></a>b）、Map集合以key和value的方式存储数据：键值对</h4><pre><code>       key和value都是引用数据类型
       key和value都是存储对象的内存地址。
       key起到主导的地位，value是key的一个附属品。
</code></pre>
<h4 id="c）、Map接口中常用方法："><a href="#c）、Map接口中常用方法：" class="headerlink" title="c）、Map接口中常用方法："></a>c）、Map接口中常用方法：</h4><pre><code>       V    put(K key, V value)  向Map集合中添加键值对
       V get(Object key) 通过key获取value
       void clear()  清空Map集合
       boolean    containsKey(Object key)  判断Map集合中是否包含否个value
       boolean    containsValue(Object value)    判断Map中是否包含某个value
       boolean    isEmpty()  判断Map集合中元素个数是否为0

       V remove(Object key) 通过key删除键值对
       int    size()  获取Map集合中键值对的个数
       Collection&lt;V&gt;    values()  获取Map集合中所有的value，返回一个Collection

       Set&lt;K&gt;    keySet()  获取Map集合所有的key(所有的键是一个Set集合)
       Set&lt;Map.Entry&lt;K,V&gt;&gt;    entrySet()  将Map集合转换成Set集合
          假设现在有一个Map集合，如下所示：
             map1集合对象-
             key             value
             ---------------------

             1               zhangsan
             2               lisi
             3               wangwu
             4               zhaoliu

             Set set = map1.entrySet();
             Set集合对象
             1=zhangsan 【注意：Map集合通过entrySet()方法转换成的这个Set集合，
             set集合中元素的类型是Map.Entry&lt;K,V&gt;】
             2=lisi     【Map.Entry和String一样，都是一种类型的名字，只不过：
                                 Map.Entry是静态内部类，是Map中的静态内部类】
             3=wangwu
             4=zhaoliuimport java.util.Collection;

    import java.util.Collections;
    import java.util.HashMap;
    import java.util.Map;
    public class MapTest01 &#123;
        public static void main(String[] args) &#123;
           //创建Map集合对象
           Map&lt;Integer,String&gt; map = new HashMap();
           //向Map集合中添加键值对
           map.put(1,&quot;zhangsan&quot;); //1在这里自动装箱
           map.put(2,&quot;lisi&quot;);
           map.put(3,&quot;wangwu&quot;);
           map.put(4,&quot;zhaoliu&quot;);
           //通过key获取value
           String value = map.get(1);
           System.out.println(value);

           //获取键值对的数量
           System.out.println(&quot;键值对的数量是：&quot; + map.size()); //3

           //通过key删除key-value
           map.remove(2);
           System.out.println(map.size());

           //判断是否包含某个key
           //contains方法底层调用的都是equals方法进行比对，所以自定义的类型需要重写equals方法
           System.out.println(map.containsKey(3)); //true
           //判断是否包含某个value
           System.out.println(map.containsValue(&quot;lisi&quot;)); //false
           //获取所有的value
           Collection&lt;String&gt; c =map.values();
           for (String s : c)&#123;
              System.out.println(s);
           &#125;
           //清空Map集合
           map.clear();
           System.out.println(&quot;键值对的数量是：&quot; + map.size()); //0
           //判断是否为空
           System.out.println(map.isEmpty()); //true
        &#125;
    &#125;
</code></pre>
<h4 id="d）、静态内部类"><a href="#d）、静态内部类" class="headerlink" title="d）、静态内部类"></a>d）、静态内部类</h4><pre><code>    public class MyClass &#123;
        //声明一个静态内部类
        private static class InnerClass&#123;
           //静态方法
           public static void m1()&#123;
              System.out.println(&quot;静态内部类的m1方法执行&quot;);
           &#125;

           //实例方法
           public void m2()&#123;
              System.out.println(&quot;静态内部类中的实例方法m2执行&quot;);
           &#125;
        &#125;

        public static void main(String[] args) &#123;
           //类名叫做MyClass.InnerClass
           MyClass.InnerClass.m1();

           /*InnerClass ic = new InnerClass();
           ic.m2();*/
           //创建静态内部类对象
           MyClass.InnerClass mi = new MyClass.InnerClass();
           mi.m2();

           //给一个set集合
           //该set集合中存储的对象是：MyClass.InnerClass
           Set&lt;MyClass.InnerClass&gt; set = new HashSet&lt;&gt;();
        &#125;
    &#125;
</code></pre>
<h4 id="e）、Map集合的遍历【非常重要】"><a href="#e）、Map集合的遍历【非常重要】" class="headerlink" title="e）、Map集合的遍历【非常重要】"></a>e）、Map集合的遍历【非常重要】</h4><pre><code>    import java.util.HashMap;
    import java.util.Iterator;
    import java.util.Map;
    import java.util.Set;
    public class MapTest02 &#123;
        public static void main(String[] args) &#123;
           //第一种方式：获取所有的key，通过遍历key，来遍历value
           Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;();
           map.put(1,&quot;zhangsan&quot;);
           map.put(2,&quot;lisi&quot;);
           map.put(3,&quot;wangwu&quot;);
           map.put(4,&quot;zhaoliu&quot;);
           //遍历Map集合

           //先获取所有的key，所有的key是一个Set集合
           Set&lt;Integer&gt; keys = map.keySet();
           //遍历key，通过key获取value
           //迭代器可以
           Iterator&lt;Integer&gt; it = keys.iterator();
           while (it.hasNext())&#123;
              Integer key = it.next();
              System.out.println(map.get(key));
           &#125;
           //foreach也可以
           for (Integer key : keys)&#123;
              System.out.println(key + &quot;=&quot; + map.get(key));
           &#125;

           //第二种方式：Set&lt;Map.Entry&lt;K,V&gt;&gt;    entrySet()
           //以上这个方法是把Map集合直接全部转成Set集合。
           //Set集合中元素的类型是：Map.Entry
           Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entrySet();
           //遍历Set集合，每一次取出一个Node
           /*//迭代器
           Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it2 = set.iterator();
           while(it2.hasNext())&#123;
              Map.Entry&lt;Integer,String&gt; node = it2.next();
              Integer key = node.getKey();
              String value = node.getValue();
              System.out.println(key + &quot;=&quot; + value);
           &#125;*/

           //foreach
           //这种方式效率比较高，因为获取key和value都是直接从node对象中获取的属性值。
           //这种方式比较适合于大数据量
           for (Map.Entry&lt;Integer,String&gt; node : set)&#123;
              System.out.println(node.getKey() + &quot;---&gt;&quot; + node.getValue());
           &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="7）、HashMap集合"><a href="#7）、HashMap集合" class="headerlink" title="7）、HashMap集合"></a>7）、HashMap集合</h3><h4 id="a）、HashMap集合底层是哈希表-散列表的数据结构"><a href="#a）、HashMap集合底层是哈希表-散列表的数据结构" class="headerlink" title="a）、HashMap集合底层是哈希表/散列表的数据结构"></a>a）、HashMap集合底层是哈希表/散列表的数据结构</h4><h4 id="b）、哈希表是一个怎样的数据结构呢？"><a href="#b）、哈希表是一个怎样的数据结构呢？" class="headerlink" title="b）、哈希表是一个怎样的数据结构呢？"></a>b）、哈希表是一个怎样的数据结构呢？</h4><pre><code>        哈希表是一个数组和单向链表的结合体。
        数组：在查询方面效率很高，随机增删方面效率很低。
        单向链表：在随机增删方面效率较高，在查询方面效率较低。
        哈希表将以上的两种数据结构融合在一起，充分发挥它们各自的优点。
</code></pre>
<h4 id="c）、HashMap集合底层的源代码："><a href="#c）、HashMap集合底层的源代码：" class="headerlink" title="c）、HashMap集合底层的源代码："></a>c）、HashMap集合底层的源代码：</h4><pre><code>        public class HashMap&#123;
            //HashMap底层实际上就是一个数组。(一维数组)
            Node&lt;K,V&gt;[] table;
            //静态的内部类HashMap.Node
            static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;&#123;
                final int hash; //哈希值(哈希值是key的hashCode()方法的执行结果。
                //hash值可以通过哈希函数/算法，可以转换存储成数组的下标。)
                final K key; //存储到Map集合中的那个key
                V value;  //存储到Map集合中的那个value
                Node&lt;K,V&gt; next; //下一个节点的内存地址。
            &#125;
        &#125;
        哈希表/散列表：一维数组，这个一维数组中每一个元素是一个单向链表。（数组和链表的结合体。）
</code></pre>
<h4 id="d）、最主要掌握的是："><a href="#d）、最主要掌握的是：" class="headerlink" title="d）、最主要掌握的是："></a>d）、最主要掌握的是：</h4><pre><code>        map.put(k,v)
        v = map.get(k)
        以上两个方法的实现原理，是必须掌握的。
</code></pre>
<h4 id="e）、HashMap集合的key部分特点："><a href="#e）、HashMap集合的key部分特点：" class="headerlink" title="e）、HashMap集合的key部分特点："></a>e）、HashMap集合的key部分特点：</h4><pre><code>        无序，不可重复
        为什么无序？ 因为不一定挂到那个单向链表上。
        不可重复是怎么保证的？equals方法来保证HashMap集合的key不可重复。
        如果key重复了，value会覆盖。

        放在HashMap集合key部分的元素其实就是放到HashSet集合中了。
        所以HashSet集合中的元素也需要重写哈市Code()+equals()方法。
</code></pre>
<h4 id="f）、哈希表HashMap使用不当时无法发挥性能！"><a href="#f）、哈希表HashMap使用不当时无法发挥性能！" class="headerlink" title="f）、哈希表HashMap使用不当时无法发挥性能！"></a>f）、哈希表HashMap使用不当时无法发挥性能！</h4><pre><code>        假设将所有的hashCode()方法返回值固定为某个值，那么会导致底层哈希表变成了纯单向链表；
        这种情况我们称为：散列分布不均匀。

        什么是散列分布均匀呢？
            假设有100个元素，10个单向链表，那么每个单向链表上有10个节点，这是最好的，
                这是散列分布均匀的。
            假设将所有的hashCode()方法返回值都设定为不一样的值，可以吗？有什么问题？
                不行，因为这样的话就导致底层哈希表就成为一维数组了，没有链表的概念了。
                也是散列分布不均匀。
        散列分布均匀需要你重写hashCode()方法时有一定的技巧。
</code></pre>
<h4 id="g）、重点：放在HashMap集合key部分的元素，以及放在HashSet集合中的元素需要同时重写hashCode-和equals-方法。"><a href="#g）、重点：放在HashMap集合key部分的元素，以及放在HashSet集合中的元素需要同时重写hashCode-和equals-方法。" class="headerlink" title="g）、重点：放在HashMap集合key部分的元素，以及放在HashSet集合中的元素需要同时重写hashCode()和equals()方法。"></a>g）、重点：放在HashMap集合key部分的元素，以及放在HashSet集合中的元素需要同时重写hashCode()和equals()方法。</h4><h4 id="h）、HashMap集合的默认初始化容量时16，默认加载因子是0-75"><a href="#h）、HashMap集合的默认初始化容量时16，默认加载因子是0-75" class="headerlink" title="h）、HashMap集合的默认初始化容量时16，默认加载因子是0.75"></a>h）、HashMap集合的默认初始化容量时16，默认加载因子是0.75</h4><pre><code>        这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容。
        重点，记住：HashMap集合初始化容量必须是2的倍数，这也是官方推荐的，
        这是因为达到散列分布均匀，为了提高HashMap集合的存取效率，所必须的。
    public class HashMapTest01 &#123;
        public static void main(String[] args) &#123;
           //测试HashMap集合key部分的元素特点
           //Integer时key，它的hashCode()和equals都重写了
           Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;();
           map.put(1111,&quot;zhangsan&quot;);
           map.put(6666,&quot;lisi&quot;);
           map.put(7777,&quot;lwangwu&quot;);
           map.put(2222,&quot;zhaoliu&quot;);
           map.put(2222,&quot;king&quot;);
           System.out.println(map.size()); //4

           //遍历Map集合
           Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set = map.entrySet();
           for (Map.Entry&lt;Integer,String &gt; key : set)&#123;
              //验证结果：HashMap集合key部分元素：无序不可重复。
              System.out.println(key.getKey() + &quot;=&quot; + key.getValue());
           &#125;
        &#125;
    &#125;
</code></pre>
<h4 id="i）、向Map集合中存，以及从Map集合中取，都是先调用key的hashCode方法，然后再调用equals方法！"><a href="#i）、向Map集合中存，以及从Map集合中取，都是先调用key的hashCode方法，然后再调用equals方法！" class="headerlink" title="i）、向Map集合中存，以及从Map集合中取，都是先调用key的hashCode方法，然后再调用equals方法！"></a>i）、向Map集合中存，以及从Map集合中取，都是先调用key的hashCode方法，然后再调用equals方法！</h4><pre><code>equals方法有可能调用，也有可能不调用。
    拿put(k,v)举例，什么时候equals不会调用？
       k.hashCode()方法返回哈希值，
       哈希值经过哈希算法转换成数组下标，数组下标位置上如果是null，equals不需要执行。
    拿get(k)举例，什么时候equals不会调用？
       k.hashCode()方法返回哈希值，
       哈希值经过哈希算法转换成数组下标，数组下标位置上如果是null，equals不需要执行。
</code></pre>
<h4 id="j）、注意：如果一个类的equals-方法重写了，那么hashCode-方法必须重写；"><a href="#j）、注意：如果一个类的equals-方法重写了，那么hashCode-方法必须重写；" class="headerlink" title="j）、注意：如果一个类的equals()方法重写了，那么hashCode()方法必须重写；"></a>j）、注意：如果一个类的equals()方法重写了，那么hashCode()方法必须重写；</h4><pre><code>       并且equals方法返回的时true，hashCode()方法返回的值必须一样。

       equals方法返回true表示两个对象相同，他们的哈希值都是相共同的。
       所以hashCode()方法的返回值也应该相同。
</code></pre>
<h4 id="k）、hashCode-方法和equals-方法不用研究了，直接使用IDEA工具生成，但是这两个方法需要同时生成。"><a href="#k）、hashCode-方法和equals-方法不用研究了，直接使用IDEA工具生成，但是这两个方法需要同时生成。" class="headerlink" title="k）、hashCode()方法和equals()方法不用研究了，直接使用IDEA工具生成，但是这两个方法需要同时生成。"></a>k）、hashCode()方法和equals()方法不用研究了，直接使用IDEA工具生成，但是这两个方法需要同时生成。</h4><h4 id="l）、终极结论："><a href="#l）、终极结论：" class="headerlink" title="l）、终极结论："></a>l）、终极结论：</h4><pre><code>       放在HashMap集合key部分的，以及放在HashSet集合中的元素，
       需要同时重写hashCode()方法和equals()方法
</code></pre>
<h4 id="m）、在JDK8之后，如果哈希表单向链表中元素超过8个，单向链表这种数据结构会变成红黑树数据结构；"><a href="#m）、在JDK8之后，如果哈希表单向链表中元素超过8个，单向链表这种数据结构会变成红黑树数据结构；" class="headerlink" title="m）、在JDK8之后，如果哈希表单向链表中元素超过8个，单向链表这种数据结构会变成红黑树数据结构；"></a>m）、在JDK8之后，如果哈希表单向链表中元素超过8个，单向链表这种数据结构会变成红黑树数据结构；</h4><pre><code>    当红黑树上的节点小于6时，会重新把红黑树变成单向链表数据结构。
    这种方式也是为了提高检索效率，二叉树的检索会再次缩小扫描范围。
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
public class HashMapTest02 &#123;
    public static void main(String[] args) &#123;
       Student s1 = new Student(&quot;zhangsan&quot;);
       Student s2 = new Student(&quot;zhangsan&quot;);

       //重写equals方法之前是false
       //System.out.println(s1.equals(s2)); //false

       //重写equals方法之后是true
       System.out.println(s1.equals(s2)); //true(s1和s2表示相等 )

       System.out.println(&quot;s1的hashCode() = &quot; + s1.hashCode());
        //s1的hashCode() = 1067040082 重写hashCode之后：-1432604525
       System.out.println(&quot;s2的hashCode() = &quot; + s2.hashCode());
        //s2的hashCode() = 245257410 重写hashCode之后：-1432604525

       //s1.equals(s2)结果已经是true了，表示s1和s2是一样的，相同的，
       //那么往HashSet集合中放的话，按说只能放进去一个
       //因为HashSet特点是无序不可重复
       Set&lt;Student&gt; students = new HashSet&lt;&gt;();
       students.add(s1);
       students.add(s2);
       System.out.println(students.size());  //2 ；这个结果按说应该是1，但是结果是2，
       //显然不符合HashSet集合存储特点。
    &#125;
&#125;

class Student&#123;
    private String name;

    public Student() &#123;
    &#125;

    public Student(String name) &#123;
       this.name = name;
    &#125;

    public String getName() &#123;
       return name;
    &#125;

    public void setName(String name) &#123;
       this.name = name;
    &#125;

    /*//equals(如果学生名字一样，表示同一个学生)
    public boolean equals(Object o) &#123;
       if (this == o) return true;
       if (null == o || !(o instanceof Student)) return false;
       Student student = (Student)o;
       return name.equals(student.name);
    &#125;*/

    @Override
    public boolean equals(Object o) &#123;
       if (this == o) return true;
       if (o == null || getClass() != o.getClass()) return false;
       Student student = (Student) o;
       return Objects.equals(name, student.name);
    &#125;

    @Override
    public int hashCode() &#123;
       return Objects.hash(name);
    &#125;
&#125;
</code></pre>
<h4 id="n）、HashMap集合key部分可以允许null吗？"><a href="#n）、HashMap集合key部分可以允许null吗？" class="headerlink" title="n）、HashMap集合key部分可以允许null吗？"></a>n）、HashMap集合key部分可以允许null吗？</h4><pre><code>        允许；但是要注意：HashMap集合的key null值只能有一个。
import java.util.HashMap;
import java.util.Map;
public class HashMapTest03 &#123;
    public static void main(String[] args) &#123;
       Map map = new HashMap&lt;&gt;();
       //HashMap集合允许key为null
       map.put(null,null);
       System.out.println(map.size()); //1

       //key重复的话，value覆盖
       map.put(null,100);
       System.out.println(map.size()); //1

       //通过key获取value
       System.out.println(map.get(null)); //100
    &#125;
&#125;
</code></pre>
<h4 id="o）、Hashtable的key可以为null吗？"><a href="#o）、Hashtable的key可以为null吗？" class="headerlink" title="o）、Hashtable的key可以为null吗？"></a>o）、Hashtable的key可以为null吗？</h4><pre><code>        Hashtable的key和value都是不能为null的。
        HasgMap集合的key和value都是可以为null的。

        Hashtable方法都带有synchronized：线程安全的
        线程安全有其他的方案，这个Hashtable对线程的处理导致效率较低，使用较少了。

        Hashtable和HashMap一样底层都是哈希表数据结构。
        Hashtable的初始化容量是11，默认加载因子是0.75
        Hashtable的扩容是：原容量*2+1
import java.util.Hashtable;
import java.util.Map;
public class HashtableTest01 &#123;
    public static void main(String[] args) &#123;
       Map map = new Hashtable();
       //map.put(null,&quot;123&quot;);
       //运行出现空指针异常：java.lang.NullPointerException
       map.put(100,null); //运行也出现空指针异常：java.lang.NullPointerException
    &#125;
&#125;
</code></pre>
<h4 id="p）、Properties属性类"><a href="#p）、Properties属性类" class="headerlink" title="p）、Properties属性类"></a>p）、Properties属性类</h4><pre><code>        目前只需要掌握Properties属性类对像的相关方法即可。
         Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型的
         Properties被称为属性类对象.
         Properties是线程安全的。
import java.util.Properties;
public class PropertiesTest01 &#123;
    public static void main(String[] args) &#123;
       //创建一个Properties对象
       Properties pro = new Properties();
       //需要掌握Properties的两个方法，一个存，一个取。
       pro.setProperty(&quot;url&quot;,&quot;jdbc.mysq1://khjasdfakhjak:1622/bajdihajh&quot;);
       pro.setProperty(&quot;dirver&quot;,&quot;com.mysql.jdbc.Dirver&quot;);
       pro.setProperty(&quot;username&quot;,&quot;root&quot;);
       pro.setProperty(&quot;password&quot;,&quot;123&quot;);

       //通过key获取value
       String url = pro.getProperty(&quot;url&quot;);
       String dirver = pro.getProperty(&quot;dirver&quot;);
       String username = pro.getProperty(&quot;username&quot;);
       String password = pro.getProperty(&quot;password&quot;);

       System.out.println(url);
       System.out.println(dirver);
       System.out.println(username);
       System.out.println(password);
    &#125;
&#125;
</code></pre>
<h3 id="8）、TreeSet集合（二）"><a href="#8）、TreeSet集合（二）" class="headerlink" title="8）、TreeSet集合（二）"></a>8）、TreeSet集合（二）</h3><h4 id="a）、TreeSet集合底层实际上是一个TreeMap"><a href="#a）、TreeSet集合底层实际上是一个TreeMap" class="headerlink" title="a）、TreeSet集合底层实际上是一个TreeMap"></a>a）、TreeSet集合底层实际上是一个TreeMap</h4><h4 id="b）、TreeMap集合底层是一个二叉树"><a href="#b）、TreeMap集合底层是一个二叉树" class="headerlink" title="b）、TreeMap集合底层是一个二叉树"></a>b）、TreeMap集合底层是一个二叉树</h4><h4 id="c）、放到TreeSet集合中的元素，等同于放到TreeMap集合key部分。"><a href="#c）、放到TreeSet集合中的元素，等同于放到TreeMap集合key部分。" class="headerlink" title="c）、放到TreeSet集合中的元素，等同于放到TreeMap集合key部分。"></a>c）、放到TreeSet集合中的元素，等同于放到TreeMap集合key部分。</h4><h4 id="d）、TreeSet集合中的元素：无序不可重复，但是可以按照元素的大小顺序自动排序。称为可排序集合。"><a href="#d）、TreeSet集合中的元素：无序不可重复，但是可以按照元素的大小顺序自动排序。称为可排序集合。" class="headerlink" title="d）、TreeSet集合中的元素：无序不可重复，但是可以按照元素的大小顺序自动排序。称为可排序集合。"></a>d）、TreeSet集合中的元素：无序不可重复，但是可以按照元素的大小顺序自动排序。称为可排序集合。</h4><pre><code>    import java.util.TreeSet;
    public class TreeSetTest01 &#123;
        public static void main(String[] args) &#123;
           //创建一个treeSet集合
           TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;();
           //添加String
           ts.add(&quot;zhangsan&quot;);
           ts.add(&quot;lisi&quot;);
           ts.add(&quot;wangwu&quot;);
           ts.add(&quot;zhangsi&quot;);
           ts.add(&quot;wangliu&quot;);
           //遍历
           for (String s : ts)&#123;
              //按照字典顺序，升序！
              System.out.println(s);
           &#125;
           /*
           lisi
           wangliu
           wangwu
           zhangsan
           zhangsi
           */

           TreeSet&lt;Integer&gt; ts2 = new TreeSet&lt;&gt;();
           ts2.add(1);
           ts2.add(3);
           ts2.add(8);
           ts2.add(2);
           ts2.add(7);
           //遍历
           for (Integer i : ts2)&#123;
              System.out.println(i); //1 2 3 7 8 升序
           &#125;
        &#125;
    &#125;
</code></pre>
<h4 id="e）、对自定义的类型来说，TreeSet可以排序吗？"><a href="#e）、对自定义的类型来说，TreeSet可以排序吗？" class="headerlink" title="e）、对自定义的类型来说，TreeSet可以排序吗？"></a>e）、对自定义的类型来说，TreeSet可以排序吗？</h4><pre><code>        以下程序中，对于Person类型来说，无法排序，因为没有指定Person对象之间的比较规则。
        谁大谁小并没有说明。

        以下程序运行的时候出现了这个异常：
           java.lang.ClassCastException:
              class Person cannot be cast to class java.lang.Comparable
           出现这个异常的原因是：Person类没有实现java.lang.Comparable接口。
    import java.util.TreeSet;
    public class TreeSetTest02 &#123;
        public static void main(String[] args) &#123;
              Person p1 = new Person(32);
              Person p2 = new Person(20);
              Person p3 = new Person(30);
              Person p4 = new Person(25);

              //创建TreeSet集合
              TreeSet&lt;Person&gt; ts = new TreeSet&lt;&gt;();
              //添加元素
              ts.add(p1);
              ts.add(p2);
              ts.add(p3);
              ts.add(p4);
              for (Person p : ts)&#123;
                 System.out.println(p);
              &#125;
        &#125;
    &#125;

    class Person&#123;
        int age;
        public Person(int age)&#123;
           this.age =age;
        &#125;

        //重写toString()方法
        public String toString()&#123;
           return &quot;Person[age = &quot; + age + &quot;]&quot;;
        &#125;
    &#125;

    import java.util.TreeSet;
    public class TreeSetTest03 &#123;
        public static void main(String[] args) &#123;
           Customer c1 = new Customer(32);
           Customer c2 = new Customer(20);
           Customer c3 = new Customer(30);
           Customer c4 = new Customer(25);

           //创建TreeSet集合
           TreeSet&lt;Customer&gt; customers = new TreeSet&lt;&gt;();
           //添加元素
           customers.add(c1);
           customers.add(c2);
           customers.add(c3);
           customers.add(c4);
           for (Customer c : customers)&#123;
              System.out.println(c);
           &#125;
           /*
           Customer[age = 20]
           Customer[age = 25]
           Customer[age = 30]
           Customer[age = 32]
           */
        &#125;
    &#125;
    //放在TreeSet集合中的元素需要实现java.lang.Comparable接口。
    //ing且实现compareTo方法，equals可以不写。
    class Customer implements Comparable&lt;Customer&gt;&#123;
        int age;
        public Customer(int age)&#123;
           this.age = age;
        &#125;

        //需要在这个方法中编写比较的逻辑，或者说比较的规则，按照什么进行比较！
        //k.compareTo(t.key)
        //拿着参数k和集合中每一个k进行比较，返回值可能是&gt;0 &lt;0 =0
        //比较规则最终还是由程序员指定的；例如按照年龄升序，或者按照年龄降序
        public int compareTo(Customer c) &#123;
           //c1.compareTo(c2)
           //this是c1
           //c就是c2
           //c1和c2比较的时候，就是this和c比较。
           /*int age1 = this.age;
           int age2 = c.age;
           if (age1 ==age2) return 0;
           else if (age1 &gt; age2) return 1;
           else return -1;*/
           return this.age - c.age; //&gt;0 &lt;0 =0(升序)
           //return c.age - this.age; //降序
        &#125;
        //重写toString
        public String toString()&#123;
           return &quot;Customer[age = &quot; + age + &quot;]&quot;;
        &#125;
    &#125;
</code></pre>
<h4 id="h）、先按照年龄升序，如果年龄一样的再按照姓名升序。"><a href="#h）、先按照年龄升序，如果年龄一样的再按照姓名升序。" class="headerlink" title="h）、先按照年龄升序，如果年龄一样的再按照姓名升序。"></a>h）、先按照年龄升序，如果年龄一样的再按照姓名升序。</h4><pre><code>    public class TreeSetTest04 &#123;
        public static void main(String[] args) &#123;
           TreeSet&lt;Vip&gt; vips = new TreeSet&lt;&gt;();
           vips.add(new Vip(&quot;zhangsan&quot;,20));
           vips.add(new Vip(&quot;zhangsi&quot;,20));
           vips.add(new Vip(&quot;king&quot;,18));
           vips.add(new Vip(&quot;soft&quot;,17));

           //遍历
           for (Vip v : vips)&#123;
              System.out.println(v);
           &#125;
           /*Vip&#123;name=&#39;soft&#39;, age=17&#125;
           Vip&#123;name=&#39;king&#39;, age=18&#125;
           Vip&#123;name=&#39;zhangsan&#39;, age=20&#125;
           Vip&#123;name=&#39;zhangsi&#39;, age=20&#125;*/
        &#125;
    &#125;

    class Vip implements Comparable&lt;Vip&gt;&#123;
        String name;
        int age;

        public Vip(String name, int age) &#123;
           this.name = name;
           this.age = age;
        &#125;

        /*
        compareTo()方法很重要：
           返回0表示相同，value会覆盖
           返回 &gt;0，会继续在右子树上找【10-9=1，1 &gt;0，说明左边这个数字比较大，所以在右子树上找】
           返回 &lt;0，会继续在左子树上找

        */
        //重写compareTo()方法
        public int compareTo(Vip o) &#123;
           //写排序规则按照什么进行比较。
           if (this.age != o.age) return this.age - o.age;
           else return this.name.compareTo(o.name);
           //姓名是String类型，可以直接比，调用compareTo来完成比较。
        &#125;

        //重写toString()方法
        public String  toString() &#123;
           return &quot;Vip&#123;&quot; +
                 &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                 &quot;, age=&quot; + age +
                 &#39;&#125;&#39;;
        &#125;
    &#125;
</code></pre>
<h4 id="i）、TreeSet集合中元素可排序的第二种方式：使用比较器的方式。"><a href="#i）、TreeSet集合中元素可排序的第二种方式：使用比较器的方式。" class="headerlink" title="i）、TreeSet集合中元素可排序的第二种方式：使用比较器的方式。"></a>i）、TreeSet集合中元素可排序的第二种方式：使用比较器的方式。</h4><pre><code>    最终的结论：
        放到TreeSet或者TreeMap集合key部分的元素要想做到排序，包括两种方式：
            第一种：放在集合中的元素实现java.lang.Comparable接口。
            第二种：在构造TreeSet或者TreeMap集合的时候给他传一个比较器对象。
    Comparable和Comparator怎么选择呢？
           当比较规则不会发生改变的时候，或者说当比较规则只有1个的时候，建议实现Comparable接口。
           当比较规则有多个，并且需要多个比较规则之间频繁切换建议使用Comparator接口。

           Comparator接口的设计符合OCP原则。
    import java.util.Comparator;
    import java.util.TreeSet;
    public class TreeSetTest06 &#123;
        public static void main(String[] args) &#123;
           //创建TreeSet集合的时候，需要使用这个比较器。
           //TreeSet&lt;WuGui&gt; WuGuis = new TreeSet&lt;&gt;(); //这样不行，没有通过构造方法传递一个比较器进去
           //给构造方法传递一个比较器。
           //TreeSet&lt;WuGui&gt; WuGuis = new TreeSet&lt;&gt;(new WuGuiComparator());

           //大家可以使用匿名内部类的方式(这个类没有名字，直接new接口)
           TreeSet&lt;WuGui&gt; WuGuis = new TreeSet&lt;&gt;(new Comparator&lt;WuGui&gt;() &#123;
              @Override
              public int compare(WuGui o1, WuGui o2) &#123;
                 return o1.age - o2.age;
              &#125;
           &#125;);
           WuGuis.add(new WuGui(1000));
           WuGuis.add(new WuGui(800));
           WuGuis.add(new WuGui(810));
           for (WuGui w : WuGuis)&#123;
              System.out.println(w);
           &#125;
           /*小乌龟[age =800]
           小乌龟[age =810]
           小乌龟[age =1000]*/
        &#125;
    &#125;
    class WuGui&#123;
        int age;
        public WuGui(int age)&#123;
           this.age = age;
        &#125;

        public String toString()&#123;
           return &quot;小乌龟[&quot; + &quot;age =&quot; + age + &quot;]&quot;;
        &#125;
    &#125;

    /*
    //单独在这里编写一个比较器
    //比较器实现java.util.Comparator接口。
    //(Comparable是java.lang包下的；Comparator是java.util包下的。)
    class WuGuiComparator implements Comparator&lt;WuGui&gt;&#123;
        public int compare(WuGui o1, WuGui o2) &#123;
           //指定比较规则
           //按照年龄排序
           return o1.age - o2.age;
        &#125;
    &#125;
    */
</code></pre>
<h1 id="九、泛型"><a href="#九、泛型" class="headerlink" title="九、泛型"></a>九、泛型</h1><h2 id="1、JDK5-0之后推出的新特性：泛型。泛型这种语法机制，旨在程序编译阶段起作用，只是给编译器参考的。-运行阶段泛型没用！"><a href="#1、JDK5-0之后推出的新特性：泛型。泛型这种语法机制，旨在程序编译阶段起作用，只是给编译器参考的。-运行阶段泛型没用！" class="headerlink" title="1、JDK5.0之后推出的新特性：泛型。泛型这种语法机制，旨在程序编译阶段起作用，只是给编译器参考的。(运行阶段泛型没用！)"></a>1、JDK5.0之后推出的新特性：泛型。泛型这种语法机制，旨在程序编译阶段起作用，只是给编译器参考的。(运行阶段泛型没用！)</h2><h2 id="2、使用了泛型好处是什么？"><a href="#2、使用了泛型好处是什么？" class="headerlink" title="2、使用了泛型好处是什么？"></a>2、使用了泛型好处是什么？</h2><pre><code>        第一：集合中存储的元素类型统一了
        第二:从集合中取出的类型是泛型指定的类型，不需要进行大量的“向下转型”！
</code></pre>
<h2 id="3、泛型的缺点："><a href="#3、泛型的缺点：" class="headerlink" title="3、泛型的缺点："></a>3、泛型的缺点：</h2><pre><code>        导致集合中存储的元素缺乏多样性。
        大多数业务中，集合中元素的类型还是统一的，所以这种泛型特性被大家认可。
    import java.util.ArrayList;
    import java.util.Iterator;
    import java.util.List;
    public class GenericTest01 &#123;
        public static void main(String[] args) &#123;
           /*
           //不使用泛型，分析程序存在的缺点
           List myList = new ArrayList();
           //准备对象
           Cat c = new Cat();
           Bird b = new Bird();
           //将对象添加到集合当中去
           myList.add(c);
           myList.add(b);

           //遍历集合，取出cat让它抓老鼠，取出bird让它飞
           Iterator it = myList.iterator();
           while(it.hasNext())&#123;
              Object obj = it.next();
              //obj中没有move方法，无法调用，需要向下转型
              if (obj instanceof Animal)&#123;
                 ((Animal)obj).move();
              &#125;else if (obj instanceof Cat)&#123;
                 ((Cat) obj).catchMouse();
              &#125;else &#123;
                 ((Bird) obj).fly();
              &#125;
           &#125;
           */
           //使用JDK5之后的泛型机制
           //s使用泛型List&lt;Animal&gt;之后，表示List集合中只允许存储Animal类型的数据。
           //用泛型来指定集合中村粗的数据类型。
           List&lt;Animal&gt; myList = new ArrayList&lt;Animal&gt;();
           //指定List集合中只能存储Animal，那么存储String就编译报错了。
           //这样用了泛型之后，集合中元素的数据类型更加统一了。
           //myList.add(&quot;abc&quot;); //报错
           myList.add(new Cat());
           Bird b = new Bird();
           myList.add(b);

           //获取迭代器
           //这个表示迭代器迭代的是Animal类型
           Iterator&lt;Animal&gt; it = myList.iterator();
           while (it.hasNext())&#123;
              //使用泛型之后，每一次迭代返回的数据都是Animal类型
              Animal a = it.next();
              //这里不需要进行强制类型转换了，直接调用。
              //a.move();
              //调用子类特有的方法还是需要向下转型的
              if (a instanceof Cat)&#123;
                 ((Cat)a).catchMouse();
              &#125;else&#123;
                 ((Bird)a).fly();
              &#125;
           &#125;
        &#125;
    &#125;

    class Animal&#123;
        public void move()&#123;
           System.out.println(&quot;动物在移动&quot;);
        &#125;
    &#125;

    class Cat extends Animal&#123;
        public void catchMouse()&#123;
           System.out.println(&quot;猫抓老鼠&quot;);
        &#125;
    &#125;

    class Bird extends Animal&#123;
        public void fly()&#123;
           System.out.println(&quot;鸟儿在飞翔&quot;);
        &#125;
    &#125;
</code></pre>
<h2 id="4、JDK8之后引入了：自动类型推断机制。-又称为钻石表达式"><a href="#4、JDK8之后引入了：自动类型推断机制。-又称为钻石表达式" class="headerlink" title="4、JDK8之后引入了：自动类型推断机制。(又称为钻石表达式)"></a>4、JDK8之后引入了：自动类型推断机制。(又称为钻石表达式)</h2><pre><code>    import java.util.ArrayList;
    import java.util.Iterator;
    import java.util.List;
    public class GenericTest02 &#123;
        public static void main(String[] args) &#123;
           //ArrayList&lt;这里的类型会自动推断&gt;()，前提是JDK8之后才允许。
           //自动类型推断
           List&lt;Animal&gt; myList = new ArrayList&lt;&gt;();
           myList.add(new Animal());
           myList.add(new Cat());
           myList.add(new Bird());

           //遍历
           /*
           for (int i =0; i &lt; myList.size();i++)&#123;
              Animal a = myList.get(i);
              if (a instanceof Cat)&#123;
                 ((Cat)a).catchMouse();
              &#125;else if (a instanceof Bird)&#123;
                 ((Bird)a).fly();
              &#125;else&#123;
                 a.move();
              &#125;
           &#125;
           */
           Iterator&lt;Animal&gt; it =myList.iterator();
           while (it.hasNext())&#123;
              Animal a = it.next();
              if (a instanceof Cat)&#123;
                 ((Cat)a).catchMouse();
              &#125;else if (a instanceof Bird)&#123;
                 ((Bird)a).fly();
              &#125;else&#123;
                 a.move();
              &#125;
           &#125;
        &#125;
    &#125;
</code></pre>
<h2 id="5、自定义泛型"><a href="#5、自定义泛型" class="headerlink" title="5、自定义泛型:"></a>5、自定义泛型:</h2><pre><code>        自定义泛型的时候，&lt;&gt;加括号中的是一个标识符，随便写。
        java源代码中经常出现的是：
           &lt;E&gt;和&lt;T&gt;
           E是element单词首字母
           T是Type单词首字母
    public class GenericTest03&lt;标识符随便写&gt; &#123;
        public void doSome(标识符随便写 o)&#123;
           System.out.println(o);
        &#125;

        public static void main(String[] args) &#123;
           //new对象的时候指定了泛型是String类型
           //不用泛型就是Object类型
           GenericTest03&lt;String&gt; gt = new GenericTest03&lt;&gt;();
           //类型不匹配
           //gt.doSome(100);
           gt.doSome(&quot;abc&quot;);

           GenericTest03&lt;Integer&gt; gt2 = new GenericTest03&lt;&gt;();
           gt2.doSome(100);
           //类型不匹配
           //gt.doSome(&quot;abc&quot;);
        &#125;
    &#125;
</code></pre>
<h2 id="6、集合使用foreach"><a href="#6、集合使用foreach" class="headerlink" title="6、集合使用foreach"></a>6、集合使用foreach</h2><pre><code>    import java.util.ArrayList;
    import java.util.Iterator;
    import java.util.List;
    public class ForEachTest02 &#123;
        public static void main(String[] args) &#123;
           //创建List集合
           List&lt;String&gt; strList = new ArrayList&lt;&gt;();
           //添加元素
           strList.add(&quot;hello&quot;);
           strList.add(&quot;world&quot;);
           strList.add(&quot;kitty&quot;);
           //遍历，使用迭代器方式
           Iterator&lt;String&gt; it = strList.iterator();
           while (it.hasNext())&#123;
              System.out.println(it.next());
           &#125;

           //使用下标的方式(只针对于有下标的集合)
           for (int i = 0;i &lt;strList.size();i++)&#123;
              System.out.println(strList.get(i));
           &#125;
           //使用foreach
           for (String data : strList)&#123;
              System.out.println(data);
           &#125;
        &#125;
    &#125;
</code></pre>
<h1 id="十、IO"><a href="#十、IO" class="headerlink" title="十、IO"></a>十、IO</h1><h2 id="1、IO流，什么是IO？"><a href="#1、IO流，什么是IO？" class="headerlink" title="1、IO流，什么是IO？"></a>1、IO流，什么是IO？</h2><pre><code>I：Input
O：Output
通过IO可以完成硬盘文件的读和写
</code></pre>
<h2 id="2、IO流的分类？"><a href="#2、IO流的分类？" class="headerlink" title="2、IO流的分类？"></a>2、IO流的分类？</h2><pre><code>有多种分类方式：
    一种方式是按照流的方向进行分类：
        以内存作为参照物；
            往内存中去，叫做输入（Input），或者叫做读（Read）。
            从内存中出来，叫做输出（Output），或者叫做写（Write）。
    另一种方式是按照读取数据方式不同进行分类：
        有的流是按照字节的方式读取数据，一次读取1个字节byte，等同于一次读取8个二进制位（bit）
        这种流是万能的，什么类型的文件都可以读取；包括：文本文件、图片、声音文件、视频文件....
            假设文件file1.txt，采用字符流的话这样读的：
                a中国bc张三fe
                第一次读：一个字节，正好读到&#39;a&#39;
                第二次读：一个字节，正好读到&#39;中&#39;字符的一半
                第三次读：一个字节，正好读到&#39;中&#39;字符的另外一半

        有的流是按照字符的方式读取数据的，一次读取一个字符，这种流是为了方便读取普通文本文件而存在的；
        这种流不能读取：图片、声音、视频等文件，只能读取纯文本文件，连Word文件都无法读取。
            假设文件file1.txt，采用字符流的话这样读的：
                a中国bc张三fe
                第一次读：&#39;a&#39;字符（&#39;a&#39;字符在windows系统中占用1个字节）
                第二次读：&#39;中&#39;字符（&#39;中&#39;字符在windows系统中占用2个字节）
综上所述：流的分类
    输入流、输出流
    字节流、字符流
</code></pre>
<h2 id="3、java中的IO流都已经写好了，我们程序员不需要关心，我们最主要还是掌握，在java中以及提供3-了哪些流，每个流的特点是什么，"><a href="#3、java中的IO流都已经写好了，我们程序员不需要关心，我们最主要还是掌握，在java中以及提供3-了哪些流，每个流的特点是什么，" class="headerlink" title="3、java中的IO流都已经写好了，我们程序员不需要关心，我们最主要还是掌握，在java中以及提供3 了哪些流，每个流的特点是什么，"></a>3、java中的IO流都已经写好了，我们程序员不需要关心，我们最主要还是掌握，在java中以及提供3 了哪些流，每个流的特点是什么，</h2><p>   每个流对象上的常用方法有哪些？？？？<br>    java中所有的流都在：java.io.*；下。</p>
<pre><code>java中主要还是研究：
    怎么new流对象
    调用流对象的那个方法是读，那个方法是写。
</code></pre>
<h2 id="4、java-IO流这块有四大家族："><a href="#4、java-IO流这块有四大家族：" class="headerlink" title="4、java IO流这块有四大家族："></a>4、java IO流这块有四大家族：</h2><pre><code>java.io.InputStream 字节输入流
java.io.OutputStream 字节输出流
java.io.Reader 字符输入流
java.io.Writer 字符输出流

四个都是抽象类（abstract class）
所有的流都实现了：java.io.Closeable接口，都是可关闭的，都有close()方法。
    流毕竟是一个管道，这个是内存和硬盘之间的通道，用完之后一定要关闭，不然会耗费很多资源。
    养成好习惯，用完流一定要关闭。

所有的输出流都实现了：
    java.io.Flushable接口，都是可刷新的，都有flush()方法。
    养成一个好习惯，输出流在最终输出之后，一定要记得flush()刷新一下；
    这个刷新表示将通道/管道当中剩余为输出的数据强行输出完(清空管道！)刷新的作用就是清空管道。
    注意：如果没有flush()可能导致丢失数据。

注意：在java中只要“类名”以Stream结尾的都是字节流；以“Reader/Writer”结尾的都是字符流。
</code></pre>
<h2 id="5、java-io包下需要掌握的流有16个："><a href="#5、java-io包下需要掌握的流有16个：" class="headerlink" title="5、java.io包下需要掌握的流有16个："></a>5、java.io包下需要掌握的流有16个：</h2><pre><code>文件专属：
    java.io.FileInputStream （掌握）
    java.io.fileOutputStream（掌握）
    java.io.Reader
    java.io.Writer

转换流：（将字节流转换成字符流）
    java.io.InputStreamReader
    java.io.OutputStreamWriter

缓冲流专属：
    java.io.BufferedInputStream
    java.io.BufferedOutputStream
    java.io.BufferedReader
    java.io.BufferedWriter

数据流专属：
    java.io.DataInputStream
    java.io.DataOutputStream

标准数据流：
    java.io.PrintWriter（掌握）
    java.io.PrintReader

对象专属流：
    java.io.ObjectInputStream（掌握）
    java.io.ObjectOutputStream（掌握）
</code></pre>
<h2 id="6、java-io-FileInputStream"><a href="#6、java-io-FileInputStream" class="headerlink" title="6、java.io.FileInputStream"></a>6、java.io.FileInputStream</h2><h3 id="1）、文件字节输入流，万能的，任何类型的文件都可以采用这个流来读。"><a href="#1）、文件字节输入流，万能的，任何类型的文件都可以采用这个流来读。" class="headerlink" title="1）、文件字节输入流，万能的，任何类型的文件都可以采用这个流来读。"></a>1）、文件字节输入流，万能的，任何类型的文件都可以采用这个流来读。</h3><h3 id="2）、字节的方式，完成输入的操作，完成读的操作（硬盘–-gt-内存）"><a href="#2）、字节的方式，完成输入的操作，完成读的操作（硬盘–-gt-内存）" class="headerlink" title="2）、字节的方式，完成输入的操作，完成读的操作（硬盘–&gt;内存）"></a>2）、字节的方式，完成输入的操作，完成读的操作（硬盘–&gt;内存）</h3><pre><code>    import java.io.FileInputStream;
    import java.io.FileNotFoundException;
    import java.io.IOException;
    public class FileInputStreamTest01 &#123;
        public static void main(String[] args) &#123;
           //放到外面才能在finally里面调用close()
           FileInputStream fis = null;
           try&#123;
              //创建文件字节输入流对象
              //文件路劲：F:\ideaIUproject (IDEA会自动变成双斜杠，因为单斜杠是转义符)
              //以下都是采用了绝对路径
              //FileInputStream fis = new FileInputStream(&quot;F:\\ideaIUproject\\temp&quot;);
              //写成/也是可以的
              fis = new FileInputStream(&quot;F:/ideaIUproject/temp&quot;);

              //开始时，指针指向文件中字符的前一个位置，调用一次read方法，指针往后移一位
              int readData = fis.read(); //这个方法的返回值是：读取到的“字节”本身。
              System.out.println(readData); //97;a对应97

              readData = fis.read();
              System.out.println(readData); //98;b对应98

              readData = fis.read();
              System.out.println(readData); //99

              readData = fis.read();
              System.out.println(readData); //100

              readData = fis.read();
              System.out.println(readData);//101

              readData = fis.read();
              System.out.println(readData);//102

              readData = fis.read();
              System.out.println(readData); //-1;
              //已经读到文件末尾了，再读的时候，读不到任何数据就返回-1

           &#125;catch (FileNotFoundException e)&#123;
              e.printStackTrace();
           &#125; catch (IOException e) &#123;
           //或者也可以把FileNotFoundException异常替换成IOException异常，因为后者包含了前者
              e.printStackTrace();
           &#125; finally &#123;
              //避免空指针异常
              //在finally语句快当中确保流一定关闭：关闭流的前提“流不是空”。
              if (fis != null)&#123;
                 try &#123;
                    fis.close();
                 &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                 &#125;
              &#125;

           &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="3）、FileInputStream循环读"><a href="#3）、FileInputStream循环读" class="headerlink" title="3）、FileInputStream循环读"></a>3）、FileInputStream循环读</h3><pre><code>    分析这个程序的缺点:
        一次读取一个字节byte，这样内存和硬盘交互太频繁，基本上资源都耗费在交互上面了
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
public class FileInputStreamTest02 &#123;
    public static void main(String[] args) &#123;
       FileInputStream fis = null;
       try &#123;
          fis = new FileInputStream(&quot;F:/ideaIUproject/temp&quot;);
           /*
           不可以这样写，因为在fis.read() != -1的时候调用了一次read，
           执行输出的时候又调用了一次read；
           第一次的read没有输出
            while (fis.read() != -1)&#123;
              System.out.println(fis.read());
           &#125;
            */
           /*while (true)&#123;
              int readData = fis.read();
              if (readData == -1) break;
              System.out.println(readData);
           &#125;*/
          //改造
          int readData2 = 0;
          while ((readData2 = fis.read()) != -1)&#123;
             System.out.println(readData2);
          &#125;

       &#125; catch (FileNotFoundException e) &#123;
          e.printStackTrace();
       &#125; catch (IOException e) &#123;
          e.printStackTrace();
       &#125; finally &#123;
          if (fis != null)&#123;
             try &#123;
                fis.close();
             &#125; catch (IOException e) &#123;
                e.printStackTrace();
             &#125;
          &#125;
       &#125;
    &#125;
&#125;
</code></pre>
<h3 id="4）、int-read-byte-b"><a href="#4）、int-read-byte-b" class="headerlink" title="4）、int read(byte[] b)"></a>4）、int read(byte[] b)</h3><pre><code>    一次最多读取b.length个字节
    减少硬盘和内存的交互，提高程序的执行效率。
    往byte[]数组当中读。
    import java.io.FileInputStream;
    import java.io.FileNotFoundException;
    import java.io.IOException;
    public class FileInputStreamTest03 &#123;
        public static void main(String[] args) &#123;
           FileInputStream fis = null;
           try &#123;
              //相对路径一定是从当前所在的位置作为起点开始找
              //IDEA默认的当前路径是哪里？工程project的根就是IDEA的默认当前路径
              fis = new FileInputStream(&quot;src/src/tempFile2&quot;);

              //开始读，采用byte数组，一次读取多个字节。最多读取数组.length个字节
              byte[] bytes = new byte[4]; //准备一个4个长度的byte数组，一次最多读取4个字节。
              //这个方法的返回值是：独到的字节数，不是字节本身。
              int readCount = fis.read(bytes);
              System.out.println(readCount); //4;第一次读到了4个字节。
              System.out.println(new String(bytes)); //abcd
              //String String(byte[] b)将byte数组转换为字符串

              readCount = fis.read(bytes);
              System.out.println(readCount); //2
              //System.out.println(new String(bytes)); //efcd；读只剩ef，ef换掉了ab，但是cd还在
              //不应该全部都转，应该读到多少个字节转多少个
              System.out.println(new String(bytes,0,readCount)); //ef

              readCount = fis.read(bytes);//一个字节都没有读到，返回-1
              System.out.println(readCount); //-1
           &#125; catch (FileNotFoundException e) &#123;
              e.printStackTrace();
           &#125; catch (IOException e) &#123;
              e.printStackTrace();
           &#125; finally &#123;
              if (fis != null) &#123;
                 try &#123;
                    fis.close();
                 &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                 &#125;
              &#125;
           &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="5）、最终版"><a href="#5）、最终版" class="headerlink" title="5）、最终版"></a>5）、最终版</h3><pre><code>import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
public class FileInputStreamTest04 &#123;
    public static void main(String[] args) &#123;
       FileInputStream fis = null;
       try &#123;
          fis = new FileInputStream(&quot;src/src/tempfile2&quot;);
          byte[] bytes = new byte[4];
          int readCount = 0;
          while((readCount = fis.read(bytes)) != -1)&#123;
             System.out.println(new String(bytes,0,readCount));
          &#125;
       &#125;catch(FileNotFoundException e)&#123;
          e.printStackTrace();
       &#125; catch (IOException e) &#123;
          e.printStackTrace();
       &#125; finally &#123;
          if (fis != null) &#123;
             try &#123;
                fis.close();
             &#125; catch (IOException e) &#123;
                e.printStackTrace();
             &#125;
          &#125;
       &#125;
    &#125;
&#125;
</code></pre>
<h3 id="6）、FileInputStream类的其它常用方法"><a href="#6）、FileInputStream类的其它常用方法" class="headerlink" title="6）、FileInputStream类的其它常用方法"></a>6）、FileInputStream类的其它常用方法</h3><pre><code>    int    available()  返回流当中剩余的没有读到的字节数量
    long skip(long n) 跳过几个字节不读
    import java.io.FileInputStream;
    import java.io.FileNotFoundException;
    import java.io.IOException;
    public class FileInputStreamTest05 &#123;
        public static void main(String[] args) &#123;
           FileInputStream fis = null;
           try &#123;
              fis = new FileInputStream(&quot;tempfile&quot;);
              System.out.println(&quot;总字节数量&quot; + fis.available()); //6
              //读一个字节
              //int readByte = fis.read();
              //还剩下可以读的字节数量是：
              //System.out.println(&quot;还剩下：&quot; + fis.available() + &quot; 个字节未读&quot;); //5
              //这个方法有什么用？
              //byte[] bytes = new byte[fis.available()]; //这种方式不太适合太大的文件，因为byte数组不能太大
              //不需要循环了，直接读一次就行了
              //int readCount = fis.read(bytes);
              //System.out.println(new String(bytes)); //abcdef

              //skip跳过几个字节不读取，这个方法也可能以后会用！
              fis.skip(3);
              System.out.println(fis.read()); //100

           &#125; catch (FileNotFoundException e) &#123;
              e.printStackTrace();
           &#125; catch (IOException e) &#123;
              e.printStackTrace();
           &#125; finally &#123;
              if (fis != null) &#123;
                 try &#123;
                    fis.close();
                 &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                 &#125;
              &#125;
           &#125;
        &#125;
    &#125;
</code></pre>
<h2 id="7、java-io-FileInputStream"><a href="#7、java-io-FileInputStream" class="headerlink" title="7、java.io.FileInputStream"></a>7、java.io.FileInputStream</h2><h3 id="1）、文件字节输出流，负责写；从内存到硬盘。"><a href="#1）、文件字节输出流，负责写；从内存到硬盘。" class="headerlink" title="1）、文件字节输出流，负责写；从内存到硬盘。"></a>1）、文件字节输出流，负责写；从内存到硬盘。</h3><pre><code>    import java.io.FileNotFoundException;
    import java.io.FileOutputStream;
    import java.io.IOException;
    public class FileOutputStreamTest01 &#123;
        public static void main(String[] args) &#123;
           FileOutputStream fos = null;
           try &#123;
              //myfile文件不存在的时候会自动在工程文件夹下新建
              //这种方式谨慎使用，这种方式会先将原文件清空，然后再写入。
              //fos = new FileOutputStream(&quot;src/src/tempfile2&quot;);
              //以追加的方式在文件末尾写入，不会清空源文件内容
              fos = new FileOutputStream(&quot;src/src/tempfile2&quot;,true);
              //开始写
              byte[] bytes = &#123;97,98,99,100&#125;;
              //将bytes数组全部写出
              fos.write(bytes); //abcd
              //将byte数组一部分写出！

              fos.write(bytes,0,2); //再写出ab

              String s = &quot;我是一个中国人，我骄傲！！！！&quot;;
              byte[] bytes1 = s.getBytes(); //getBytes，把字符串转换成byte数组
              fos.write(bytes1);

              //写完之后，最后一定要刷新
              fos.flush();
           &#125; catch (FileNotFoundException e) &#123;
              e.printStackTrace();
           &#125; catch (IOException e) &#123;
              e.printStackTrace();
           &#125; finally &#123;
              if (fos != null) &#123;
                 try &#123;
                    fos.close();
                 &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                 &#125;
              &#125;
           &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="2）、使用FileInputStream-FileOutputStream完成文件的拷贝。"><a href="#2）、使用FileInputStream-FileOutputStream完成文件的拷贝。" class="headerlink" title="2）、使用FileInputStream + FileOutputStream完成文件的拷贝。"></a>2）、使用FileInputStream + FileOutputStream完成文件的拷贝。</h3><pre><code>    拷贝的过程应该是一边读一边写。
    使用以上的字节流拷贝文件的时候，文件类型随意，万能的。什么养的文件都能拷贝。
    import java.io.FileInputStream;
    import java.io.FileNotFoundException;
    import java.io.FileOutputStream;
    import java.io.IOException;
    public class Copy01 &#123;
        public static void main(String[] args) &#123;
           FileInputStream fis = null;
           FileOutputStream fos = null;
           try &#123;
              //创建一个输入流对象
              fis = new FileInputStream(&quot;F:\\ANSYS_VIDEO\\fluent+post.avi&quot;);
              //创建一个输出流对象
              fos = new FileOutputStream(&quot;F:\\fluent+post.avi&quot;,true);

              //最核心的：一边读，一边写
              byte[] bytes = new byte[1024 * 1024]; //一次最多拷贝1MB
              int readData = 0;
              while ((readData = fis.read(bytes)) != -1)&#123;
                 fos.write(bytes,0,readData);
              &#125;

              //刷新，输出流最后要刷新
              fos.flush();
           &#125; catch (FileNotFoundException e) &#123;
              e.printStackTrace();
           &#125; catch (IOException e) &#123;
              e.printStackTrace();
           &#125; finally &#123;
              //分开try，不要一起try。
              //一起try的时候，其中一个出现出现异常，可能会影响另一个流的关闭
              if (fis != null) &#123;
                 try &#123;
                    fis.close();
                 &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                 &#125;
              &#125;

              if (fos != null) &#123;
                 try &#123;
                    fos.close();
                 &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                 &#125;
              &#125;
           &#125;
        &#125;
    &#125;
</code></pre>
<h2 id="8、java-io-Reader"><a href="#8、java-io-Reader" class="headerlink" title="8、java.io.Reader"></a>8、java.io.Reader</h2><pre><code>FileReader:
    文件字符输入流，只能读取普通文本。
    读取文本内容时比较方便，快捷。
    import java.io.FileNotFoundException;
    import java.io.FileReader;
    import java.io.IOException;
    public class FileReaderTest01 &#123;
        public static void main(String[] args) &#123;
           FileReader reader = null;
           try &#123;
              reader = new FileReader(&quot;tempFile&quot;);
              //开始读
              char[] chars = new char[4]; //一次读取4个字符；按支付的方式读取
              int readcound = 0;
              while ((readcound = reader.read(chars)) != -1)&#123;
                 System.out.println(new String(chars,0,readcound));
              &#125;
           &#125; catch (FileNotFoundException e) &#123;
              e.printStackTrace();
           &#125; catch (IOException e) &#123;
              e.printStackTrace();
           &#125; finally &#123;
              if (reader != null) &#123;
                 try &#123;
                    reader.close();
                 &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                 &#125;
              &#125;
           &#125;
        &#125;
    &#125;
</code></pre>
<h2 id="9、java-io-Writer"><a href="#9、java-io-Writer" class="headerlink" title="9、java.io.Writer"></a>9、java.io.Writer</h2><pre><code>    FileWriter：
        文件字符输出流，写。
        只能输出普通文本
    import java.io.FileWriter;
    import java.io.IOException;
    public class FileWriterTest01 &#123;
        public static void main(String[] args) &#123;
           FileWriter fw = null;
           try &#123;
              //创建文件字符输出流对象
              fw = new FileWriter(&quot;tempFile&quot;,true);

              //开始写
              char[] chars = &#123;&#39;我&#39;,&#39;是&#39;,&#39;中&#39;,&#39;国&#39;,&#39;人&#39;&#125;;

              fw.write(chars);
              fw.write(&quot;\n&quot;);

              fw.write(chars,2,3);
              fw.write(&quot;\n&quot;);
              //直接写入字符串
              fw.write(&quot;我骄傲！！！&quot;);


              //刷新
              fw.flush();
           &#125; catch (IOException e) &#123;
              e.printStackTrace();
           &#125;finally &#123;
              if (fw != null) &#123;
                 try &#123;
                    fw.close();
                 &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                 &#125;
              &#125;
           &#125;
        &#125;
    &#125;
</code></pre>
<h2 id="10、使用FileReader和FileWriter进行拷贝的话，只能拷贝普通文本文件"><a href="#10、使用FileReader和FileWriter进行拷贝的话，只能拷贝普通文本文件" class="headerlink" title="10、使用FileReader和FileWriter进行拷贝的话，只能拷贝普通文本文件"></a>10、使用FileReader和FileWriter进行拷贝的话，只能拷贝普通文本文件</h2><pre><code>    import java.io.FileNotFoundException;
    import java.io.FileReader;
    import java.io.FileWriter;
    import java.io.IOException;
    public class Copy02 &#123;
        public static void main(String[] args) &#123;
           FileReader fr = null;
           FileWriter fw = null;
           try &#123;
              //读
              fr = new FileReader(&quot;tempFile&quot;);
              //写
              fw = new FileWriter(&quot;F:\\ideaIUproject\\IO\\src\\src\\tempFile.text&quot;,true);

              //一边读一边写
              char[] chars = new char[1024 * 512];//1MB
              int readCount = 0;
              while ((readCount = fr.read(chars)) != -1)&#123;
                 fw.write(chars,0,readCount);
              &#125;
              //刷新
              fw.flush();
           &#125; catch (FileNotFoundException e) &#123;
              e.printStackTrace();
           &#125; catch (IOException e) &#123;
              e.printStackTrace();
           &#125;finally &#123;
              if (fr != null) &#123;
                 try &#123;
                    fr.close();
                 &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                 &#125;
              &#125;

              if (fw != null) &#123;
                 try &#123;
                    fw.close();
                 &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                 &#125;
              &#125;
           &#125;
        &#125;
    &#125;
</code></pre>
<h2 id="11、BufferedReader"><a href="#11、BufferedReader" class="headerlink" title="11、BufferedReader:"></a>11、BufferedReader:</h2><h3 id="1）、带有缓冲区的字符输入流；"><a href="#1）、带有缓冲区的字符输入流；" class="headerlink" title="1）、带有缓冲区的字符输入流；"></a>1）、带有缓冲区的字符输入流；</h3><pre><code>    使用这个流的时候不需要自定义char数组，或者说不需要自定义byte数组，自带缓冲。
    import java.io.*;
    public class BufferedReaderTest01 &#123;
        public static void main(String[] args)&#123;
           //当一个流的构造方法中需要一个流的时候，这个被传进来的流叫做：节点流。
           //外部负责包装的这个流叫做：包装流，还有一个名字叫做：处理流。
           //像当前这个程序来说，FileReader就是一个节点流；BufferedReader就是一个包装流/处理流。
           FileReader reader = null;
           BufferedReader br = null;
           try &#123;
              reader = new FileReader(&quot;tempFile&quot;);
              br = new BufferedReader(reader);
              //读一行
              /*String firstLine = br.readLine();
              System.out.println(firstLine);

              String secondLine = br.readLine();
              System.out.println(secondLine);*/

              //br.readLine()方法读取一个文本行，但不带换行符
              String line = null;
              while ((line = br.readLine()) != null)&#123;
                 System.out.println(line);
              &#125;
           &#125; catch (FileNotFoundException e) &#123;
              e.printStackTrace();
           &#125; catch (IOException e) &#123;
              e.printStackTrace();
           &#125;finally &#123;
              //关闭流
              //对于包装流来说，只需要关闭最外层流就行，里面的节点流会自动关闭。（可以看源代码）
              if (br != null) &#123;
                 try &#123;
                    br.close();
                 &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                 &#125;
              &#125;
           &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="2）、转换流："><a href="#2）、转换流：" class="headerlink" title="2）、转换流："></a>2）、转换流：</h3><pre><code>    java.io.InputStreamReader
    import java.io.*;
    public class BufferedReaderTest02 &#123;
        public static void main(String[] args) &#123;
           FileInputStream in = null;
           BufferedReader br = null;
           try &#123;
              /*in = new FileInputStream(&quot;tempFile&quot;);
              //通过转换流转换（InputStreamReader将字节流转换为字符流。）
              InputStreamReader reader = new InputStreamReader(in);
              br = new BufferedReader(reader);*/
              //合并
              br = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;tempFile&quot;)));

              String line = null;
              while ((line = br.readLine()) != null)&#123;
                 System.out.println(line);
              &#125;
           &#125; catch (FileNotFoundException e) &#123;
              e.printStackTrace();
           &#125; catch (IOException e) &#123;
              e.printStackTrace();
           &#125; finally &#123;
              if (br != null)&#123;
                 try &#123;
                    br.close();
                 &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                 &#125;
              &#125;
           &#125;
        &#125;
    &#125;
</code></pre>
<h2 id="12、BufferedWriter：带有缓冲的字符输出流。"><a href="#12、BufferedWriter：带有缓冲的字符输出流。" class="headerlink" title="12、BufferedWriter：带有缓冲的字符输出流。"></a>12、BufferedWriter：带有缓冲的字符输出流。</h2><pre><code>OutputStreamWriter：转换流
import java.io.*;
public class BufferedWriterTest01 &#123;
    public static void main(String[] args) &#123;
       FileOutputStream out = null;
       BufferedWriter bw = null;
       try &#123;
          //带有缓冲区的字符输出流
          //bw = new BufferedWriter(new FileWriter(&quot;tempFile&quot;,true));
          bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;tempFile&quot;,true)));
          bw.write(&quot;\n&quot;);
          bw.write(&quot;hello world!&quot;);
          bw.write(&quot;\n&quot;);
          bw.write(&quot;hello kitty!&quot;);

          //刷新不能忘
          bw.flush();
       &#125; catch (IOException e) &#123;
          e.printStackTrace();
       &#125;finally &#123;
          if (bw != null)&#123;
             try &#123;
                bw.close();
             &#125; catch (IOException e) &#123;
                e.printStackTrace();
             &#125;
          &#125;
       &#125;
    &#125;
&#125;
</code></pre>
<h2 id="13、数据流专属："><a href="#13、数据流专属：" class="headerlink" title="13、数据流专属："></a>13、数据流专属：</h2><pre><code>    java.io.DataInputStream
    java.io.DataOutputStream
</code></pre>
<h3 id="1）、java-io-DataOutputStream：数据专属的流"><a href="#1）、java-io-DataOutputStream：数据专属的流" class="headerlink" title="1）、java.io.DataOutputStream：数据专属的流"></a>1）、java.io.DataOutputStream：数据专属的流</h3><pre><code>    这个流可以将数据联通数据类型一并写入文件。
    注意：这个文件不是普通文本文档。（这个文件用记事本打不开。）
    import java.io.DataOutputStream;
    import java.io.FileNotFoundException;
    import java.io.FileOutputStream;
    import java.io.IOException;
    public class DataOutputStreamTest &#123;
        public static void main(String[] args) &#123;
           DataOutputStream dos = null;
           try &#123;
              //创建数据专属的字节输出流
              dos = new DataOutputStream(new FileOutputStream(&quot;data&quot;)); //记事本打不开
              //写数据
              byte b = 100;
              short s = 200;
              int i = 300;
              long l = 400L;
              float f = 3.0F;
              double d = 3.14;
              boolean sex = false;
              char c = &#39;a&#39;;
              //写
              dos.writeByte(b); //把数据以及数据的类型一并写入到文件当中
              dos.writeShort(s);
              dos.writeInt(i);
              dos.writeLong(l);
              dos.writeFloat(f);
              dos.writeDouble(d);
              dos.writeBoolean(sex);
              dos.writeChar(c);

              //刷新
              dos.flush();
           &#125; catch (FileNotFoundException e) &#123;
              e.printStackTrace();
           &#125; catch (IOException e) &#123;
              e.printStackTrace();
           &#125;finally &#123;
              if (dos != null)&#123;
                 try &#123;
                    dos.close();
                 &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                 &#125;
              &#125;
           &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="2）、DataInputStream：数据字节输入流"><a href="#2）、DataInputStream：数据字节输入流" class="headerlink" title="2）、DataInputStream：数据字节输入流"></a>2）、DataInputStream：数据字节输入流</h3><pre><code>    DataOutputStream写的文件，只能使用DataInputStream去读，并且读的时候你需要提前知道写入的顺序。
    读的顺序和写的顺序一直，才可以正常取出数据
    import java.io.DataInputStream;
    import java.io.FileInputStream;
    import java.io.FileNotFoundException;
    import java.io.IOException;
    public class DataInputStreamTest01 &#123;
        public static void main(String[] args) &#123;
           DataInputStream dis = null;
           try &#123;
              dis = new DataInputStream(new FileInputStream(&quot;data&quot;));
              //开始读
              byte b =  dis.readByte();
              short s =  dis.readShort();
              int i = dis.readInt();
              long l = dis.readLong();
              float f =  dis.readFloat();
              double d=  dis.readDouble();
              boolean sex = dis.readBoolean();
              char c = dis.readChar();

              //读
              System.out.println(b);
              System.out.println(s);
              System.out.println(i + 100);
              System.out.println(l);
              System.out.println(f);
              System.out.println(d);
              System.out.println(sex);
              System.out.println(c);
           &#125; catch (FileNotFoundException e) &#123;
              e.printStackTrace();
           &#125; catch (IOException e) &#123;
              e.printStackTrace();
           &#125; finally &#123;
              if (dis != null)&#123;
                 try &#123;
                    dis.close();
                 &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                 &#125;
              &#125;
           &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="3）、java-io-PrintStream：标准的字节输出流；默认输出到控制台。"><a href="#3）、java-io-PrintStream：标准的字节输出流；默认输出到控制台。" class="headerlink" title="3）、java.io.PrintStream：标准的字节输出流；默认输出到控制台。"></a>3）、java.io.PrintStream：标准的字节输出流；默认输出到控制台。</h3><pre><code>import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
public class PrintStreamTest &#123;
    public static void main(String[] args) &#123;
       System.out.println(&quot;hello world!&quot;);

       //分开写
       PrintStream ps = System.out;
       ps.println(&quot;hello zhangsan&quot;);
       ps.println(&quot;hello lisi&quot;);
       ps.println(&quot;hello wangwu&quot;);

       //标准输出流不需要手动close()关闭
       //可以改变标准输出流的输出方向吗？ 可以
       try &#123;
          //标准输出流不再指向控制台，指向&quot;tempFile&quot;文件
          PrintStream printStream = new PrintStream(new FileOutputStream(&quot;log&quot;));
          //修改输出方向，将输出方向修改到“log”文件。
          System.setOut(printStream);
          //再输出
          System.out.println(&quot;Hello world&quot;);
          System.out.println(&quot;Hello kitty&quot;);
          System.out.println(&quot;Hello zhangsan&quot;);
       &#125; catch (FileNotFoundException e) &#123;
          e.printStackTrace();
       &#125;
    &#125;
&#125;
</code></pre>
<h2 id="14、File"><a href="#14、File" class="headerlink" title="14、File"></a>14、File</h2><h3 id="1）、File类和四大家族没有关系，所以File类不能完成文件的读和写。"><a href="#1）、File类和四大家族没有关系，所以File类不能完成文件的读和写。" class="headerlink" title="1）、File类和四大家族没有关系，所以File类不能完成文件的读和写。"></a>1）、File类和四大家族没有关系，所以File类不能完成文件的读和写。</h3><h3 id="2）、File对象代表什么？"><a href="#2）、File对象代表什么？" class="headerlink" title="2）、File对象代表什么？"></a>2）、File对象代表什么？</h3><pre><code>        文件和目录路径名的抽象表示形式。
        一个File对象有可能对应的是目录，也可能是文件
        File只是一个路径名的抽象表示形式。
</code></pre>
<h3 id="3）、需要掌握File类中的常用方法。"><a href="#3）、需要掌握File类中的常用方法。" class="headerlink" title="3）、需要掌握File类中的常用方法。"></a>3）、需要掌握File类中的常用方法。</h3><pre><code>import java.io.File;
import java.io.IOException;
public class FileTest01 &#123;
    public static void main(String[] args) &#123;
       //创建一个File对象
       File f1 = new File(&quot;F:\\file&quot;);
       //判断File是否存在
       System.out.println(f1.exists()); //false
       //如果F:\file不存在
       if (!f1.exists()) &#123;
          //以文件的形式创建出来
          //f1.createNewFile();
          //以目录的方式创建出来
          f1.mkdir();

          //以多重目录的形式新建
          //f1.mkdirs();
       &#125;
          File f2 = new File(&quot;F:\\unbutu笔记&quot;);
          //获取文件的父路径
          System.out.println(f2.getParent()); //F:\
    &#125;
&#125;
</code></pre>
<p> **由于线程较为复杂，所以打算另写一篇文章专门介绍线程。  **</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://xugjia.github.io">xuguangjia</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://xugjia.github.io/2022/11/13/Java-SE%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6%E7%89%88/">http://xugjia.github.io/2022/11/13/Java-SE%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6%E7%89%88/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://xugjia.github.io" target="_blank">XuGJia Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/11/08/hello-world/"><img class="next-cover" src="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xuguangjia</div><div class="author-info__description">Java，一个究极卷的行业，你值得入坑！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xugjia" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:250330100@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">一、抽象类和接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E4%BB%A5%E5%8F%8A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">1.1.</span> <span class="toc-text">1、抽象类、接口以及抽象类和接口的区别。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">1）、什么是抽象类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%B1%9E%E4%BA%8E%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">2）、抽象类属于什么类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%EF%BC%9F%E3%80%90%E8%83%BD%E6%8A%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%85%88%E5%AD%A6%E4%BC%9A%E5%B0%B1%E8%A1%8C%E3%80%91"><span class="toc-number">1.1.3.</span> <span class="toc-text">3）、抽象类怎么定义？【能把基础语法先学会就行】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E6%97%A0%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%EF%BC%8C%E6%97%A0%E6%B3%95%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%89%80%E4%BB%A5%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E7%94%A8%E6%9D%A5%E8%A2%AB%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%9A%84"><span class="toc-number">1.1.4.</span> <span class="toc-text">4）、抽象类是无法实例化的，无法创建对象，所以抽象类是用来被子类继承的.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E3%80%81final%E5%92%8Cabstract%E4%B8%8D%E8%83%BD%E8%81%94%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%8C%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E5%AF%B9%E7%AB%8B%E7%9A%84%E3%80%82"><span class="toc-number">1.1.5.</span> <span class="toc-text">5）、final和abstract不能联合使用，这两个关键字是对立的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%AD%90%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%98%AF%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%82"><span class="toc-number">1.1.6.</span> <span class="toc-text">6）、抽象类的子类可以是抽象类。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%BC%89%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%99%BD%E7%84%B6%E6%97%A0%E6%B3%95%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%8C%E4%BD%86%E6%98%AF%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E6%9E%84%E9%80%A0%EF%BC%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%98%AF%E4%BE%9B%E5%AD%90%E7%B1%BB%E4%BD%BF%E7%94%A8%E7%9A%84%E3%80%82"><span class="toc-number">1.1.7.</span> <span class="toc-text">7）、抽象类虽然无法被实例化，但是抽象类有构造，构造方法是供子类使用的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%EF%BC%89%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%85%B3%E8%81%94%E4%B8%80%E4%B8%AA%E6%A6%82%E5%BF%B5%EF%BC%9A%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E3%80%82%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%91%A2%EF%BC%9F"><span class="toc-number">1.1.8.</span> <span class="toc-text">8）、抽象类关联一个概念：抽象方法。什么是抽象方法呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%EF%BC%89%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%AD%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%9C%89%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E5%87%BA%E7%8E%B0%E5%9C%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%AD%E3%80%82"><span class="toc-number">1.1.9.</span> <span class="toc-text">9）、抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%EF%BC%89%E3%80%81%E9%87%8D%E8%A6%81%E7%BB%93%E8%AE%BA%EF%BC%9A%E4%BA%94%E9%A2%97%E6%98%9F-%EF%BC%88%E5%BF%85%E9%A1%BB%E8%AE%B0%E4%BD%8F%EF%BC%89"><span class="toc-number">1.1.10.</span> <span class="toc-text">10）、重要结论：五颗星*****（必须记住）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">2、接口的基础语法：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%82%E7%BC%96%E8%AF%91%E4%B9%8B%E5%90%8E%E4%B9%9F%E6%98%AF%E4%B8%80%E4%B8%AAclass%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">1）、接口也是一种引用数据类型。编译之后也是一个class字节码文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%AE%8C%E5%85%A8%E6%8A%BD%E8%B1%A1%E7%9A%84%E3%80%82%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%8D%8A%E6%8A%BD%E8%B1%A1%E7%9A%84%EF%BC%89%E6%88%96%E8%80%85%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%AF%B4%E6%8E%A5%E5%8F%A3%E6%98%AF%E7%89%B9%E6%AE%8A%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%82"><span class="toc-number">1.2.2.</span> <span class="toc-text">2）、接口是完全抽象的。（抽象类是半抽象的）或者也可以说接口是特殊的抽象类。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E3%80%81%E6%8E%A5%E5%8F%A3%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%EF%BC%8C%E8%AF%AD%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">3）、接口怎么定义，语法是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E3%80%81%E6%8E%A5%E5%8F%A3%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E3%80%82"><span class="toc-number">1.2.4.</span> <span class="toc-text">4）、接口支持多继承，一个接口可以继承多个接口。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%8F%AA%E5%8C%85%E5%90%AB%E4%B8%A4%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%EF%BC%8C%E4%B8%80%E9%83%A8%E5%88%86%E6%98%AF%EF%BC%9A%E5%B8%B8%E9%87%8F%EF%BC%9B%E4%B8%80%E9%83%A8%E5%88%86%E6%98%AF%EF%BC%9A%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E3%80%82%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%B2%A1%E6%9C%89%E5%85%B6%E5%AE%83%E5%86%85%E5%AE%B9%E4%BA%86%EF%BC%8C%E5%8F%AA%E6%9C%89%E4%BB%A5%E4%B8%8A%E4%B8%A4%E9%83%A8%E5%88%86%E3%80%82"><span class="toc-number">1.2.5.</span> <span class="toc-text">5）、接口中只包含两部分内容，一部分是：常量；一部分是：抽象方法。接口中没有其它内容了，只有以上两部分。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%85%83%E7%B4%A0%E9%83%BD%E6%98%AFpublic%E4%BF%AE%E9%A5%B0%E7%9A%84%E3%80%82%EF%BC%88%E9%83%BD%E6%98%AF%E5%85%AC%E5%BC%80%E7%9A%84%EF%BC%89"><span class="toc-number">1.2.6.</span> <span class="toc-text">6）、接口中所有的元素都是public修饰的。（都是公开的）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%BC%89%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E6%97%B6%EF%BC%9Apublic-abstract%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5%E3%80%82"><span class="toc-number">1.2.7.</span> <span class="toc-text">7）、接口中的抽象方法定义时：public abstract修饰符可以省略。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%EF%BC%89%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E9%83%BD%E6%98%AF%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B8%8D%E8%83%BD%E5%B8%A6%E6%9C%89%E6%96%B9%E6%B3%95%E4%BD%93%E3%80%82"><span class="toc-number">1.2.8.</span> <span class="toc-text">8）、接口中的方法都是抽象方法，所以不能带有方法体。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%EF%BC%89%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E9%87%8F%E7%9A%84public-abstract%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5%E3%80%82"><span class="toc-number">1.2.9.</span> <span class="toc-text">9）、接口中常量的public abstract修饰符可以省略。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">3、接口的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81%E7%B1%BB%E5%92%8C%E7%B1%BB%E4%B9%8B%E9%97%B4%E5%8F%AB%E5%81%9A%E7%BB%A7%E6%89%BF%EF%BC%8C%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%B9%8B%E9%97%B4%E5%8F%AB%E5%81%9A%E5%AE%9E%E7%8E%B0%E3%80%82%E3%80%90%E5%88%AB%E5%A4%9A%E6%83%B3%EF%BC%8C%E4%BB%8D%E7%84%B6%E5%8F%AF%E4%BB%A5%E5%B0%86%E2%80%9C%E5%AE%9E%E7%8E%B0%E2%80%9D%E7%9C%8B%E4%BD%9C%E2%80%9C%E7%BB%A7%E6%89%BF%E2%80%9D%E3%80%91"><span class="toc-number">1.3.1.</span> <span class="toc-text">1）、类和类之间叫做继承，类和接口之间叫做实现。【别多想，仍然可以将“实现”看作“继承”】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%E7%9A%84%E7%BB%93%E8%AE%BA%EF%BC%9A%E5%BD%93%E4%B8%80%E4%B8%AA%E9%9D%9E%E6%8A%BD%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%BF%85%E9%A1%BB%E5%B0%86%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%85%A8%E9%83%A8%E5%AE%9E%E7%8E%B0-%E8%A6%86%E7%9B%96-%E9%87%8D%E5%86%99%E3%80%82"><span class="toc-number">1.3.2.</span> <span class="toc-text">2）、非常重要的结论：当一个非抽象的类实现接口的话，必须将接口中所有的抽象方法全部实现&#x2F;覆盖&#x2F;重写。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%B9%8B%E9%97%B4%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF%EF%BC%8C%E9%82%A3%E4%B9%88%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E5%90%97%EF%BC%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">3）、接口和接口之间支持多继承，那么一个类可以同时实现多个接口吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E3%80%81%E8%BF%99%E7%A7%8D%E6%9C%BA%E5%88%B6%E5%BC%A5%E8%A1%A5%E4%BA%86java%E4%B8%AD%E7%9A%84%E5%93%AA%E4%B8%AA%E7%BC%BA%E9%99%B7%EF%BC%9F"><span class="toc-number">1.3.4.</span> <span class="toc-text">4）、这种机制弥补了java中的哪个缺陷？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E3%80%81%E6%8E%A5%E5%8F%A3A%E5%92%8C%E6%8E%A5%E5%8F%A3B%E8%99%BD%E7%84%B6%E6%B2%A1%E6%9C%89%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%8C%E4%BD%86%E6%98%AF%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E4%BA%92%E8%BD%AC%EF%BC%9B%E4%B8%8D%E8%BF%87%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%EF%BC%9AClassCastException%E5%BC%82%E5%B8%B8%E3%80%82"><span class="toc-number">1.3.5.</span> <span class="toc-text">5）、接口A和接口B虽然没有继承关系，但是写代码的时候可以互转；不过运行的时候可能出现：ClassCastException异常。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89%E3%80%81%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E9%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E8%AF%9D%EF%BC%8C%E4%BB%A3%E7%A0%81%E8%AF%A5%E6%80%8E%E4%B9%88%E5%86%99%EF%BC%9F"><span class="toc-number">1.3.6.</span> <span class="toc-text">6）、继承和实现都存在的话，代码该怎么写？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%8E%A5%E5%8F%A3%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">4、接口在开发中的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81%E5%AE%9E%E4%BE%8B%EF%BC%9A%E9%A1%BE%E5%AE%A2%E6%8B%BF%E8%8F%9C%E5%8D%95%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%82%B9%E9%A4%90%EF%BC%8C%E5%8E%A8%E5%B8%88%E6%8C%89%E7%85%A7%E8%8F%9C%E5%8D%95%E5%81%9A%E8%8F%9C%E3%80%90%E5%8E%A8%E5%B8%88%E6%98%AF%E8%8F%9C%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%80%85%E3%80%91"><span class="toc-number">1.4.1.</span> <span class="toc-text">1）、实例：顾客拿菜单（接口）点餐，厨师按照菜单做菜【厨师是菜单的实现者】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-number">1.5.</span> <span class="toc-text">5、类型和类型之间的关系：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">6、抽象类和接口有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81JDK%E7%B1%BB%E5%BA%93%E7%9A%84%E6%A0%B9%E7%B1%BB%EF%BC%9AObject"><span class="toc-number">2.</span> <span class="toc-text">二、JDK类库的根类：Object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81%E8%BF%99%E4%B8%AA%E8%80%81%E7%A5%96%E5%AE%97%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E9%83%BD%E6%98%AF%E6%89%80%E6%9C%89%E5%AD%90%E7%B1%BB%E9%80%9A%E7%94%A8%E7%9A%84%E3%80%82%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E7%B1%BB%E9%BB%98%E8%AE%A4%E7%BB%A7%E6%89%BFObject%EF%BC%8C%E5%B0%B1%E7%AE%97%E6%B2%A1%E6%9C%89%E7%9B%B4%E6%8E%A5%E7%BB%A7%E6%89%BF%EF%BC%8C%E6%9C%80%E7%BB%88%E4%B9%9F%E4%BC%9A%E9%97%B4%E6%8E%A5%E7%BB%A7%E6%89%BF%E3%80%82"><span class="toc-number">2.0.1.</span> <span class="toc-text">1）、这个老祖宗类中的方法我们需要研究一下，因为这些方法都是所有子类通用的。任何一个类默认继承Object，就算没有直接继承，最终也会间接继承。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81Object%E7%B1%BB%E5%BD%93%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">2.0.2.</span> <span class="toc-text">2）、Object类当中有哪些常用的方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E3%80%81%E5%85%B3%E4%BA%8EObject%E7%B1%BB%E4%B8%AD%E7%9A%84toString-%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.3.</span> <span class="toc-text">3）、关于Object类中的toString()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E3%80%81%E5%85%B3%E4%BA%8EObject%E7%B1%BB%E4%B8%AD%E7%9A%84equals%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.4.</span> <span class="toc-text">4）、关于Object类中的equals方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E3%80%81String%E6%9C%89%E6%B2%A1%E6%9C%89%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E5%92%8CtoString%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.0.5.</span> <span class="toc-text">5）、String有没有重写equals方法和toString方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89%E3%80%81%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E7%9A%84%E6%97%B6%E5%80%99%E8%A6%81%E5%BD%BB%E5%BA%95%EF%BC%9A"><span class="toc-number">2.0.6.</span> <span class="toc-text">6）、重写equals方法的时候要彻底：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%BC%89%E3%80%81%E5%85%B3%E4%BA%8EObject%E7%B1%BB%E4%B8%AD%E7%9A%84finalize%E6%96%B9%E6%B3%95%EF%BC%88%E9%9D%9E%E9%87%8D%E7%82%B9%EF%BC%8C%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-number">2.0.7.</span> <span class="toc-text">7）、关于Object类中的finalize方法（非重点，了解即可）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%EF%BC%89%E3%80%81%E5%85%B3%E4%BA%8EObject%E7%B1%BB%E5%BA%93%E4%B8%AD%E7%9A%84hashCode-%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.0.8.</span> <span class="toc-text">8）、关于Object类库中的hashCode()方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%EF%BC%89%E3%80%81%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB-%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%90%8D%E5%AD%97-%EF%BC%9A"><span class="toc-number">2.0.9.</span> <span class="toc-text">9）、匿名内部类(类没有名字)：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text">三、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%85%B3%E4%BA%8Ejava%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84-Array"><span class="toc-number">3.1.</span> <span class="toc-text">1、关于java语言中的数组(Array):</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81java%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%98%AF%E4%B8%80%E7%A7%8D%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%8D%E5%B1%9E%E4%BA%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9B%E6%95%B0%E7%BB%84%E7%9A%84%E7%88%B6%E7%B1%BB%E6%98%AFObject%E7%B1%BB%E3%80%82"><span class="toc-number">3.1.1.</span> <span class="toc-text">1）、java语言中的数组是一种引用数据类型，不属于基本数据类型；数组的父类是Object类。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81%E6%95%B0%E7%BB%84%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%AE%B9%E7%BA%B3%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0%E3%80%82-%E6%95%B0%E7%BB%84%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">3.1.2.</span> <span class="toc-text">2）、数组是一个容器，可以容纳多个元素。(数组是一个数据的集合)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E3%80%81%E6%95%B0%E7%BB%84%E5%BD%93%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E2%80%9D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%80%9D%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E2%80%9D%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%80%9D%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">3.1.3.</span> <span class="toc-text">3）、数组当中可以存储”基本数据类型”的数据，也可以存储”引用数据类型”的数据。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E3%80%81%E6%95%B0%E7%BB%84%E5%9B%A0%E4%B8%BA%E6%98%AF%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%89%80%E4%BB%A5%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%AD%98%E5%82%A8%E5%9C%A8%E5%A0%86%E5%86%85%E5%AD%98%E5%BD%93%E4%B8%AD%E7%9A%84%E3%80%82"><span class="toc-number">3.1.4.</span> <span class="toc-text">4）、数组因为是引用数据类型，所以数组对象是存储在堆内存当中的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E3%80%81%E5%AF%B9%E4%BA%8E%E6%95%B0%E7%BB%84%E5%BD%93%E4%B8%AD%E5%A6%82%E6%9E%9C%E5%AD%98%E5%82%A8%E7%9A%84%E6%98%AF%E2%80%9Djava%E5%AF%B9%E8%B1%A1%E2%80%9D%E7%9A%84%E8%AF%9D%E5%AE%9E%E9%99%85%E4%B8%8A%E5%AD%98%E5%82%A8%E7%9A%84%E6%98%AF%E5%AF%B9%E8%B1%A1%E7%9A%84%E2%80%9D%E5%BC%95%E7%94%A8-%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80-%E2%80%9D"><span class="toc-number">3.1.5.</span> <span class="toc-text">5）、对于数组当中如果存储的是”java对象”的话实际上存储的是对象的”引用(内存地址)”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%80%E6%97%A6%E5%88%9B%E5%BB%BA%EF%BC%8C%E5%9C%A8java%E4%B8%AD%E8%A7%84%E5%AE%9A%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%AF%E5%8F%98%E3%80%82"><span class="toc-number">3.1.6.</span> <span class="toc-text">6）、数组一旦创建，在java中规定长度不可变。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%BC%89%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E3%80%81%E4%B8%89%E4%BD%8D%E6%95%B0%E7%BB%84%E3%80%81%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E2%80%A6-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BE%83%E5%A4%9A%EF%BC%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%81%B6%E5%B0%94%E4%BD%BF%E7%94%A8%EF%BC%81"><span class="toc-number">3.1.7.</span> <span class="toc-text">7）、数组的分类：一维数组、二维数组、三位数组、多维数组…..(一维数组较多，二维数组偶尔使用！)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%EF%BC%89%E3%80%81%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%9C%89length%E5%B1%9E%E6%80%A7-java%E8%87%AA%E5%B8%A6%E7%9A%84-%EF%BC%8C%E7%94%A8%E6%9D%A5%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0%E3%80%82"><span class="toc-number">3.1.8.</span> <span class="toc-text">8）、所有的数组对象都有length属性(java自带的)，用来获取数组中元素的个数。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%EF%BC%89%E3%80%81java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E8%A6%81%E6%B1%82%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BB%9F%E4%B8%80%EF%BC%9B%E6%AF%94%E5%A6%82int%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E5%8F%AA%E8%83%BD%E5%AD%98%E5%82%A8int%E7%B1%BB%E5%9E%8B%E3%80%81Person%E6%95%B0%E7%BB%84%E5%8F%AA%E8%83%BD%E5%AD%98%E5%82%A8Person%E7%B1%BB%E5%9E%8B%E3%80%82"><span class="toc-number">3.1.9.</span> <span class="toc-text">9）、java中的数组要求数组中元素的类型统一；比如int类型数组只能存储int类型、Person数组只能存储Person类型。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%EF%BC%89%E3%80%81%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E6%96%B9%E9%9D%A2%E5%AD%98%E5%82%A8%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%E3%80%82-%E5%AD%98%E5%82%A8%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E9%83%BD%E6%98%AF%E6%9C%89%E8%A7%84%E5%88%99%E7%9A%84%E6%8C%A8%E7%9D%80%E6%8E%92%E5%88%97%E7%9A%84"><span class="toc-number">3.1.10.</span> <span class="toc-text">10）、数组在内存方面存储的时候，数组中的元素内存地址是连续的。(存储的每一个元素都是有规则的挨着排列的)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%EF%BC%89%E3%80%81%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E7%BB%84%E9%83%BD%E6%98%AF%E6%8B%BF%E2%80%9D%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%96%B9%E6%A1%86%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E2%80%9D%E4%BD%9C%E4%B8%BA%E6%95%B4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E3%80%82"><span class="toc-number">3.1.11.</span> <span class="toc-text">11）、所有的数组都是拿”第一个小方框的内存地址”作为整个数组对象的内存地址。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%EF%BC%89%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E9%83%BD%E6%98%AF%E6%9C%89%E4%B8%8B%E6%A0%87%E7%9A%84%EF%BC%8C%E4%B8%8B%E6%A0%87%E4%BB%8E0%E5%BC%80%E5%A7%8B%EF%BC%8C%E4%BB%A5%E4%B8%80%E9%80%92%E5%A2%9E%EF%BC%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%B8%8B%E6%A0%87%E6%98%AF-length-1"><span class="toc-number">3.1.12.</span> <span class="toc-text">12）、数组中每一个元素都是有下标的，下标从0开始，以一递增，最后一个下标是[length-1]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%EF%BC%89%E3%80%81%E6%95%B0%E7%BB%84%E8%BF%99%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.1.13.</span> <span class="toc-text">13）、数组这种数据结构的优点和缺点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%EF%BC%89%E3%80%81%E6%80%8E%E4%B9%88%E5%A3%B0%E6%98%8E-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="toc-number">3.1.14.</span> <span class="toc-text">14）、怎么声明&#x2F;定义一个一维数组？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%EF%BC%89%E3%80%81%E6%80%8E%E4%B9%88%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%91%A2%EF%BC%9F"><span class="toc-number">3.1.15.</span> <span class="toc-text">15）、怎么初始化一个一维数组呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%EF%BC%89%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%87%E7%94%A8%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%87%E7%94%A8%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">3.1.16.</span> <span class="toc-text">16）、什么时候采用静态初始化的方式，什么时候采用动态初始化方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%EF%BC%89%E3%80%81%E5%BD%93%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E4%B8%8A%EF%BC%8C%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%98%AF%E6%95%B0%E7%BB%84%E7%9A%84%E6%97%B6%E5%80%99%E3%80%82"><span class="toc-number">3.1.17.</span> <span class="toc-text">17）、当一个方法上，参数类型是数组的时候。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%EF%BC%89%E3%80%81%E5%BD%93%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E6%95%B0%E7%BB%84%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%98%E5%8F%AF%E4%BB%A5%E9%87%87%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%BC%A0"><span class="toc-number">3.1.18.</span> <span class="toc-text">18）、当一个方法的参数是数组的时候，我们还可以采用这种方式传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%EF%BC%89%E3%80%81-main%E6%96%B9%E6%B3%95%E4%B8%8A%E9%9D%A2%E7%9A%84%E2%80%9DString-args%E2%80%9D%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">3.1.19.</span> <span class="toc-text">19）、 main方法上面的”String[] args”有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%EF%BC%89%E3%80%81-%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%81%87%E8%AE%BE%E8%BF%99%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%A6%81%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%BF%85%E9%A1%BB%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81"><span class="toc-number">3.1.20.</span> <span class="toc-text">20）、 模拟一个系统，假设这个系统要使用，必须输入用户名和密码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%EF%BC%89%E3%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%B1%E5%85%A5%EF%BC%8C%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%BA%EF%BC%9A%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.21.</span> <span class="toc-text">21）、一维数组的深入，数组中存储的类型为：引用数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%EF%BC%89%E3%80%81%E5%85%B3%E4%BA%8E%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%AE%B9%E3%80%82"><span class="toc-number">3.1.22.</span> <span class="toc-text">22）、关于一维数组的扩容。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%85%B3%E4%BA%8Ejava%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">3.2.</span> <span class="toc-text">2、关于java语言中的二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%8C%E7%89%B9%E6%AE%8A%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%BD%93%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E3%80%82"><span class="toc-number">3.2.1.</span> <span class="toc-text">1）、二维数组其实是一个特殊的一维数组，特殊在这个一维数组当中的每一个元素是一个一维数组。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81%E4%B8%89%E7%BB%B4%E6%95%B0%E7%BB%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.2.2.</span> <span class="toc-text">2）、三维数组是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.2.3.</span> <span class="toc-text">3）、二维数组静态初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%85%B3%E4%BA%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E8%AF%BB%E5%92%8C%E6%94%B9"><span class="toc-number">3.3.</span> <span class="toc-text">3、关于二维数组中元素的读和改:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%85%B3%E4%BA%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">3.4.</span> <span class="toc-text">4、关于二维数组的遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">四、常见算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">1、冒泡排序算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="toc-number">4.2.</span> <span class="toc-text">2、选择排序：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%83%E7%B4%A0%E6%9F%A5%E6%89%BE%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.3.</span> <span class="toc-text">3、数组的元素查找有两种方式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%85%B3%E4%BA%8E%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%EF%BC%9A"><span class="toc-number">4.4.</span> <span class="toc-text">4、关于查找算法中的二分法查找：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">4.5.</span> <span class="toc-text">5、Arrays工具类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81JDK%E4%B8%AD%E5%86%85%E7%BD%AE%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">五、JDK中内置的常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%85%B3%E4%BA%8Ejava-JDK%E4%B8%AD%E5%86%85%E7%BD%AE%E7%9A%84%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%9Ajava-lang-String%EF%BC%9A"><span class="toc-number">5.1.</span> <span class="toc-text">1、关于java JDK中内置的一个类：java.lang.String：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81String%E8%A1%A8%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%B1%9E%E4%BA%8E%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%8D%E5%B1%9E%E4%BA%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">1）、String表示字符串，属于引用数据类型，不属于基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81%E5%9C%A8java%E4%B8%AD%E9%9A%8F%E4%BE%BF%E4%BD%BF%E7%94%A8%E5%8F%8C%E5%BC%95%E5%8F%B7%E6%8B%AC%E8%B5%B7%E6%9D%A5%E7%9A%84%E9%83%BD%E6%98%AFString%E5%AF%B9%E8%B1%A1%EF%BC%9B%E4%BE%8B%E5%A6%82%EF%BC%9A%E2%80%9Dabc%E2%80%9D-%E2%80%9Cdef%E2%80%9D-%E2%80%9CHelloWorld%E2%80%9D-%E8%BF%99%E6%98%AF3%E4%B8%AAString%E5%AF%B9%E8%B1%A1%E3%80%82"><span class="toc-number">5.1.2.</span> <span class="toc-text">2）、在java中随便使用双引号括起来的都是String对象；例如：”abc”, “def”, “HelloWorld”, 这是3个String对象。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E3%80%81java%E4%B8%AD%E8%A7%84%E5%AE%9A%EF%BC%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E6%8B%AC%E8%B5%B7%E6%9D%A5%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E2%80%9Dabc%E2%80%9D%E8%87%AA%E5%87%BA%E7%94%9F%E5%88%B0%E6%B6%88%E9%80%9D%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%8C%E4%B8%8D%E8%83%BD%E5%8F%98%E6%88%90%E2%80%9Dabcd%E2%80%9D%EF%BC%8C%E4%B9%9F%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%88%90%E2%80%9Dab%E2%80%9D%E3%80%82"><span class="toc-number">5.1.3.</span> <span class="toc-text">3）、java中规定，双引号括起来的字符串是不可变的，也就是说”abc”自出生到消逝不可变，不能变成”abcd”，也不可变成”ab”。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E3%80%81%E5%9C%A8JDK%E5%BD%93%E4%B8%AD%E5%8F%8C%E5%BC%95%E5%8F%B7%E6%8B%AC%E8%B5%B7%E6%9D%A5%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E4%BE%8B%E5%A6%82%EF%BC%9A%E2%80%9Dabc%E2%80%9D-%E2%80%9Cdef%E2%80%9D%E9%83%BD%E6%98%AF%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%9C%A8%E2%80%9C%E6%96%B9%E6%B3%95%E5%8C%BA%E2%80%9D%E7%9A%84%E2%80%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E2%80%9D%E5%BD%93%E4%B8%AD%E7%9A%84%E3%80%82"><span class="toc-number">5.1.4.</span> <span class="toc-text">4）、在JDK当中双引号括起来的字符串，例如：”abc”, “def”都是直接存储在“方法区”的“字符串常量池”当中的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E3%80%81%E6%8E%A5%E4%B8%8A%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="toc-number">5.1.5.</span> <span class="toc-text">5）、接上举例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89%E3%80%81%E5%85%B3%E4%BA%8EString%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.6.</span> <span class="toc-text">6）、关于String类中的构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%BC%89%E3%80%81%E5%85%B3%E4%BA%8EString%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.7.</span> <span class="toc-text">7）、关于String类中的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%EF%BC%89%E3%80%81%E5%85%B3%E4%BA%8EJdk%E4%B8%AD%E7%9A%84StringBuffer"><span class="toc-number">5.1.8.</span> <span class="toc-text">8）、关于Jdk中的StringBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%EF%BC%89%E3%80%81java-lang-StringBuilder"><span class="toc-number">5.1.9.</span> <span class="toc-text">9）、java.lang.StringBuilder</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%85%AB%E7%A7%8D%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">2、八种包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81java%E4%B8%AD%E4%B8%BA8%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%88%E5%87%86%E5%A4%87%E4%BA%868%E7%A7%8D%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E3%80%828%E4%B8%AD%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%B1%9E%E4%BA%8E%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E7%88%B6%E7%B1%BB%E6%98%AFObject%E3%80%82"><span class="toc-number">5.2.1.</span> <span class="toc-text">1）、java中为8种基本数据类型又准备了8种包装类型。8中包装类型属于引用数据类型，父类是Object。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81%E6%80%9D%E8%80%83%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%8D%E6%8F%90%E4%BE%9B8%E7%A7%8D%E5%8C%85%E8%A3%85%E7%B1%BB%E5%91%A2%EF%BC%9F"><span class="toc-number">5.2.2.</span> <span class="toc-text">2）、思考：为什么要再提供8种包装类呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E3%80%818%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%90%8D%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.2.3.</span> <span class="toc-text">3）、8种基本数据类型对应的包装类名是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E3%80%81%E4%BB%A5%E4%B8%8A%E5%85%AB%E7%A7%8D%E5%8C%85%E8%A3%85%E7%B1%BB%E7%A7%8D%EF%BC%8C%E9%87%8D%E7%82%B9%E4%BB%A5java-lang-Integer%E4%B8%BA%E4%BB%A3%E8%A1%A8%E8%BF%9B%E8%A1%8C%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%85%A7%E8%91%AB%E8%8A%A6%E7%94%BB%E7%93%A2%E3%80%82"><span class="toc-number">5.2.4.</span> <span class="toc-text">4）、以上八种包装类种，重点以java.lang.Integer为代表进行学习，其他的类型照葫芦画瓢。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E3%80%81%E5%85%AB%E7%A7%8D%E5%8C%85%E8%A3%85%E7%B1%BB%E5%85%B6%E4%B8%AD6%E4%B8%AA%E9%83%BD%E6%98%AF%E6%95%B0%E5%AD%97%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%8C%E4%BB%96%E4%BB%AC%E7%9A%84%E7%88%B6%E7%B1%BB%E9%83%BD%E6%98%AFNumber%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8BNumber%E4%B8%AD%E5%85%AC%E5%85%B1%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9B"><span class="toc-number">5.2.5.</span> <span class="toc-text">5）、八种包装类其中6个都是数字对应的包装类，他们的父类都是Number，可以研究一下Number中公共的方法；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%BC%89%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E4%B9%8B%E5%89%8D%E6%89%80%E5%AD%A6%E7%9A%84%E7%BB%8F%E5%85%B8%E5%BC%82%E5%B8%B8%EF%BC%9A"><span class="toc-number">5.2.6.</span> <span class="toc-text">7）、总结一下之前所学的经典异常：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%EF%BC%89%E3%80%81java%E4%B8%AD%E5%AF%B9%E6%97%B6%E9%97%B4%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">5.2.7.</span> <span class="toc-text">8）、java中对时间的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%EF%BC%89%E3%80%81%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%97%B6%E9%95%BF"><span class="toc-number">5.2.8.</span> <span class="toc-text">9）、统计方法执行时长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%EF%BC%89%E3%80%81%E9%80%9A%E8%BF%87%E6%AF%AB%E7%A7%92%E6%9E%84%E9%80%A0Date%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.2.9.</span> <span class="toc-text">10）、通过毫秒构造Date对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%9E%9A%E4%B8%BE"><span class="toc-number">6.</span> <span class="toc-text">六、枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%BC%82%E5%B8%B8"><span class="toc-number">7.</span> <span class="toc-text">七、异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E5%B8%B8%EF%BC%8Cjava%E6%8F%90%E4%BE%9B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">1、什么是异常，java提供异常处理机制有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81java%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%BC%82%E5%B8%B8%E6%98%AF%E4%BB%A5%E4%BB%80%E4%B9%88%E5%BD%A2%E5%BC%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">2、java语言中异常是以什么形式存在的呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81java%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">7.3.</span> <span class="toc-text">3、java的异常处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFUML%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">7.3.1.</span> <span class="toc-text">1）、什么是UML？有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81%E5%BC%82%E5%B8%B8%E5%9C%A8java%E4%B8%AD%E4%BB%A5%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%AD%98%E5%9C%A8%EF%BC%8C%E9%82%A3%E4%B9%88%E5%BC%82%E5%B8%B8%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">7.3.2.</span> <span class="toc-text">2）、异常在java中以类和对象的形式存在，那么异常的继承结构是怎样的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a%EF%BC%89%E3%80%81Object"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">a）、Object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b%EF%BC%89%E3%80%81%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E9%83%BD%E6%98%AF%E5%8F%91%E7%94%9F%E5%9C%A8%E8%BF%90%E8%A1%8C%E9%98%B6%E6%AE%B5%EF%BC%8C%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E5%AE%9C%E6%98%8C%E5%B8%82%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E7%9A%84%E3%80%82"><span class="toc-number">7.3.2.2.</span> <span class="toc-text">b）、编译时异常和运行时异常都是发生在运行阶段，编译阶段宜昌市不会发生的。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c%EF%BC%89%E3%80%81%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%E5%9B%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%80%8C%E5%BE%97%E5%90%8D%EF%BC%9F"><span class="toc-number">7.3.2.3.</span> <span class="toc-text">c）、编译时异常因为什么而得名？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d%EF%BC%89%E3%80%81%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.3.2.4.</span> <span class="toc-text">d）、编译时异常和运行时异常的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e%EF%BC%89%E3%80%81Java%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AF%B9%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E5%8C%85%E6%8B%AC%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">7.3.2.5.</span> <span class="toc-text">e）、Java语言中对异常的处理包括两种方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#f%EF%BC%89%E3%80%81%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E6%8A%A5%E9%94%99%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.3.2.6.</span> <span class="toc-text">f）、以下代码报错的原因是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E3%80%81%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">7.3.3.</span> <span class="toc-text">3）、异常的处理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E3%80%81%E6%B7%B1%E5%85%A5try%E2%80%A6catch"><span class="toc-number">7.3.4.</span> <span class="toc-text">4）、深入try…catch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a%EF%BC%89%E3%80%81catch%E5%90%8E%E9%9D%A2%E7%9A%84%E5%B0%8F%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%85%B7%E4%BD%93%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%98%AF%E8%AF%A5%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%88%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.3.4.1.</span> <span class="toc-text">a）、catch后面的小括号中的类型可以是具体的异常类型，也可以是该异常类型的父类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b%EF%BC%89%E3%80%81catch%E5%8F%AF%E4%BB%A5%E5%86%99%E5%A4%9A%E4%B8%AA%EF%BC%9B%E5%BB%BA%E8%AE%AEcatch%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%B2%BE%E7%A1%AE%E5%9C%B0%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E5%A4%84%E7%90%86%E3%80%82%E8%BF%99%E6%A0%B7%E5%88%A9%E4%BA%8E%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E3%80%82"><span class="toc-number">7.3.4.2.</span> <span class="toc-text">b）、catch可以写多个；建议catch的时候，精确地一个一个处理。这样利于程序调试。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c%EF%BC%89%E3%80%81catch%E5%BF%85%E9%A1%BB%E9%81%B5%E5%BE%AA%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%E7%9A%84%E5%8E%9F%E5%88%99%E3%80%82"><span class="toc-number">7.3.4.3.</span> <span class="toc-text">c）、catch必须遵循从小到大的原则。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d%EF%BC%89%E3%80%81%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E5%A4%84%E7%90%86%E7%BC%96%E8%AF%91%E5%BC%82%E5%B8%B8%E6%97%B6%EF%BC%8C%E5%BA%94%E8%AF%A5%E4%B8%8A%E6%8A%A5%E8%BF%98%E6%98%AF%E6%8D%95%E6%8D%89%E5%91%A2%EF%BC%8C%E6%80%8E%E4%B9%88%E9%80%89%EF%BC%9F"><span class="toc-number">7.3.4.4.</span> <span class="toc-text">d）、在开发中，处理编译异常时，应该上报还是捕捉呢，怎么选？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E3%80%81%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">7.3.5.</span> <span class="toc-text">5）、异常对象有两个重要的方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89%E3%80%81%E5%85%B3%E4%BA%8Etry-catch%E4%B8%AD%E7%9A%84finally%E5%AD%90%E5%8F%A5%EF%BC%9A"><span class="toc-number">7.3.6.</span> <span class="toc-text">6）、关于try..catch中的finally子句：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a%EF%BC%89%E3%80%81%E5%9C%A8finally%E5%AD%90%E5%8F%A5%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%AF%E6%9C%80%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%98%AF%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%8C%E5%8D%B3%E4%BD%BFtry%E8%AF%AD%E5%8F%A5%E5%9D%97%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%87%BA%E7%8E%B0%E4%BA%86%E5%BC%82%E5%B8%B8%E3%80%82"><span class="toc-number">7.3.6.1.</span> <span class="toc-text">a）、在finally子句中的代码是最后执行的，并且是一定会执行的，即使try语句块中的代码出现了异常。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b%EF%BC%89%E3%80%81finally%E8%AF%AD%E5%8F%A5%E9%80%9A%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E5%91%A2%EF%BC%9F"><span class="toc-number">7.3.6.2.</span> <span class="toc-text">b）、finally语句通常使用在哪些情况下呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%BC%89%E3%80%81finally%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.3.7.</span> <span class="toc-text">7）、finally语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%EF%BC%89%E3%80%81java%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99%EF%BC%88%E6%9C%89%E4%BA%9B%E8%A7%84%E5%88%99%E6%98%AF%E4%B8%8D%E8%83%BD%E7%A0%B4%E5%9D%8F%E7%9A%84%EF%BC%8C%E4%B8%80%E6%97%A6%E8%BF%99%E4%B9%88%E8%AF%B4%E4%BA%86%EF%BC%8C%E5%B0%B1%E5%BF%85%E9%A1%BB%E8%BF%99%E4%B9%88%E5%81%9A%EF%BC%81%EF%BC%89"><span class="toc-number">7.3.8.</span> <span class="toc-text">8）、java语法规则（有些规则是不能破坏的，一旦这么说了，就必须这么做！）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%EF%BC%89%E3%80%81final-finally-finalize%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.3.9.</span> <span class="toc-text">9）、final finally finalize有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%EF%BC%89%E3%80%81%E5%BC%82%E5%B8%B8%E5%9C%A8%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">7.3.10.</span> <span class="toc-text">10）、异常在实际开发中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a%EF%BC%89%E3%80%81SUN%E6%8F%90%E4%BE%9B%E7%9A%84JDK%E5%86%85%E7%BD%AE%E7%9A%84%E5%BC%82%E5%B8%B8%E8%82%AF%E5%AE%9A%E6%98%AF%E4%B8%8D%E5%A4%9F%E7%94%A8%E7%9A%84%EF%BC%8C%E5%9C%A8%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%BE%88%E5%A4%9A%E4%B8%9A%E5%8A%A1%EF%BC%8C"><span class="toc-number">7.3.10.1.</span> <span class="toc-text">a）、SUN提供的JDK内置的异常肯定是不够用的，在实际开发中，有很多业务，</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b%EF%BC%89%E3%80%81Java%E4%B8%AD%E6%80%8E%E4%B9%88%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%91%A2%EF%BC%9F"><span class="toc-number">7.3.10.2.</span> <span class="toc-text">b）、Java中怎么自定义异常呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%EF%BC%89%E3%80%81%E4%B9%8B%E5%89%8D%E5%9C%A8%E8%AE%B2%E8%A7%A3%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%BD%93%E6%97%B6%E9%81%97%E7%95%99%E4%BA%86%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">7.3.11.</span> <span class="toc-text">11）、之前在讲解方法覆盖的时候，当时遗留了一个问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%EF%BC%89%E3%80%81%E5%BC%82%E5%B8%B8%E5%BA%94%E7%94%A8%E4%B8%80"><span class="toc-number">7.3.12.</span> <span class="toc-text">12）、异常应用一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%EF%BC%89%E3%80%81%E5%BC%82%E5%B8%B8%E5%BA%94%E7%94%A8%E4%BA%8C%EF%BC%9A"><span class="toc-number">7.3.13.</span> <span class="toc-text">13）、异常应用二：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E9%9B%86%E5%90%88"><span class="toc-number">8.</span> <span class="toc-text">八、集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="toc-number">8.1.</span> <span class="toc-text">1、集合概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E5%90%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">8.1.1.</span> <span class="toc-text">1）、什么是集合？有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%8F%A6%E5%A4%96%E9%9B%86%E5%90%88%E4%B9%9F%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8java%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%9B%86%E5%90%88%E5%BD%93%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E9%83%BD%E6%98%AFjava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E3%80%82-%E6%88%96%E8%80%85%E8%AF%B4%E9%9B%86%E5%90%88%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%98%AF%E5%BC%95%E7%94%A8%E3%80%82"><span class="toc-number">8.1.2.</span> <span class="toc-text">2）、集合不能直接存储基本数据类型，另外集合也不能直接存储java对象，集合当中存储的都是java对象的内存地址。(或者说集合中存储的是引用。)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E3%80%81%E5%9C%A8java%E4%B8%AD%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E9%9B%86%E5%90%88%EF%BC%8C%E5%BA%95%E5%B1%82%E4%BC%9A%E5%AF%B9%E5%BA%94%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%BE%80%E4%B8%8D%E5%90%8C%E7%9A%84%E9%9B%86%E5%90%88%E4%B8%AD%E5%AD%98%E5%82%A8%E5%85%83%E7%B4%A0%EF%BC%8C%E7%AD%89%E4%BA%8E%E5%B0%86%E6%95%B0%E6%8D%AE%E6%94%BE%E5%88%B0%E4%BA%86%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BD%93%E4%B8%AD%E3%80%82"><span class="toc-number">8.1.3.</span> <span class="toc-text">3）、在java中每一个不同的集合，底层会对应不同的数据结构，往不同的集合中存储元素，等于将数据放到了不同的数据结构当中。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E3%80%81%E9%9B%86%E5%90%88%E5%9C%A8java-JDK%E4%B8%AD%E5%93%AA%E4%B8%AA%E5%8C%85%E4%B8%8B%EF%BC%9F"><span class="toc-number">8.1.4.</span> <span class="toc-text">4）、集合在java JDK中哪个包下？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E3%80%81%E4%B8%BA%E4%BA%86%E8%AE%A9%E5%A4%A7%E5%AE%B6%E6%8E%8C%E6%8F%A1%E9%9B%86%E5%90%88%E8%BF%99%E5%9D%97%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E6%9C%80%E5%A5%BD%E8%83%BD%E5%B0%86%E9%9B%86%E5%90%88%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE%E8%83%8C%E4%BC%9A%EF%BC%81%EF%BC%81%EF%BC%81"><span class="toc-number">8.1.5.</span> <span class="toc-text">5）、为了让大家掌握集合这块的内容，最好能将集合的继承结构图背会！！！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89%E3%80%81%E5%9C%A8Java%E4%B8%AD%E9%9B%86%E5%90%88%E5%88%86%E4%B8%BA%E4%B8%A4%E5%A4%A7%E7%B1%BB%EF%BC%9A"><span class="toc-number">8.1.6.</span> <span class="toc-text">6）、在Java中集合分为两大类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%BC%89%E3%80%81%E6%80%BB%E7%BB%93-%E6%89%80%E6%9C%89%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB-%EF%BC%9A"><span class="toc-number">8.1.7.</span> <span class="toc-text">7）、总结(所有的实现类)：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%85%B3%E4%BA%8Ejava-util-Collection%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">8.2.</span> <span class="toc-text">2、关于java.util.Collection接口中常用的方法。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81Collection%E4%B8%AD%E8%83%BD%E5%AD%98%E6%94%BE%E4%BB%80%E4%B9%88%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="toc-number">8.2.1.</span> <span class="toc-text">1）、Collection中能存放什么元素？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81Collection%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.2.</span> <span class="toc-text">2）、Collection中的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E3%80%81%E5%85%B3%E4%BA%8E%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86-%E8%BF%AD%E4%BB%A3%E4%B8%93%E9%A2%98%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%9A%E4%BA%94%E9%A2%97%E6%98%9F-%EF%BC%89"><span class="toc-number">8.2.3.</span> <span class="toc-text">3）、关于集合遍历&#x2F;迭代专题（重点：五颗星*****）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E3%80%81%E6%B7%B1%E5%85%A5Collection%E9%9B%86%E5%90%88%E7%9A%84contains%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">8.2.4.</span> <span class="toc-text">4）、深入Collection集合的contains方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E3%80%81%E6%B5%8B%E8%AF%95contains%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.5.</span> <span class="toc-text">5）、测试contains方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89%E3%80%81%E5%85%B3%E4%BA%8E%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E7%9A%84remove"><span class="toc-number">8.2.6.</span> <span class="toc-text">6）、关于集合元素的remove</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81List%E9%9B%86%E5%90%88"><span class="toc-number">8.3.</span> <span class="toc-text">3、List集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81List%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E5%85%83%E7%B4%A0%E7%89%B9%E7%82%B9%EF%BC%9A%E6%9C%89%E5%BA%8F%E5%8F%AF%E9%87%8D%E5%A4%8D"><span class="toc-number">8.3.1.</span> <span class="toc-text">1）、List集合存储元素特点：有序可重复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81List%E6%97%A2%E7%84%B6%E6%98%AFCollection%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AD%90%E6%8E%A5%E5%8F%A3%EF%BC%8C%E9%82%A3%E4%B9%88%E8%82%AF%E5%AE%9AList%E6%8E%A5%E5%8F%A3%E6%9C%89%E8%87%AA%E5%B7%B1%E2%80%9C%E7%89%B9%E8%89%B2%E2%80%9D%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9B"><span class="toc-number">8.3.2.</span> <span class="toc-text">2）、List既然是Collection接口的子接口，那么肯定List接口有自己“特色”的方法；</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%B8%BB%E8%A6%81%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">8.4.</span> <span class="toc-text">4、主要的集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81ArrayList%E9%9B%86%E5%90%88%EF%BC%9A"><span class="toc-number">8.4.1.</span> <span class="toc-text">1）、ArrayList集合：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a%EF%BC%89%E3%80%81%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F10-%E5%BA%95%E5%B1%82%E5%85%88%E5%88%9B%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E9%95%BF%E5%BA%A6%E4%B8%BA0%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%8C%E5%BD%93%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F10"><span class="toc-number">8.4.1.1.</span> <span class="toc-text">a）、默认初始化容量10(底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量10)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b%EF%BC%89%E3%80%81%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E6%98%AF%E4%B8%80%E4%B8%AAObject-%E6%95%B0%E7%BB%84"><span class="toc-number">8.4.1.2.</span> <span class="toc-text">b）、集合底层是一个Object[]数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c%EF%BC%89%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">8.4.1.3.</span> <span class="toc-text">c）、构造方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d%EF%BC%89%E3%80%81ArrayList%E9%9B%86%E5%90%88%E7%9A%84%E6%89%A9%E5%AE%B9%EF%BC%9A"><span class="toc-number">8.4.1.4.</span> <span class="toc-text">d）、ArrayList集合的扩容：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e%EF%BC%89%E3%80%81%E6%95%B0%E7%BB%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">8.4.1.5.</span> <span class="toc-text">e）、数组优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#f%EF%BC%89%E3%80%81%E6%95%B0%E7%BB%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">8.4.1.6.</span> <span class="toc-text">f）、数组缺点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#g%EF%BC%89%E3%80%81%E5%90%91%E6%95%B0%E7%BB%84%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%EF%BC%8C%E6%95%88%E7%8E%87%E5%BE%88%E9%AB%98%EF%BC%8C%E4%B8%8D%E5%8F%97%E5%BD%B1%E5%93%8D%E3%80%82"><span class="toc-number">8.4.1.7.</span> <span class="toc-text">g）、向数组末尾添加元素，效率很高，不受影响。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#h%EF%BC%89%E3%80%81%E8%BF%99%E4%B9%88%E5%A4%9A%E7%9A%84%E9%9B%86%E5%90%88%EF%BC%8C%E4%BD%BF%E7%94%A8%E9%82%A3%E4%B8%AA%E9%9B%86%E5%90%88%E6%9C%80%E5%A4%9A%EF%BC%9F"><span class="toc-number">8.4.1.8.</span> <span class="toc-text">h）、这么多的集合，使用那个集合最多？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i%EF%BC%89%E3%80%81ArrayList%E9%9B%86%E5%90%88%E6%98%AF%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E3%80%82-%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">8.4.1.9.</span> <span class="toc-text">i）、ArrayList集合是非线程安全的集合。(不是线程安全的集合)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#j%EF%BC%89%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6-gt-gt-lt-lt"><span class="toc-number">8.4.1.10.</span> <span class="toc-text">j）、位运算符 &gt;&gt; &lt;&lt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#k%EF%BC%89%E3%80%81%E9%9B%86%E5%90%88ArrayList%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">8.4.1.11.</span> <span class="toc-text">k）、集合ArrayList的构造方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81%E9%93%BE%E8%A1%A8%E7%B1%BB%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">8.4.2.</span> <span class="toc-text">2）、链表类（单向链表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E3%80%81Vector"><span class="toc-number">8.4.3.</span> <span class="toc-text">3）、Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a%EF%BC%89%E3%80%81%E5%BA%95%E5%B1%82%E4%B9%9F%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="toc-number">8.4.3.1.</span> <span class="toc-text">a）、底层也是一个数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b%EF%BC%89%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F%EF%BC%9A10"><span class="toc-number">8.4.3.2.</span> <span class="toc-text">b）、初始化容量：10</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c%EF%BC%89%E3%80%81%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9%E7%9A%84%EF%BC%9F"><span class="toc-number">8.4.3.3.</span> <span class="toc-text">c）、怎么扩容的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d%EF%BC%89%E3%80%81ArrayList%E9%9B%86%E5%90%88%E6%89%A9%E5%AE%B9%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">8.4.3.4.</span> <span class="toc-text">d）、ArrayList集合扩容特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e%EF%BC%89%E3%80%81Vector%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95%E9%83%BD%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%EF%BC%8C%E9%83%BD%E5%B8%A6%E6%9C%89synchronized%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%8C%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83%E4%BD%8E%EF%BC%8C%E7%94%A8%E7%9A%84%E6%AF%94%E8%BE%83%E5%B0%91"><span class="toc-number">8.4.3.5.</span> <span class="toc-text">e）、Vector中所有的方法都是线程同步的，都带有synchronized关键字，是线程安全的，效率比较低，用的比较少</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#h%EF%BC%89%E3%80%81%E6%80%8E%E4%B9%88%E5%B0%86%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84ArrayList%E9%9B%86%E5%90%88%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">8.4.3.6.</span> <span class="toc-text">h）、怎么将一个线程不安全的ArrayList集合转换成线程安全的呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E3%80%81HashSet%E9%9B%86%E5%90%88"><span class="toc-number">8.4.4.</span> <span class="toc-text">4）、HashSet集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E3%80%81TreeSet%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89"><span class="toc-number">8.4.5.</span> <span class="toc-text">5）、TreeSet集合（一）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89%E3%80%81Map%E9%9B%86%E5%90%88"><span class="toc-number">8.4.6.</span> <span class="toc-text">6）、Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a%EF%BC%89%E3%80%81Map%E5%92%8CCollection%E6%B2%A1%E6%9C%89%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">8.4.6.1.</span> <span class="toc-text">a）、Map和Collection没有继承关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b%EF%BC%89%E3%80%81Map%E9%9B%86%E5%90%88%E4%BB%A5key%E5%92%8Cvalue%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%EF%BC%9A%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-number">8.4.6.2.</span> <span class="toc-text">b）、Map集合以key和value的方式存储数据：键值对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c%EF%BC%89%E3%80%81Map%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">8.4.6.3.</span> <span class="toc-text">c）、Map接口中常用方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d%EF%BC%89%E3%80%81%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">8.4.6.4.</span> <span class="toc-text">d）、静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e%EF%BC%89%E3%80%81Map%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86%E3%80%90%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%E3%80%91"><span class="toc-number">8.4.6.5.</span> <span class="toc-text">e）、Map集合的遍历【非常重要】</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%BC%89%E3%80%81HashMap%E9%9B%86%E5%90%88"><span class="toc-number">8.4.7.</span> <span class="toc-text">7）、HashMap集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a%EF%BC%89%E3%80%81HashMap%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E6%98%AF%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">8.4.7.1.</span> <span class="toc-text">a）、HashMap集合底层是哈希表&#x2F;散列表的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b%EF%BC%89%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E6%98%AF%E4%B8%80%E4%B8%AA%E6%80%8E%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%91%A2%EF%BC%9F"><span class="toc-number">8.4.7.2.</span> <span class="toc-text">b）、哈希表是一个怎样的数据结构呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c%EF%BC%89%E3%80%81HashMap%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">8.4.7.3.</span> <span class="toc-text">c）、HashMap集合底层的源代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d%EF%BC%89%E3%80%81%E6%9C%80%E4%B8%BB%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%98%AF%EF%BC%9A"><span class="toc-number">8.4.7.4.</span> <span class="toc-text">d）、最主要掌握的是：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e%EF%BC%89%E3%80%81HashMap%E9%9B%86%E5%90%88%E7%9A%84key%E9%83%A8%E5%88%86%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">8.4.7.5.</span> <span class="toc-text">e）、HashMap集合的key部分特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#f%EF%BC%89%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8HashMap%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E6%97%B6%E6%97%A0%E6%B3%95%E5%8F%91%E6%8C%A5%E6%80%A7%E8%83%BD%EF%BC%81"><span class="toc-number">8.4.7.6.</span> <span class="toc-text">f）、哈希表HashMap使用不当时无法发挥性能！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#g%EF%BC%89%E3%80%81%E9%87%8D%E7%82%B9%EF%BC%9A%E6%94%BE%E5%9C%A8HashMap%E9%9B%86%E5%90%88key%E9%83%A8%E5%88%86%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%94%BE%E5%9C%A8HashSet%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E9%9C%80%E8%A6%81%E5%90%8C%E6%97%B6%E9%87%8D%E5%86%99hashCode-%E5%92%8Cequals-%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">8.4.7.7.</span> <span class="toc-text">g）、重点：放在HashMap集合key部分的元素，以及放在HashSet集合中的元素需要同时重写hashCode()和equals()方法。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#h%EF%BC%89%E3%80%81HashMap%E9%9B%86%E5%90%88%E7%9A%84%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F%E6%97%B616%EF%BC%8C%E9%BB%98%E8%AE%A4%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%E6%98%AF0-75"><span class="toc-number">8.4.7.8.</span> <span class="toc-text">h）、HashMap集合的默认初始化容量时16，默认加载因子是0.75</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i%EF%BC%89%E3%80%81%E5%90%91Map%E9%9B%86%E5%90%88%E4%B8%AD%E5%AD%98%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BB%8EMap%E9%9B%86%E5%90%88%E4%B8%AD%E5%8F%96%EF%BC%8C%E9%83%BD%E6%98%AF%E5%85%88%E8%B0%83%E7%94%A8key%E7%9A%84hashCode%E6%96%B9%E6%B3%95%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E8%B0%83%E7%94%A8equals%E6%96%B9%E6%B3%95%EF%BC%81"><span class="toc-number">8.4.7.9.</span> <span class="toc-text">i）、向Map集合中存，以及从Map集合中取，都是先调用key的hashCode方法，然后再调用equals方法！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#j%EF%BC%89%E3%80%81%E6%B3%A8%E6%84%8F%EF%BC%9A%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84equals-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E4%BA%86%EF%BC%8C%E9%82%A3%E4%B9%88hashCode-%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99%EF%BC%9B"><span class="toc-number">8.4.7.10.</span> <span class="toc-text">j）、注意：如果一个类的equals()方法重写了，那么hashCode()方法必须重写；</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#k%EF%BC%89%E3%80%81hashCode-%E6%96%B9%E6%B3%95%E5%92%8Cequals-%E6%96%B9%E6%B3%95%E4%B8%8D%E7%94%A8%E7%A0%94%E7%A9%B6%E4%BA%86%EF%BC%8C%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8IDEA%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E5%90%8C%E6%97%B6%E7%94%9F%E6%88%90%E3%80%82"><span class="toc-number">8.4.7.11.</span> <span class="toc-text">k）、hashCode()方法和equals()方法不用研究了，直接使用IDEA工具生成，但是这两个方法需要同时生成。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#l%EF%BC%89%E3%80%81%E7%BB%88%E6%9E%81%E7%BB%93%E8%AE%BA%EF%BC%9A"><span class="toc-number">8.4.7.12.</span> <span class="toc-text">l）、终极结论：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#m%EF%BC%89%E3%80%81%E5%9C%A8JDK8%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%93%88%E5%B8%8C%E8%A1%A8%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%85%83%E7%B4%A0%E8%B6%85%E8%BF%878%E4%B8%AA%EF%BC%8C%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E8%BF%99%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%9A%E5%8F%98%E6%88%90%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9B"><span class="toc-number">8.4.7.13.</span> <span class="toc-text">m）、在JDK8之后，如果哈希表单向链表中元素超过8个，单向链表这种数据结构会变成红黑树数据结构；</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#n%EF%BC%89%E3%80%81HashMap%E9%9B%86%E5%90%88key%E9%83%A8%E5%88%86%E5%8F%AF%E4%BB%A5%E5%85%81%E8%AE%B8null%E5%90%97%EF%BC%9F"><span class="toc-number">8.4.7.14.</span> <span class="toc-text">n）、HashMap集合key部分可以允许null吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#o%EF%BC%89%E3%80%81Hashtable%E7%9A%84key%E5%8F%AF%E4%BB%A5%E4%B8%BAnull%E5%90%97%EF%BC%9F"><span class="toc-number">8.4.7.15.</span> <span class="toc-text">o）、Hashtable的key可以为null吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#p%EF%BC%89%E3%80%81Properties%E5%B1%9E%E6%80%A7%E7%B1%BB"><span class="toc-number">8.4.7.16.</span> <span class="toc-text">p）、Properties属性类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%EF%BC%89%E3%80%81TreeSet%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="toc-number">8.4.8.</span> <span class="toc-text">8）、TreeSet集合（二）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a%EF%BC%89%E3%80%81TreeSet%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AF%E4%B8%80%E4%B8%AATreeMap"><span class="toc-number">8.4.8.1.</span> <span class="toc-text">a）、TreeSet集合底层实际上是一个TreeMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b%EF%BC%89%E3%80%81TreeMap%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.4.8.2.</span> <span class="toc-text">b）、TreeMap集合底层是一个二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c%EF%BC%89%E3%80%81%E6%94%BE%E5%88%B0TreeSet%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E7%AD%89%E5%90%8C%E4%BA%8E%E6%94%BE%E5%88%B0TreeMap%E9%9B%86%E5%90%88key%E9%83%A8%E5%88%86%E3%80%82"><span class="toc-number">8.4.8.3.</span> <span class="toc-text">c）、放到TreeSet集合中的元素，等同于放到TreeMap集合key部分。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d%EF%BC%89%E3%80%81TreeSet%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%9A%E6%97%A0%E5%BA%8F%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%AF%E4%BB%A5%E6%8C%89%E7%85%A7%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%A7%E5%B0%8F%E9%A1%BA%E5%BA%8F%E8%87%AA%E5%8A%A8%E6%8E%92%E5%BA%8F%E3%80%82%E7%A7%B0%E4%B8%BA%E5%8F%AF%E6%8E%92%E5%BA%8F%E9%9B%86%E5%90%88%E3%80%82"><span class="toc-number">8.4.8.4.</span> <span class="toc-text">d）、TreeSet集合中的元素：无序不可重复，但是可以按照元素的大小顺序自动排序。称为可排序集合。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e%EF%BC%89%E3%80%81%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%9D%A5%E8%AF%B4%EF%BC%8CTreeSet%E5%8F%AF%E4%BB%A5%E6%8E%92%E5%BA%8F%E5%90%97%EF%BC%9F"><span class="toc-number">8.4.8.5.</span> <span class="toc-text">e）、对自定义的类型来说，TreeSet可以排序吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#h%EF%BC%89%E3%80%81%E5%85%88%E6%8C%89%E7%85%A7%E5%B9%B4%E9%BE%84%E5%8D%87%E5%BA%8F%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%B9%B4%E9%BE%84%E4%B8%80%E6%A0%B7%E7%9A%84%E5%86%8D%E6%8C%89%E7%85%A7%E5%A7%93%E5%90%8D%E5%8D%87%E5%BA%8F%E3%80%82"><span class="toc-number">8.4.8.6.</span> <span class="toc-text">h）、先按照年龄升序，如果年龄一样的再按照姓名升序。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i%EF%BC%89%E3%80%81TreeSet%E9%9B%86%E5%90%88%E4%B8%AD%E5%85%83%E7%B4%A0%E5%8F%AF%E6%8E%92%E5%BA%8F%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E5%99%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E3%80%82"><span class="toc-number">8.4.8.7.</span> <span class="toc-text">i）、TreeSet集合中元素可排序的第二种方式：使用比较器的方式。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">九、泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81JDK5-0%E4%B9%8B%E5%90%8E%E6%8E%A8%E5%87%BA%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E6%B3%9B%E5%9E%8B%E3%80%82%E6%B3%9B%E5%9E%8B%E8%BF%99%E7%A7%8D%E8%AF%AD%E6%B3%95%E6%9C%BA%E5%88%B6%EF%BC%8C%E6%97%A8%E5%9C%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E8%B5%B7%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%8F%AA%E6%98%AF%E7%BB%99%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%82%E8%80%83%E7%9A%84%E3%80%82-%E8%BF%90%E8%A1%8C%E9%98%B6%E6%AE%B5%E6%B3%9B%E5%9E%8B%E6%B2%A1%E7%94%A8%EF%BC%81"><span class="toc-number">9.1.</span> <span class="toc-text">1、JDK5.0之后推出的新特性：泛型。泛型这种语法机制，旨在程序编译阶段起作用，只是给编译器参考的。(运行阶段泛型没用！)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8%E4%BA%86%E6%B3%9B%E5%9E%8B%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">9.2.</span> <span class="toc-text">2、使用了泛型好处是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">9.3.</span> <span class="toc-text">3、泛型的缺点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81JDK8%E4%B9%8B%E5%90%8E%E5%BC%95%E5%85%A5%E4%BA%86%EF%BC%9A%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E6%9C%BA%E5%88%B6%E3%80%82-%E5%8F%88%E7%A7%B0%E4%B8%BA%E9%92%BB%E7%9F%B3%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">9.4.</span> <span class="toc-text">4、JDK8之后引入了：自动类型推断机制。(又称为钻石表达式)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-number">9.5.</span> <span class="toc-text">5、自定义泛型:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8foreach"><span class="toc-number">9.6.</span> <span class="toc-text">6、集合使用foreach</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81IO"><span class="toc-number">10.</span> <span class="toc-text">十、IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81IO%E6%B5%81%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AFIO%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">1、IO流，什么是IO？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81IO%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="toc-number">10.2.</span> <span class="toc-text">2、IO流的分类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81java%E4%B8%AD%E7%9A%84IO%E6%B5%81%E9%83%BD%E5%B7%B2%E7%BB%8F%E5%86%99%E5%A5%BD%E4%BA%86%EF%BC%8C%E6%88%91%E4%BB%AC%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%8D%E9%9C%80%E8%A6%81%E5%85%B3%E5%BF%83%EF%BC%8C%E6%88%91%E4%BB%AC%E6%9C%80%E4%B8%BB%E8%A6%81%E8%BF%98%E6%98%AF%E6%8E%8C%E6%8F%A1%EF%BC%8C%E5%9C%A8java%E4%B8%AD%E4%BB%A5%E5%8F%8A%E6%8F%90%E4%BE%9B3-%E4%BA%86%E5%93%AA%E4%BA%9B%E6%B5%81%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%B5%81%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C"><span class="toc-number">10.3.</span> <span class="toc-text">3、java中的IO流都已经写好了，我们程序员不需要关心，我们最主要还是掌握，在java中以及提供3 了哪些流，每个流的特点是什么，</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81java-IO%E6%B5%81%E8%BF%99%E5%9D%97%E6%9C%89%E5%9B%9B%E5%A4%A7%E5%AE%B6%E6%97%8F%EF%BC%9A"><span class="toc-number">10.4.</span> <span class="toc-text">4、java IO流这块有四大家族：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81java-io%E5%8C%85%E4%B8%8B%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%B5%81%E6%9C%8916%E4%B8%AA%EF%BC%9A"><span class="toc-number">10.5.</span> <span class="toc-text">5、java.io包下需要掌握的流有16个：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81java-io-FileInputStream"><span class="toc-number">10.6.</span> <span class="toc-text">6、java.io.FileInputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%8C%E4%B8%87%E8%83%BD%E7%9A%84%EF%BC%8C%E4%BB%BB%E4%BD%95%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%87%E4%BB%B6%E9%83%BD%E5%8F%AF%E4%BB%A5%E9%87%87%E7%94%A8%E8%BF%99%E4%B8%AA%E6%B5%81%E6%9D%A5%E8%AF%BB%E3%80%82"><span class="toc-number">10.6.1.</span> <span class="toc-text">1）、文件字节输入流，万能的，任何类型的文件都可以采用这个流来读。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81%E5%AD%97%E8%8A%82%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AE%8C%E6%88%90%E8%BE%93%E5%85%A5%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%AE%8C%E6%88%90%E8%AF%BB%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%88%E7%A1%AC%E7%9B%98%E2%80%93-gt-%E5%86%85%E5%AD%98%EF%BC%89"><span class="toc-number">10.6.2.</span> <span class="toc-text">2）、字节的方式，完成输入的操作，完成读的操作（硬盘–&gt;内存）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E3%80%81FileInputStream%E5%BE%AA%E7%8E%AF%E8%AF%BB"><span class="toc-number">10.6.3.</span> <span class="toc-text">3）、FileInputStream循环读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E3%80%81int-read-byte-b"><span class="toc-number">10.6.4.</span> <span class="toc-text">4）、int read(byte[] b)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E3%80%81%E6%9C%80%E7%BB%88%E7%89%88"><span class="toc-number">10.6.5.</span> <span class="toc-text">5）、最终版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89%E3%80%81FileInputStream%E7%B1%BB%E7%9A%84%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">10.6.6.</span> <span class="toc-text">6）、FileInputStream类的其它常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81java-io-FileInputStream"><span class="toc-number">10.7.</span> <span class="toc-text">7、java.io.FileInputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%8C%E8%B4%9F%E8%B4%A3%E5%86%99%EF%BC%9B%E4%BB%8E%E5%86%85%E5%AD%98%E5%88%B0%E7%A1%AC%E7%9B%98%E3%80%82"><span class="toc-number">10.7.1.</span> <span class="toc-text">1）、文件字节输出流，负责写；从内存到硬盘。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81%E4%BD%BF%E7%94%A8FileInputStream-FileOutputStream%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E7%9A%84%E6%8B%B7%E8%B4%9D%E3%80%82"><span class="toc-number">10.7.2.</span> <span class="toc-text">2）、使用FileInputStream + FileOutputStream完成文件的拷贝。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81java-io-Reader"><span class="toc-number">10.8.</span> <span class="toc-text">8、java.io.Reader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81java-io-Writer"><span class="toc-number">10.9.</span> <span class="toc-text">9、java.io.Writer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E4%BD%BF%E7%94%A8FileReader%E5%92%8CFileWriter%E8%BF%9B%E8%A1%8C%E6%8B%B7%E8%B4%9D%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%8F%AA%E8%83%BD%E6%8B%B7%E8%B4%9D%E6%99%AE%E9%80%9A%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">10.10.</span> <span class="toc-text">10、使用FileReader和FileWriter进行拷贝的话，只能拷贝普通文本文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81BufferedReader"><span class="toc-number">10.11.</span> <span class="toc-text">11、BufferedReader:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81%E5%B8%A6%E6%9C%89%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%9B"><span class="toc-number">10.11.1.</span> <span class="toc-text">1）、带有缓冲区的字符输入流；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81%EF%BC%9A"><span class="toc-number">10.11.2.</span> <span class="toc-text">2）、转换流：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81BufferedWriter%EF%BC%9A%E5%B8%A6%E6%9C%89%E7%BC%93%E5%86%B2%E7%9A%84%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81%E3%80%82"><span class="toc-number">10.12.</span> <span class="toc-text">12、BufferedWriter：带有缓冲的字符输出流。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%93%E5%B1%9E%EF%BC%9A"><span class="toc-number">10.13.</span> <span class="toc-text">13、数据流专属：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81java-io-DataOutputStream%EF%BC%9A%E6%95%B0%E6%8D%AE%E4%B8%93%E5%B1%9E%E7%9A%84%E6%B5%81"><span class="toc-number">10.13.1.</span> <span class="toc-text">1）、java.io.DataOutputStream：数据专属的流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81DataInputStream%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">10.13.2.</span> <span class="toc-text">2）、DataInputStream：数据字节输入流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E3%80%81java-io-PrintStream%EF%BC%9A%E6%A0%87%E5%87%86%E7%9A%84%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%9B%E9%BB%98%E8%AE%A4%E8%BE%93%E5%87%BA%E5%88%B0%E6%8E%A7%E5%88%B6%E5%8F%B0%E3%80%82"><span class="toc-number">10.13.3.</span> <span class="toc-text">3）、java.io.PrintStream：标准的字节输出流；默认输出到控制台。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81File"><span class="toc-number">10.14.</span> <span class="toc-text">14、File</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E3%80%81File%E7%B1%BB%E5%92%8C%E5%9B%9B%E5%A4%A7%E5%AE%B6%E6%97%8F%E6%B2%A1%E6%9C%89%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%89%80%E4%BB%A5File%E7%B1%BB%E4%B8%8D%E8%83%BD%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%92%8C%E5%86%99%E3%80%82"><span class="toc-number">10.14.1.</span> <span class="toc-text">1）、File类和四大家族没有关系，所以File类不能完成文件的读和写。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E3%80%81File%E5%AF%B9%E8%B1%A1%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.14.2.</span> <span class="toc-text">2）、File对象代表什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E3%80%81%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1File%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">10.14.3.</span> <span class="toc-text">3）、需要掌握File类中的常用方法。</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/13/Java-SE%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6%E7%89%88/" title="JavaSE-进阶版"><img src="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaSE-进阶版"/></a><div class="content"><a class="title" href="/2022/11/13/Java-SE%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6%E7%89%88/" title="JavaSE-进阶版">JavaSE-进阶版</a><time datetime="2022-11-13T00:00:00.000Z" title="发表于 2022-11-13 08:00:00">2022-11-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/08/hello-world/" title="Hello World"><img src="https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2022/11/08/hello-world/" title="Hello World">Hello World</a><time datetime="2022-11-08T07:51:33.779Z" title="发表于 2022-11-08 15:51:33">2022-11-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By xuguangjia</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>